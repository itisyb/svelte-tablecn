{
	"$schema": "https://shadcn-svelte.com/schema/registry-item.json",
	"name": "data-grid",
	"title": "Data Grid",
	"type": "registry:block",
	"description": "A powerful, feature-rich data grid component for Svelte 5. Port of tablecn.com",
	"dependencies": [
		"@tanstack/table-core",
		"@tanstack/virtual-core",
		"@internationalized/date",
		"bits-ui",
		"clsx",
		"tailwind-merge",
		"sonner",
		"@lucide/svelte"
	],
	"devDependencies": [
		"@lucide/svelte@^0.544.0",
		"@internationalized/date@^3.8.1",
		"bits-ui@^2.11.0"
	],
	"registryDependencies": [
		"button",
		"badge",
		"calendar",
		"checkbox",
		"input",
		"kbd",
		"popover",
		"skeleton",
		"table",
		"tooltip"
	],
	"meta": {
		"author": "itisyb",
		"originalAuthor": "tablecn.com"
	},
	"files": [
		{
			"content": "<script lang=\"ts\" generics=\"TData\">\n\timport type { Table, Column } from '@tanstack/table-core';\n\timport type { UseDataGridReturn } from '$lib/hooks/use-data-grid.svelte.js';\n\timport type { RowHeightValue, CellPosition, SearchState } from '$lib/types/data-grid.js';\n\timport { cn } from '$UTILS$.js';\n\timport { FlexRender } from '$lib/table';\n\timport DataGridRow from './data-grid-row.svelte';\n\timport DataGridColumnHeader from './data-grid-column-header.svelte';\n\timport DataGridSearch from './data-grid-search.svelte';\n\timport DataGridContextMenu from './data-grid-context-menu.svelte';\n\timport DataGridPasteDialog from './data-grid-paste-dialog.svelte';\n\timport { TooltipProvider } from '$lib/components/ui/tooltip/index.js';\n\timport Plus from '@lucide/svelte/icons/plus';\n\n\tinterface Props extends UseDataGridReturn<TData> {\n\t\theight?: number;\n\t\tclass?: string;\n\t}\n\n\tlet {\n\t\tdataGridRef = $bindable(null),\n\t\theaderRef = $bindable(null),\n\t\trowMapRef,\n\t\tfooterRef = $bindable(null),\n\t\ttable,\n\t\trowVirtualizer,\n\t\theight = 600,\n\t\tsearchState,\n\t\tcolumnSizeVars: _, // We compute this ourselves for reactivity\n\t\tonRowAdd,\n\t\tsetDataGridRef,\n\t\tsetHeaderRef,\n\t\tsetFooterRef,\n\t\tclass: className\n\t}: Props = $props();\n\n\t// Notify hook when refs change - only run once per ref\n\tlet dataGridRefSet = false;\n\tlet headerRefSet = false;\n\tlet footerRefSet = false;\n\n\t$effect(() => {\n\t\tif (dataGridRef && setDataGridRef && !dataGridRefSet) {\n\t\t\tdataGridRefSet = true;\n\t\t\tsetDataGridRef(dataGridRef);\n\t\t}\n\t});\n\n\t$effect(() => {\n\t\tif (headerRef && setHeaderRef && !headerRefSet) {\n\t\t\theaderRefSet = true;\n\t\t\tsetHeaderRef(headerRef);\n\t\t}\n\t});\n\n\t$effect(() => {\n\t\tif (footerRef && setFooterRef && !footerRefSet) {\n\t\t\tfooterRefSet = true;\n\t\t\tsetFooterRef(footerRef);\n\t\t}\n\t});\n\n\tconst rows = $derived(table.getRowModel().rows);\n\tconst columns = $derived(table.getAllColumns());\n\n\tconst meta = $derived(table.options.meta);\n\tconst rowHeight = $derived<RowHeightValue>(meta?.rowHeight ?? 'short');\n\tconst focusedCell = $derived<CellPosition | null>(meta?.focusedCell ?? null);\n\n\t// Get table state reactively for pinning/visibility/sizing\n\tconst tableState = $derived(table.getState());\n\tconst columnPinning = $derived(tableState.columnPinning);\n\tconst columnVisibility = $derived(tableState.columnVisibility);\n\tconst columnSizing = $derived(tableState.columnSizing);\n\tconst columnSizingInfo = $derived(tableState.columnSizingInfo);\n\n\t// Get visible headers reactively\n\tconst visibleLeafColumns = $derived(table.getVisibleLeafColumns());\n\n\t// Compute pinning styles reactively based on state\n\tfunction getPinningStyles(column: Column<TData, unknown>): Record<string, string | number | undefined> {\n\t\t// Read pinning state to create reactive dependency\n\t\tconst _ = columnPinning;\n\t\t\n\t\ttry {\n\t\t\tconst isPinned = column.getIsPinned();\n\t\t\tconst isLastLeftPinnedColumn = isPinned === 'left' && column.getIsLastColumn('left');\n\t\t\tconst isFirstRightPinnedColumn = isPinned === 'right' && column.getIsFirstColumn('right');\n\n\t\t\treturn {\n\t\t\t\tboxShadow: isLastLeftPinnedColumn\n\t\t\t\t\t? '-4px 0 4px -4px var(--border) inset'\n\t\t\t\t\t: isFirstRightPinnedColumn\n\t\t\t\t\t\t? '4px 0 4px -4px var(--border) inset'\n\t\t\t\t\t\t: undefined,\n\t\t\t\tleft: isPinned === 'left' ? `${column.getStart('left')}px` : undefined,\n\t\t\t\tright: isPinned === 'right' ? `${column.getAfter('right')}px` : undefined,\n\t\t\t\topacity: isPinned ? 0.97 : 1,\n\t\t\t\tposition: isPinned ? 'sticky' : 'relative',\n\t\t\t\tbackground: 'var(--background)',\n\t\t\t\tzIndex: isPinned ? 1 : undefined\n\t\t\t};\n\t\t} catch {\n\t\t\treturn {\n\t\t\t\tposition: 'relative',\n\t\t\t\tbackground: 'var(--background)',\n\t\t\t\tzIndex: undefined\n\t\t\t};\n\t\t}\n\t}\n\n\tfunction onGridContextMenu(event: MouseEvent) {\n\t\tevent.preventDefault();\n\t}\n\n\tfunction onAddRowKeyDown(event: KeyboardEvent) {\n\t\tif (!onRowAdd) return;\n\n\t\tif (event.key === 'Enter' || event.key === ' ') {\n\t\t\tevent.preventDefault();\n\t\t\tonRowAdd();\n\t\t}\n\t}\n\n\t// Handle mouseup anywhere to end drag selection\n\tfunction handleGridMouseUp() {\n\t\tmeta?.onCellMouseUp?.();\n\t}\n\n\t// Compute column size CSS variables reactively from table state\n\t// We read both columnSizing and columnSizingInfo to create reactive dependencies\n\t// columnSizingInfo updates during resize drag, columnSizing updates on release\n\tconst columnSizeStyle = $derived.by(() => {\n\t\t// Read both states to ensure reactivity when columns are resized\n\t\tconst _ = columnSizing;\n\t\tconst __ = columnSizingInfo;\n\t\t\n\t\tconst vars: string[] = [];\n\t\ttry {\n\t\t\tconst headers = table.getFlatHeaders();\n\t\t\tfor (const header of headers) {\n\t\t\t\tconst size = header.getSize();\n\t\t\t\tvars.push(`--header-${header.id}-size: ${size}`);\n\t\t\t\tvars.push(`--col-${header.column.id}-size: ${size}`);\n\t\t\t}\n\t\t} catch {\n\t\t\t// Table not ready yet\n\t\t}\n\t\treturn vars.join('; ');\n\t});\n\n\t// Get virtual items - use getters for reactive access\n\tconst virtualItems = $derived(rowVirtualizer.virtualItems);\n\tconst totalSize = $derived(rowVirtualizer.totalSize);\n\n\t// Handler for global mouseup - ends drag selection even when mouse leaves grid\n\tfunction handleWindowMouseUp() {\n\t\tmeta?.onCellMouseUp?.();\n\t}\n</script>\n\n<svelte:window onmouseup={handleWindowMouseUp} />\n\n<TooltipProvider>\n<div\n\tdata-slot=\"grid-wrapper\"\n\tclass={cn('relative flex w-full flex-col', className)}\n>\n\t{#if searchState}\n\t\t<DataGridSearch\n\t\t\tsearchOpen={searchState.searchOpen}\n\t\t\tsearchQuery={searchState.searchQuery}\n\t\t\tsearchMatches={searchState.searchMatches}\n\t\t\tmatchIndex={searchState.matchIndex}\n\t\t\tonSearchOpenChange={searchState.onSearchOpenChange}\n\t\t\tonSearchQueryChange={searchState.onSearchQueryChange}\n\t\t\tonSearch={searchState.onSearch}\n\t\t\tonNavigateToNextMatch={searchState.onNavigateToNextMatch}\n\t\t\tonNavigateToPrevMatch={searchState.onNavigateToPrevMatch}\n\t\t/>\n\t{/if}\n\n\t<DataGridContextMenu {table} />\n\n\t<DataGridPasteDialog {table} />\n\n\t<div\n\t\trole=\"grid\"\n\t\taria-label=\"Data grid\"\n\t\taria-rowcount={rows.length + (onRowAdd ? 1 : 0)}\n\t\taria-colcount={columns.length}\n\t\tdata-slot=\"grid\"\n\t\ttabindex={0}\n\t\tbind:this={dataGridRef}\n\t\tclass=\"relative grid select-none overflow-auto rounded-md border focus:outline-none\"\n\t\tstyle=\"{columnSizeStyle}; max-height: {height}px;\"\n\t\toncontextmenu={onGridContextMenu}\n\t\tonmouseup={handleGridMouseUp}\n\t>\n\t\t<!-- Header -->\n\t\t<div\n\t\t\trole=\"rowgroup\"\n\t\t\tdata-slot=\"grid-header\"\n\t\t\tbind:this={headerRef}\n\t\t\tclass=\"sticky top-0 z-10 grid border-b bg-background\"\n\t\t>\n\t\t\t{#each table.getHeaderGroups() as headerGroup, rowIndex (headerGroup.id)}\n\t\t\t\t<div\n\t\t\t\t\trole=\"row\"\n\t\t\t\t\taria-rowindex={rowIndex + 1}\n\t\t\t\t\tdata-slot=\"grid-header-row\"\n\t\t\t\t\ttabindex={-1}\n\t\t\t\t\tclass=\"flex w-full\"\n\t\t\t\t>\n\t\t\t\t\t{#each headerGroup.headers.filter(h => columnVisibility[h.column.id] !== false) as header, colIndex (header.id)}\n\t\t\t\t\t\t{@const sorting = tableState.sorting}\n\t\t\t\t\t\t{@const currentSort = sorting.find((sort) => sort.id === header.column.id)}\n\t\t\t\t\t\t{@const isSortable = header.column.getCanSort()}\n\t\t\t\t\t\t{@const pinningStyles = getPinningStyles(header.column)}\n\n\t\t\t\t\t\t<div\n\t\t\t\t\t\t\trole=\"columnheader\"\n\t\t\t\t\t\t\taria-colindex={colIndex + 1}\n\t\t\t\t\t\t\taria-sort={currentSort?.desc === false\n\t\t\t\t\t\t\t\t? 'ascending'\n\t\t\t\t\t\t\t\t: currentSort?.desc === true\n\t\t\t\t\t\t\t\t\t? 'descending'\n\t\t\t\t\t\t\t\t\t: isSortable\n\t\t\t\t\t\t\t\t\t\t? 'none'\n\t\t\t\t\t\t\t\t\t\t: undefined}\n\t\t\t\t\t\t\tdata-slot=\"grid-header-cell\"\n\t\t\t\t\t\t\ttabindex={-1}\n\t\t\t\t\t\t\tclass={cn('group relative', {\n\t\t\t\t\t\t\t\t'border-r': header.column.id !== 'select'\n\t\t\t\t\t\t\t})}\n\t\t\t\t\t\t\tstyle=\"position: {pinningStyles.position}; left: {pinningStyles.left}; right: {pinningStyles.right}; background: {pinningStyles.background}; z-index: {pinningStyles.zIndex}; width: calc(var(--header-{header.id}-size) * 1px);\"\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t{#if header.isPlaceholder}\n\t\t\t\t\t\t\t\t<!-- Empty -->\n\t\t\t\t\t\t\t{:else if typeof header.column.columnDef.header === 'function'}\n\t\t\t\t\t\t\t\t<div class=\"size-full px-3 py-1.5\">\n\t\t\t\t\t\t\t\t\t<FlexRender\n\t\t\t\t\t\t\t\t\t\tcontent={header.column.columnDef.header}\n\t\t\t\t\t\t\t\t\t\tcontext={header.getContext()}\n\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t{:else}\n\t\t\t\t\t\t\t\t<DataGridColumnHeader {header} {table} />\n\t\t\t\t\t\t\t{/if}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t{/each}\n\t\t\t\t</div>\n\t\t\t{/each}\n\t\t</div>\n\n\t\t<!-- Body -->\n\t\t<div\n\t\t\trole=\"rowgroup\"\n\t\t\tdata-slot=\"grid-body\"\n\t\t\tclass=\"relative grid\"\n\t\t\tstyle=\"height: {totalSize}px;\"\n\t\t>\n\t\t\t{#each virtualItems as virtualItem (virtualItem.key)}\n\t\t\t\t{@const virtualRowIndex = virtualItem.index}\n\t\t\t\t{@const row = rows[virtualRowIndex]}\n\t\t\t\t{#if row}\n\t\t\t\t\t<DataGridRow\n\t\t\t\t\t\t{row}\n\t\t\t\t\t\t{table}\n\t\t\t\t\t\t{columnPinning}\n\t\t\t\t\t\t{columnVisibility}\n\t\t\t\t\t\t{rowMapRef}\n\t\t\t\t\t\t{virtualRowIndex}\n\t\t\t\t\t\t{rowVirtualizer}\n\t\t\t\t\t\t{rowHeight}\n\t\t\t\t\t\t{focusedCell}\n\t\t\t\t\t\tvirtualStart={virtualItem.start}\n\t\t\t\t\t/>\n\t\t\t\t{/if}\n\t\t\t{/each}\n\t\t</div>\n\n\t\t<!-- Footer / Add Row -->\n\t\t{#if onRowAdd}\n\t\t\t<div\n\t\t\t\trole=\"rowgroup\"\n\t\t\t\tdata-slot=\"grid-footer\"\n\t\t\t\tbind:this={footerRef}\n\t\t\t\tclass=\"sticky bottom-0 z-10 grid border-t bg-background\"\n\t\t\t>\n\t\t\t\t<div\n\t\t\t\t\trole=\"row\"\n\t\t\t\t\taria-rowindex={rows.length + 2}\n\t\t\t\t\tdata-slot=\"grid-add-row\"\n\t\t\t\t\ttabindex={-1}\n\t\t\t\t\tclass=\"flex w-full\"\n\t\t\t\t>\n\t\t\t\t\t<div\n\t\t\t\t\t\trole=\"gridcell\"\n\t\t\t\t\t\ttabindex={0}\n\t\t\t\t\t\tclass=\"relative flex h-9 grow items-center bg-muted/30 transition-colors hover:bg-muted/50 focus:bg-muted/50 focus:outline-none\"\n\t\t\t\t\t\tstyle=\"width: {table.getTotalSize()}px; min-width: {table.getTotalSize()}px;\"\n\t\t\t\t\t\tonclick={onRowAdd}\n\t\t\t\t\t\tonkeydown={onAddRowKeyDown}\n\t\t\t\t\t>\n\t\t\t\t\t\t<div class=\"sticky left-0 flex items-center gap-2 px-3 text-muted-foreground\">\n\t\t\t\t\t\t\t<Plus class=\"size-3.5\" />\n\t\t\t\t\t\t\t<span class=\"text-sm\">Add row</span>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t{/if}\n\t</div>\n</div>\n</TooltipProvider>\n",
			"type": "registry:component",
			"target": "data-grid.svelte"
		},
		{
			"content": "<script lang=\"ts\" generics=\"TData\">\n\timport type { Cell, Table } from '@tanstack/table-core';\n\n\t// Cell variant imports\n\timport ShortTextCell from './cells/short-text-cell.svelte';\n\timport NumberCell from './cells/number-cell.svelte';\n\timport CheckboxCell from './cells/checkbox-cell.svelte';\n\timport LongTextCell from './cells/long-text-cell.svelte';\n\timport SelectCell from './cells/select-cell.svelte';\n\timport MultiSelectCell from './cells/multi-select-cell.svelte';\n\timport DateCell from './cells/date-cell.svelte';\n\timport UrlCell from './cells/url-cell.svelte';\n\timport FileCell from './cells/file-cell.svelte';\n\timport RowSelectCell from './cells/row-select-cell.svelte';\n\n\tinterface Props {\n\t\tcell: Cell<TData, unknown>;\n\t\ttable: Table<TData>;\n\t}\n\n\tlet { cell, table }: Props = $props();\n\n\t// Access meta directly each time - don't cache the reference\n\tconst originalRowIndex = $derived(cell.row.index);\n\n\t// Get the display row index (for filtered/sorted tables)\n\tconst displayRowIndex = $derived.by(() => {\n\t\tconst rows = table.getRowModel().rows;\n\t\tconst idx = rows.findIndex((row) => row.original === cell.row.original);\n\t\treturn idx >= 0 ? idx : originalRowIndex;\n\t});\n\n\tconst rowIndex = $derived(displayRowIndex);\n\tconst columnId = $derived(cell.column.id);\n\n\t// Derive cell state from table meta - access meta fresh each time via getter\n\tconst isFocused = $derived.by(() => {\n\t\tconst meta = table.options.meta;\n\t\tconst fc = meta?.focusedCell;\n\t\treturn fc?.rowIndex === rowIndex && fc?.columnId === columnId;\n\t});\n\tconst isEditing = $derived.by(() => {\n\t\tconst meta = table.options.meta;\n\t\tconst ec = meta?.editingCell;\n\t\treturn ec?.rowIndex === rowIndex && ec?.columnId === columnId;\n\t});\n\tconst isSelected = $derived.by(() => {\n\t\tconst meta = table.options.meta;\n\t\treturn meta?.getIsCellSelected?.(rowIndex, columnId) ?? false;\n\t});\n\tconst readOnly = $derived.by(() => {\n\t\tconst meta = table.options.meta;\n\t\treturn meta?.readOnly ?? false;\n\t});\n\n\t// Get cell variant from column def\n\tconst cellOpts = $derived(cell.column.columnDef.meta?.cell);\n\tconst variant = $derived(cellOpts?.variant ?? 'short-text');\n</script>\n\n{#if variant === 'short-text'}\n\t<ShortTextCell\n\t\t{cell}\n\t\t{table}\n\t\t{rowIndex}\n\t\t{columnId}\n\t\t{isEditing}\n\t\t{isFocused}\n\t\t{isSelected}\n\t\t{readOnly}\n\t/>\n{:else if variant === 'number'}\n\t<NumberCell\n\t\t{cell}\n\t\t{table}\n\t\t{rowIndex}\n\t\t{columnId}\n\t\t{isEditing}\n\t\t{isFocused}\n\t\t{isSelected}\n\t\t{readOnly}\n\t/>\n{:else if variant === 'checkbox'}\n\t<CheckboxCell {cell} {table} {rowIndex} {columnId} {isFocused} {isSelected} {readOnly} />\n{:else if variant === 'long-text'}\n\t<LongTextCell\n\t\t{cell}\n\t\t{table}\n\t\t{rowIndex}\n\t\t{columnId}\n\t\t{isEditing}\n\t\t{isFocused}\n\t\t{isSelected}\n\t\t{readOnly}\n\t/>\n{:else if variant === 'select'}\n\t<SelectCell\n\t\t{cell}\n\t\t{table}\n\t\t{rowIndex}\n\t\t{columnId}\n\t\t{isEditing}\n\t\t{isFocused}\n\t\t{isSelected}\n\t\t{readOnly}\n\t/>\n{:else if variant === 'multi-select'}\n\t<MultiSelectCell\n\t\t{cell}\n\t\t{table}\n\t\t{rowIndex}\n\t\t{columnId}\n\t\t{isEditing}\n\t\t{isFocused}\n\t\t{isSelected}\n\t\t{readOnly}\n\t/>\n{:else if variant === 'date'}\n\t<DateCell\n\t\t{cell}\n\t\t{table}\n\t\t{rowIndex}\n\t\t{columnId}\n\t\t{isEditing}\n\t\t{isFocused}\n\t\t{isSelected}\n\t\t{readOnly}\n\t/>\n{:else if variant === 'url'}\n\t<UrlCell\n\t\t{cell}\n\t\t{table}\n\t\t{rowIndex}\n\t\t{columnId}\n\t\t{isEditing}\n\t\t{isFocused}\n\t\t{isSelected}\n\t\t{readOnly}\n\t/>\n{:else if variant === 'file'}\n\t<FileCell\n\t\t{cell}\n\t\t{table}\n\t\t{rowIndex}\n\t\t{columnId}\n\t\t{isEditing}\n\t\t{isFocused}\n\t\t{isSelected}\n\t\t{readOnly}\n\t/>\n{:else if variant === 'row-select'}\n\t<RowSelectCell row={cell.row} {table} {rowIndex} />\n{:else}\n\t<!-- Default to short-text -->\n\t<ShortTextCell\n\t\t{cell}\n\t\t{table}\n\t\t{rowIndex}\n\t\t{columnId}\n\t\t{isEditing}\n\t\t{isFocused}\n\t\t{isSelected}\n\t\t{readOnly}\n\t/>\n{/if}\n",
			"type": "registry:component",
			"target": "data-grid-cell.svelte"
		},
		{
			"content": "<script lang=\"ts\" generics=\"TData\">\n\timport type { Cell, Table } from '@tanstack/table-core';\n\timport type { Snippet } from 'svelte';\n\timport { getCellKey, type RowHeightValue } from '$lib/types/data-grid.js';\n\timport { cn } from '$UTILS$.js';\n\n\tinterface Props {\n\t\tcell: Cell<TData, unknown>;\n\t\ttable: Table<TData>;\n\t\trowIndex: number;\n\t\tcolumnId: string;\n\t\tisEditing: boolean;\n\t\tisFocused: boolean;\n\t\tisSelected: boolean;\n\t\tclass?: string;\n\t\twrapperRef?: HTMLDivElement | null;\n\t\tonclick?: (event: MouseEvent) => void;\n\t\tonkeydown?: (event: KeyboardEvent) => void;\n\t\tondragenter?: (event: DragEvent) => void;\n\t\tondragleave?: (event: DragEvent) => void;\n\t\tondragover?: (event: DragEvent) => void;\n\t\tondrop?: (event: DragEvent) => void;\n\t\tchildren?: Snippet;\n\t}\n\n\tlet {\n\t\tcell,\n\t\ttable,\n\t\trowIndex,\n\t\tcolumnId,\n\t\tisEditing,\n\t\tisFocused,\n\t\tisSelected,\n\t\tclass: className,\n\t\twrapperRef = $bindable(null),\n\t\tonclick: onClickProp,\n\t\tonkeydown: onKeyDownProp,\n\t\tondragenter: onDragEnterProp,\n\t\tondragleave: onDragLeaveProp,\n\t\tondragover: onDragOverProp,\n\t\tondrop: onDropProp,\n\t\tchildren\n\t}: Props = $props();\n\n\tlet internalRef = $state<HTMLDivElement | null>(null);\n\t// Track if cell was focused BEFORE mousedown (to prevent single-click opening edit)\n\tlet wasFocusedOnMouseDown = $state(false);\n\n\t// Sync internal ref to bindable prop\n\t$effect(() => {\n\t\tif (internalRef) {\n\t\t\twrapperRef = internalRef;\n\t\t}\n\t});\n\n\t// Register/unregister cell in cellMapRef\n\t$effect(() => {\n\t\tconst meta = table.options.meta;\n\t\tif (internalRef && meta?.cellMapRef) {\n\t\t\tconst cellKey = getCellKey(rowIndex, columnId);\n\t\t\tmeta.cellMapRef.set(cellKey, internalRef);\n\n\t\t\treturn () => {\n\t\t\t\ttable.options.meta?.cellMapRef?.delete(cellKey);\n\t\t\t};\n\t\t}\n\t});\n\n\t// Use SvelteSet directly for fine-grained reactivity\n\t// Each cell only re-renders when ITS key changes in the set, not when other keys change\n\tconst cellKey = getCellKey(rowIndex, columnId);\n\tconst isSearchMatch = $derived.by(() => {\n\t\tconst meta = table.options.meta;\n\t\t// Direct SvelteSet.has() - Svelte tracks this specific key\n\t\treturn meta?.searchMatchSet?.has(cellKey) ?? false;\n\t});\n\tconst isActiveSearchMatch = $derived.by(() => {\n\t\tconst meta = table.options.meta;\n\t\tconst active = meta?.activeSearchMatch;\n\t\treturn active?.rowIndex === rowIndex && active?.columnId === columnId;\n\t});\n\tconst rowHeight = $derived.by<RowHeightValue>(() => {\n\t\tconst meta = table.options.meta;\n\t\treturn meta?.rowHeight ?? 'short';\n\t});\n\n\tfunction handleClick(event: MouseEvent) {\n\t\tif (!isEditing) {\n\t\t\tevent.preventDefault();\n\t\t\tonClickProp?.(event);\n\t\t\tconst meta = table.options.meta;\n\t\t\t// Only start editing if cell was ALREADY focused before this mousedown/click\n\t\t\t// Selection is handled by mousedown, so we only handle editing here\n\t\t\tif (wasFocusedOnMouseDown) {\n\t\t\t\tmeta?.onCellEditingStart?.(rowIndex, columnId);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction handleContextMenu(event: MouseEvent) {\n\t\tif (!isEditing) {\n\t\t\ttable.options.meta?.onCellContextMenu?.(rowIndex, columnId, event);\n\t\t}\n\t}\n\n\tfunction handleMouseDown(event: MouseEvent) {\n\t\tif (!isEditing) {\n\t\t\t// Capture focus state BEFORE mousedown changes it\n\t\t\twasFocusedOnMouseDown = isFocused;\n\t\t\ttable.options.meta?.onCellMouseDown?.(rowIndex, columnId, event);\n\t\t}\n\t}\n\n\tfunction handleMouseEnter(event: MouseEvent) {\n\t\tif (!isEditing) {\n\t\t\ttable.options.meta?.onCellMouseEnter?.(rowIndex, columnId, event);\n\t\t}\n\t}\n\n\tfunction handleMouseUp() {\n\t\tif (!isEditing) {\n\t\t\ttable.options.meta?.onCellMouseUp?.();\n\t\t}\n\t}\n\n\tfunction handleDoubleClick(event: MouseEvent) {\n\t\tif (!isEditing) {\n\t\t\tevent.preventDefault();\n\t\t\ttable.options.meta?.onCellDoubleClick?.(rowIndex, columnId);\n\t\t}\n\t}\n\n\tfunction handleKeyDown(event: KeyboardEvent) {\n\t\tonKeyDownProp?.(event);\n\n\t\tif (event.defaultPrevented) return;\n\n\t\t// When editing, don't interfere with navigation keys in the input\n\t\tif (isEditing) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Let navigation keys bubble up to grid handler when not editing\n\t\tif (\n\t\t\tevent.key === 'ArrowUp' ||\n\t\t\tevent.key === 'ArrowDown' ||\n\t\t\tevent.key === 'ArrowLeft' ||\n\t\t\tevent.key === 'ArrowRight' ||\n\t\t\tevent.key === 'Home' ||\n\t\t\tevent.key === 'End' ||\n\t\t\tevent.key === 'PageUp' ||\n\t\t\tevent.key === 'PageDown' ||\n\t\t\tevent.key === 'Tab' ||\n\t\t\tevent.key === 'Escape'\n\t\t) {\n\t\t\t// Don't prevent default - let the grid handler deal with it\n\t\t\treturn;\n\t\t}\n\n\t\t// Handle editing keys when focused\n\t\tif (isFocused && !isEditing) {\n\t\t\tconst meta = table.options.meta;\n\t\t\tif (event.key === 'F2' || event.key === 'Enter') {\n\t\t\t\tevent.preventDefault();\n\t\t\t\tevent.stopPropagation();\n\t\t\t\tmeta?.onCellEditingStart?.(rowIndex, columnId);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (event.key === ' ') {\n\t\t\t\tevent.preventDefault();\n\t\t\t\tevent.stopPropagation();\n\t\t\t\tmeta?.onCellEditingStart?.(rowIndex, columnId);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Printable character starts editing\n\t\t\tif (event.key.length === 1 && !event.ctrlKey && !event.metaKey) {\n\t\t\t\tevent.preventDefault();\n\t\t\t\tevent.stopPropagation();\n\t\t\t\tmeta?.onCellEditingStart?.(rowIndex, columnId);\n\t\t\t}\n\t\t}\n\t}\n</script>\n\n<div\n\tbind:this={internalRef}\n\trole=\"button\"\n\tdata-slot=\"grid-cell-wrapper\"\n\tdata-editing={isEditing ? '' : undefined}\n\tdata-focused={isFocused ? '' : undefined}\n\tdata-selected={isSelected ? '' : undefined}\n\ttabindex={isFocused && !isEditing ? 0 : -1}\n\tclass={cn(\n\t\t'size-full px-2 py-1.5 text-left text-sm outline-none has-data-[slot=checkbox]:pt-2.5',\n\t\t{\n\t\t\t'ring-1 ring-ring ring-inset': isFocused,\n\t\t\t'bg-yellow-100 dark:bg-yellow-900/30': isSearchMatch && !isActiveSearchMatch,\n\t\t\t'bg-orange-200 dark:bg-orange-900/50': isActiveSearchMatch,\n\t\t\t'bg-primary/10': isSelected && !isFocused && !isEditing,\n\t\t\t'cursor-default': !isEditing,\n\t\t\t'**:data-[slot=grid-cell-content]:line-clamp-1': !isEditing && rowHeight === 'short',\n\t\t\t'**:data-[slot=grid-cell-content]:line-clamp-2': !isEditing && rowHeight === 'medium',\n\t\t\t'**:data-[slot=grid-cell-content]:line-clamp-3': !isEditing && rowHeight === 'tall',\n\t\t\t'**:data-[slot=grid-cell-content]:line-clamp-4': !isEditing && rowHeight === 'extra-tall'\n\t\t},\n\t\tclassName\n\t)}\n\tonclick={handleClick}\n\toncontextmenu={handleContextMenu}\n\tondblclick={handleDoubleClick}\n\tonmousedown={handleMouseDown}\n\tonmouseenter={handleMouseEnter}\n\tonmouseup={handleMouseUp}\n\tonkeydown={handleKeyDown}\n\tondragenter={onDragEnterProp}\n\tondragleave={onDragLeaveProp}\n\tondragover={onDragOverProp}\n\tondrop={onDropProp}\n>\n\t{@render children?.()}\n</div>\n",
			"type": "registry:component",
			"target": "data-grid-cell-wrapper.svelte"
		},
		{
			"content": "<script lang=\"ts\" generics=\"TData, TValue\">\n\timport type { Header, Table, ColumnSort, SortDirection, SortingState } from '@tanstack/table-core';\n\timport type { CellOpts } from '$lib/types/data-grid.js';\n\timport { cn } from '$UTILS$.js';\n\timport {\n\t\tDropdownMenu,\n\t\tDropdownMenuCheckboxItem,\n\t\tDropdownMenuContent,\n\t\tDropdownMenuItem,\n\t\tDropdownMenuSeparator,\n\t\tDropdownMenuTrigger\n\t} from '$lib/components/ui/dropdown-menu/index.js';\n\timport { Tooltip, TooltipContent, TooltipTrigger } from '$lib/components/ui/tooltip/index.js';\n\timport type { Component } from 'svelte';\n\n\t// Icons\n\timport Baseline from '@lucide/svelte/icons/baseline';\n\timport TextInitial from '@lucide/svelte/icons/text';\n\timport Hash from '@lucide/svelte/icons/hash';\n\timport Link from '@lucide/svelte/icons/link';\n\timport CheckSquare from '@lucide/svelte/icons/check-square';\n\timport List from '@lucide/svelte/icons/list';\n\timport ListChecks from '@lucide/svelte/icons/list-checks';\n\timport Calendar from '@lucide/svelte/icons/calendar';\n\timport FileIcon from '@lucide/svelte/icons/file';\n\timport ChevronDown from '@lucide/svelte/icons/chevron-down';\n\timport ChevronUp from '@lucide/svelte/icons/chevron-up';\n\timport ArrowDown from '@lucide/svelte/icons/arrow-down';\n\timport ArrowUp from '@lucide/svelte/icons/arrow-up';\n\timport EyeOff from '@lucide/svelte/icons/eye-off';\n\timport Pin from '@lucide/svelte/icons/pin';\n\timport PinOff from '@lucide/svelte/icons/pin-off';\n\timport X from '@lucide/svelte/icons/x';\n\n\tinterface Props {\n\t\theader: Header<TData, TValue>;\n\t\ttable: Table<TData>;\n\t\tclass?: string;\n\t}\n\n\tlet { header, table, class: className }: Props = $props();\n\n\tconst column = $derived(header.column);\n\tconst label = $derived.by(() => {\n\t\tif (column.columnDef.meta?.label) {\n\t\t\treturn column.columnDef.meta.label;\n\t\t}\n\t\tif (typeof column.columnDef.header === 'string') {\n\t\t\treturn column.columnDef.header;\n\t\t}\n\t\treturn column.id;\n\t});\n\n\tconst isAnyColumnResizing = $derived(table.getState().columnSizingInfo?.isResizingColumn ?? false);\n\n\tconst cellVariant = $derived(column.columnDef.meta?.cell);\n\tconst columnVariant = $derived.by(() => getColumnVariant(cellVariant?.variant));\n\n\t// Get pinning state reactively from table state\n\tconst columnPinning = $derived(table.getState().columnPinning);\n\tconst pinnedPosition = $derived.by(() => {\n\t\t// Read columnPinning to create dependency, then call column method\n\t\tconst _ = columnPinning;\n\t\treturn column.getIsPinned();\n\t});\n\tconst isPinnedLeft = $derived(pinnedPosition === 'left');\n\tconst isPinnedRight = $derived(pinnedPosition === 'right');\n\n\t// Get current sort state for this column\n\tconst currentSort = $derived.by(() => {\n\t\tconst sortState = table.getState().sorting;\n\t\treturn sortState.find((sort) => sort.id === column.id);\n\t});\n\tconst isSorted = $derived(!!currentSort);\n\tconst sortDirection = $derived(currentSort ? (currentSort.desc ? 'desc' : 'asc') : null);\n\n\t// Check if this column has an active filter\n\tconst hasActiveFilter = $derived.by(() => {\n\t\tconst filters = table.getState().columnFilters;\n\t\treturn filters.some((f) => f.id === column.id);\n\t});\n\n\t// Safe getter for column size that handles SSR edge cases\n\tconst columnSize = $derived.by(() => {\n\t\ttry {\n\t\t\treturn column.getSize();\n\t\t} catch {\n\t\t\treturn column.columnDef.size ?? 150;\n\t\t}\n\t});\n\n\t// Safe getter for resizing state that handles SSR edge cases\n\tconst isColumnResizing = $derived.by(() => {\n\t\ttry {\n\t\t\treturn header.column.getIsResizing();\n\t\t} catch {\n\t\t\treturn false;\n\t\t}\n\t});\n\n\t// Safe getter for canResize that handles SSR edge cases\n\tconst canResize = $derived.by(() => {\n\t\ttry {\n\t\t\treturn header.column.getCanResize();\n\t\t} catch {\n\t\t\treturn false;\n\t\t}\n\t});\n\n\tfunction getColumnVariant(variant?: CellOpts['variant']): {\n\t\ticon: Component<{ class?: string }>;\n\t\tlabel: string;\n\t} | null {\n\t\tswitch (variant) {\n\t\t\tcase 'short-text':\n\t\t\t\treturn { icon: Baseline, label: 'Short text' };\n\t\t\tcase 'long-text':\n\t\t\t\treturn { icon: TextInitial, label: 'Long text' };\n\t\t\tcase 'number':\n\t\t\t\treturn { icon: Hash, label: 'Number' };\n\t\t\tcase 'url':\n\t\t\t\treturn { icon: Link, label: 'URL' };\n\t\t\tcase 'checkbox':\n\t\t\t\treturn { icon: CheckSquare, label: 'Checkbox' };\n\t\t\tcase 'select':\n\t\t\t\treturn { icon: List, label: 'Select' };\n\t\t\tcase 'multi-select':\n\t\t\t\treturn { icon: ListChecks, label: 'Multi-select' };\n\t\t\tcase 'date':\n\t\t\t\treturn { icon: Calendar, label: 'Date' };\n\t\t\tcase 'file':\n\t\t\t\treturn { icon: FileIcon, label: 'File' };\n\t\t\tdefault:\n\t\t\t\treturn null;\n\t\t}\n\t}\n\n\tfunction onSortingChange(direction: SortDirection) {\n\t\ttable.setSorting((prev: SortingState) => {\n\t\t\tconst existingSortIndex = prev.findIndex((sort) => sort.id === column.id);\n\t\t\tconst newSort: ColumnSort = {\n\t\t\t\tid: column.id,\n\t\t\t\tdesc: direction === 'desc'\n\t\t\t};\n\n\t\t\tif (existingSortIndex >= 0) {\n\t\t\t\tconst updated = [...prev];\n\t\t\t\tupdated[existingSortIndex] = newSort;\n\t\t\t\treturn updated;\n\t\t\t} else {\n\t\t\t\treturn [...prev, newSort];\n\t\t\t}\n\t\t});\n\t}\n\n\tfunction onSortRemove() {\n\t\ttable.setSorting((prev: SortingState) => prev.filter((sort) => sort.id !== column.id));\n\t}\n\n\tfunction onLeftPin() {\n\t\tcolumn.pin('left');\n\t}\n\n\tfunction onRightPin() {\n\t\tcolumn.pin('right');\n\t}\n\n\tfunction onUnpin() {\n\t\tcolumn.pin(false);\n\t}\n\n\tfunction onTriggerPointerDown(event: PointerEvent) {\n\t\tif (event.defaultPrevented) return;\n\n\t\tif (event.button !== 0) {\n\t\t\treturn;\n\t\t}\n\t\ttable.options.meta?.onColumnClick?.(column.id);\n\t}\n\n\t// Resizer\n\tconst defaultColumnDef = $derived(table._getDefaultColumnDef());\n\n\tfunction onResizerDoubleClick() {\n\t\theader.column.resetSize();\n\t}\n</script>\n\n<DropdownMenu>\n\t<DropdownMenuTrigger\n\t\tclass={cn(\n\t\t\t'flex size-full items-center justify-between gap-2 p-2 text-sm hover:bg-accent/40 data-[state=open]:bg-accent/40 [&_svg]:size-4',\n\t\t\tisAnyColumnResizing && 'pointer-events-none',\n\t\t\tclassName\n\t\t)}\n\t\tonpointerdown={onTriggerPointerDown}\n\t>\n\t\t<!-- Left side: icon + label -->\n\t\t<div class=\"flex min-w-0 flex-1 items-center gap-1.5\">\n\t\t\t{#if columnVariant}\n\t\t\t\t{@const Icon = columnVariant.icon}\n\t\t\t\t<Tooltip delayDuration={100}>\n\t\t\t\t\t<TooltipTrigger>\n\t\t\t\t\t\t{#snippet child({ props })}\n\t\t\t\t\t\t\t<span {...props}>\n\t\t\t\t\t\t\t\t<Icon class=\"size-3.5 shrink-0 text-muted-foreground\" />\n\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t{/snippet}\n\t\t\t\t\t</TooltipTrigger>\n\t\t\t\t\t<TooltipContent side=\"top\">\n\t\t\t\t\t\t<p>{columnVariant.label}</p>\n\t\t\t\t\t</TooltipContent>\n\t\t\t\t</Tooltip>\n\t\t\t{/if}\n\t\t\t<span class=\"truncate\">{label}</span>\n\t\t\t{#if hasActiveFilter}\n\t\t\t\t<span class=\"ml-1 size-1.5 shrink-0 rounded-full bg-primary\" aria-label=\"Filtered\"></span>\n\t\t\t{/if}\n\t\t\t{#if isSorted}\n\t\t\t\t{#if sortDirection === 'asc'}\n\t\t\t\t\t<ArrowUp class=\"size-3.5 shrink-0 text-foreground\" />\n\t\t\t\t{:else}\n\t\t\t\t\t<ArrowDown class=\"size-3.5 shrink-0 text-foreground\" />\n\t\t\t\t{/if}\n\t\t\t{/if}\n\t\t</div>\n\t\t<!-- Right side: chevron -->\n\t\t<ChevronDown class=\"shrink-0 text-muted-foreground\" />\n\t</DropdownMenuTrigger>\n\t<DropdownMenuContent align=\"start\" sideOffset={0} class=\"w-60\">\n\t\t{#if column.getCanSort()}\n\t\t\t<DropdownMenuCheckboxItem\n\t\t\t\tclass=\"relative pr-8 pl-2 [&>span:first-child]:right-2 [&>span:first-child]:left-auto [&_svg]:text-muted-foreground\"\n\t\t\t\tchecked={column.getIsSorted() === 'asc'}\n\t\t\t\tonCheckedChange={() => onSortingChange('asc')}\n\t\t\t>\n\t\t\t\t<ChevronUp class=\"mr-2 size-4\" />\n\t\t\t\tSort asc\n\t\t\t</DropdownMenuCheckboxItem>\n\t\t\t<DropdownMenuCheckboxItem\n\t\t\t\tclass=\"relative pr-8 pl-2 [&>span:first-child]:right-2 [&>span:first-child]:left-auto [&_svg]:text-muted-foreground\"\n\t\t\t\tchecked={column.getIsSorted() === 'desc'}\n\t\t\t\tonCheckedChange={() => onSortingChange('desc')}\n\t\t\t>\n\t\t\t\t<ChevronDown class=\"mr-2 size-4\" />\n\t\t\t\tSort desc\n\t\t\t</DropdownMenuCheckboxItem>\n\t\t\t{#if column.getIsSorted()}\n\t\t\t\t<DropdownMenuItem onclick={onSortRemove}>\n\t\t\t\t\t<X class=\"mr-2 size-4\" />\n\t\t\t\t\tRemove sort\n\t\t\t\t</DropdownMenuItem>\n\t\t\t{/if}\n\t\t{/if}\n\t\t{#if column.getCanPin()}\n\t\t\t{#if column.getCanSort()}\n\t\t\t\t<DropdownMenuSeparator />\n\t\t\t{/if}\n\n\t\t\t{#if isPinnedLeft}\n\t\t\t\t<DropdownMenuItem class=\"[&_svg]:text-muted-foreground\" onclick={onUnpin}>\n\t\t\t\t\t<PinOff class=\"mr-2 size-4\" />\n\t\t\t\t\tUnpin from left\n\t\t\t\t</DropdownMenuItem>\n\t\t\t{:else}\n\t\t\t\t<DropdownMenuItem class=\"[&_svg]:text-muted-foreground\" onclick={onLeftPin}>\n\t\t\t\t\t<Pin class=\"mr-2 size-4\" />\n\t\t\t\t\tPin to left\n\t\t\t\t</DropdownMenuItem>\n\t\t\t{/if}\n\t\t\t{#if isPinnedRight}\n\t\t\t\t<DropdownMenuItem class=\"[&_svg]:text-muted-foreground\" onclick={onUnpin}>\n\t\t\t\t\t<PinOff class=\"mr-2 size-4\" />\n\t\t\t\t\tUnpin from right\n\t\t\t\t</DropdownMenuItem>\n\t\t\t{:else}\n\t\t\t\t<DropdownMenuItem class=\"[&_svg]:text-muted-foreground\" onclick={onRightPin}>\n\t\t\t\t\t<Pin class=\"mr-2 size-4\" />\n\t\t\t\t\tPin to right\n\t\t\t\t</DropdownMenuItem>\n\t\t\t{/if}\n\t\t{/if}\n\t\t{#if column.getCanHide()}\n\t\t\t<DropdownMenuSeparator />\n\t\t\t<DropdownMenuCheckboxItem\n\t\t\t\tclass=\"relative pr-8 pl-2 [&>span:first-child]:right-2 [&>span:first-child]:left-auto [&_svg]:text-muted-foreground\"\n\t\t\t\tchecked={!column.getIsVisible()}\n\t\t\t\tonCheckedChange={() => column.toggleVisibility(false)}\n\t\t\t>\n\t\t\t\t<EyeOff class=\"mr-2 size-4\" />\n\t\t\t\tHide column\n\t\t\t</DropdownMenuCheckboxItem>\n\t\t{/if}\n\t</DropdownMenuContent>\n</DropdownMenu>\n\n{#if canResize}\n\t<!-- svelte-ignore a11y_no_noninteractive_tabindex -->\n\t<!-- svelte-ignore a11y_no_noninteractive_element_interactions -->\n\t<div\n\t\trole=\"separator\"\n\t\taria-orientation=\"vertical\"\n\t\taria-label={`Resize ${label} column`}\n\t\taria-valuenow={columnSize}\n\t\taria-valuemin={defaultColumnDef.minSize}\n\t\taria-valuemax={defaultColumnDef.maxSize}\n\t\ttabindex={0}\n\t\tclass={cn(\n\t\t\t'-right-px absolute top-0 z-50 h-full w-1 cursor-col-resize touch-none select-none bg-border transition-opacity after:absolute after:inset-y-0 after:-left-1 after:h-full after:w-3 after:content-[\\'\\'] hover:bg-primary focus:bg-primary focus:outline-none',\n\t\t\tisColumnResizing ? 'bg-primary opacity-100' : 'opacity-0 hover:opacity-100'\n\t\t)}\n\t\tondblclick={onResizerDoubleClick}\n\t\tonmousedown={header.getResizeHandler()}\n\t\tontouchstart={header.getResizeHandler()}\n\t></div>\n{/if}\n",
			"type": "registry:component",
			"target": "data-grid-column-header.svelte"
		},
		{
			"content": "<script lang=\"ts\" generics=\"TData\">\n\timport type { Table } from '@tanstack/table-core';\n\timport type { UpdateCell } from '$lib/types/data-grid.js';\n\timport { parseCellKey } from '$lib/types/data-grid.js';\n\timport {\n\t\tDropdownMenu,\n\t\tDropdownMenuContent,\n\t\tDropdownMenuItem,\n\t\tDropdownMenuSeparator,\n\t\tDropdownMenuTrigger\n\t} from '$lib/components/ui/dropdown-menu/index.js';\n\timport Copy from '@lucide/svelte/icons/copy';\n\timport Scissors from '@lucide/svelte/icons/scissors';\n\timport Eraser from '@lucide/svelte/icons/eraser';\n\timport Trash2 from '@lucide/svelte/icons/trash-2';\n\timport { toast } from 'svelte-sonner';\n\n\tinterface Props {\n\t\ttable: Table<TData>;\n\t}\n\n\tlet { table }: Props = $props();\n\n\tconst meta = $derived(table.options.meta);\n\tconst contextMenu = $derived(meta?.contextMenu);\n\tconst onContextMenuOpenChange = $derived(meta?.onContextMenuOpenChange);\n\tconst selectionState = $derived(meta?.selectionState);\n\tconst dataGridRef = $derived(meta?.dataGridRef);\n\tconst onDataUpdate = $derived(meta?.onDataUpdate);\n\tconst onRowsDelete = $derived(meta?.onRowsDelete);\n\tconst onCellsCopy = $derived(meta?.onCellsCopy);\n\tconst onCellsCut = $derived(meta?.onCellsCut);\n\tconst readOnly = $derived(meta?.readOnly ?? false);\n\n\t// Trigger style to position the menu at the context menu coordinates\n\tconst triggerStyle = $derived.by(() => {\n\t\tif (!contextMenu) return '';\n\t\treturn `position: fixed; left: ${contextMenu.x}px; top: ${contextMenu.y}px; width: 1px; height: 1px; padding: 0; margin: 0; border: none; background: transparent; pointer-events: none; opacity: 0;`;\n\t});\n\n\tfunction onCloseAutoFocus(event: Event) {\n\t\tevent.preventDefault();\n\t\tif (dataGridRef instanceof HTMLElement) {\n\t\t\tdataGridRef.focus();\n\t\t}\n\t}\n\n\tfunction onCopy() {\n\t\tonCellsCopy?.();\n\t}\n\n\tfunction onCut() {\n\t\tonCellsCut?.();\n\t}\n\n\tfunction onClear() {\n\t\tif (!selectionState?.selectedCells || selectionState.selectedCells.size === 0) return;\n\n\t\tconst updates: UpdateCell[] = [];\n\t\tconst tableColumns = table.getAllColumns();\n\n\t\tfor (const cellKey of selectionState.selectedCells) {\n\t\t\tconst { rowIndex, columnId } = parseCellKey(cellKey);\n\n\t\t\tconst column = tableColumns.find((col) => col.id === columnId);\n\t\t\tconst cellVariant = column?.columnDef?.meta?.cell?.variant;\n\n\t\t\tlet emptyValue: unknown = '';\n\t\t\tif (cellVariant === 'multi-select' || cellVariant === 'file') {\n\t\t\t\temptyValue = [];\n\t\t\t} else if (cellVariant === 'number' || cellVariant === 'date') {\n\t\t\t\temptyValue = null;\n\t\t\t} else if (cellVariant === 'checkbox') {\n\t\t\t\temptyValue = false;\n\t\t\t}\n\n\t\t\tupdates.push({ rowIndex, columnId, value: emptyValue });\n\t\t}\n\n\t\tonDataUpdate?.(updates);\n\t\tconst cellCount = updates.length;\n\t\ttoast.success(`${cellCount} cell${cellCount !== 1 ? 's' : ''} cleared`);\n\t}\n\n\tasync function onDelete() {\n\t\tif (!selectionState?.selectedCells || selectionState.selectedCells.size === 0) return;\n\n\t\tconst rowIndices = new Set<number>();\n\t\tfor (const cellKey of selectionState.selectedCells) {\n\t\t\tconst { rowIndex } = parseCellKey(cellKey);\n\t\t\trowIndices.add(rowIndex);\n\t\t}\n\n\t\tconst rowIndicesArray = Array.from(rowIndices).sort((a, b) => a - b);\n\t\tawait onRowsDelete?.(rowIndicesArray);\n\t\tconst rowCount = rowIndicesArray.length;\n\t\ttoast.success(`${rowCount} row${rowCount !== 1 ? 's' : ''} deleted`);\n\t}\n</script>\n\n{#if contextMenu}\n\t<DropdownMenu open={contextMenu.open} onOpenChange={onContextMenuOpenChange}>\n\t\t<DropdownMenuTrigger style={triggerStyle}></DropdownMenuTrigger>\n\t\t<DropdownMenuContent\n\t\t\tdata-grid-popover=\"\"\n\t\t\talign=\"start\"\n\t\t\tclass=\"w-48\"\n\t\t\tonCloseAutoFocus={onCloseAutoFocus}\n\t\t>\n\t\t\t<DropdownMenuItem onSelect={onCopy}>\n\t\t\t\t<Copy class=\"mr-2 size-4\" />\n\t\t\t\tCopy\n\t\t\t</DropdownMenuItem>\n\t\t\t<DropdownMenuItem onSelect={onCut} disabled={readOnly}>\n\t\t\t\t<Scissors class=\"mr-2 size-4\" />\n\t\t\t\tCut\n\t\t\t</DropdownMenuItem>\n\t\t\t<DropdownMenuItem onSelect={onClear} disabled={readOnly}>\n\t\t\t\t<Eraser class=\"mr-2 size-4\" />\n\t\t\t\tClear\n\t\t\t</DropdownMenuItem>\n\t\t\t{#if onRowsDelete}\n\t\t\t\t<DropdownMenuSeparator />\n\t\t\t\t<DropdownMenuItem class=\"text-destructive focus:text-destructive\" onSelect={onDelete}>\n\t\t\t\t\t<Trash2 class=\"mr-2 size-4\" />\n\t\t\t\t\tDelete rows\n\t\t\t\t</DropdownMenuItem>\n\t\t\t{/if}\n\t\t</DropdownMenuContent>\n\t</DropdownMenu>\n{/if}\n",
			"type": "registry:component",
			"target": "data-grid-context-menu.svelte"
		},
		{
			"content": "<script lang=\"ts\" generics=\"TData\">\n\timport type { Table, ColumnFilter, Column } from '@tanstack/table-core';\n\timport type { Option, FilterOperator, FilterValue, CellSelectOption } from '$lib/types/data-grid.js';\n\timport { dndzone, SHADOW_ITEM_MARKER_PROPERTY_NAME } from 'svelte-dnd-action';\n\timport { cn } from '$UTILS$.js';\n\timport { getDefaultOperator, getOperatorsForVariant } from '$lib/data-grid-filters.js';\n\timport { Button } from '$lib/components/ui/button/index.js';\n\timport { Badge } from '$lib/components/ui/badge/index.js';\n\timport { Input } from '$lib/components/ui/input/index.js';\n\timport {\n\t\tPopover,\n\t\tPopoverContent,\n\t\tPopoverTrigger\n\t} from '$lib/components/ui/popover/index.js';\n\timport {\n\t\tCommand,\n\t\tCommandEmpty,\n\t\tCommandGroup,\n\t\tCommandInput,\n\t\tCommandItem,\n\t\tCommandList\n\t} from '$lib/components/ui/command/index.js';\n\timport {\n\t\tSelect,\n\t\tSelectContent,\n\t\tSelectItem,\n\t\tSelectTrigger\n\t} from '$lib/components/ui/select/index.js';\n\timport { Calendar } from '$lib/components/ui/calendar/index.js';\n\timport { CalendarDate, type DateValue, parseDate } from '@internationalized/date';\n\n\t// Icons\n\timport ListFilter from '@lucide/svelte/icons/list-filter';\n\timport ChevronsUpDown from '@lucide/svelte/icons/chevrons-up-down';\n\timport GripVertical from '@lucide/svelte/icons/grip-vertical';\n\timport Trash2 from '@lucide/svelte/icons/trash-2';\n\timport Check from '@lucide/svelte/icons/check';\n\timport CalendarIcon from '@lucide/svelte/icons/calendar';\n\n\tconst FILTER_SHORTCUT_KEY = 'f';\n\tconst REMOVE_FILTER_SHORTCUTS = ['backspace', 'delete'];\n\n\tinterface Props {\n\t\ttable: Table<TData>;\n\t\talign?: 'start' | 'center' | 'end';\n\t\tclass?: string;\n\t}\n\n\tlet { table, align = 'start', class: className }: Props = $props();\n\n\tlet open = $state(false);\n\n\tconst columnFilters = $derived(table.getState().columnFilters);\n\n\t// Create a mutable copy for DnD\n\tlet filterItems = $state<ColumnFilter[]>([]);\n\n\t$effect(() => {\n\t\tfilterItems = [...columnFilters];\n\t});\n\n\tconst { columnLabels, columns, columnVariants } = $derived.by(() => {\n\t\tconst labels = new Map<string, string>();\n\t\tconst variants = new Map<string, string>();\n\t\tconst filteringIds = new Set(columnFilters.map((f) => f.id));\n\t\tconst availableColumns: Option[] = [];\n\n\t\tfor (const column of table.getAllColumns()) {\n\t\t\tif (!column.getCanFilter()) continue;\n\n\t\t\tconst label = column.columnDef.meta?.label ?? column.id;\n\t\t\tconst variant = column.columnDef.meta?.cell?.variant ?? 'short-text';\n\t\t\tlabels.set(column.id, label);\n\t\t\tvariants.set(column.id, variant);\n\n\t\t\tif (!filteringIds.has(column.id)) {\n\t\t\t\tavailableColumns.push({ label, value: column.id });\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tcolumnLabels: labels,\n\t\t\tcolumns: availableColumns,\n\t\t\tcolumnVariants: variants\n\t\t};\n\t});\n\n\tfunction onFilterAdd() {\n\t\tconst firstColumn = columns[0];\n\t\tif (!firstColumn) return;\n\n\t\tconst variant = columnVariants.get(firstColumn.value) ?? 'short-text';\n\t\tconst defaultOperator = getDefaultOperator(variant);\n\n\t\ttable.setColumnFilters((prevFilters) => [\n\t\t\t...prevFilters,\n\t\t\t{\n\t\t\t\tid: firstColumn.value,\n\t\t\t\tvalue: {\n\t\t\t\t\toperator: defaultOperator,\n\t\t\t\t\tvalue: ''\n\t\t\t\t}\n\t\t\t}\n\t\t]);\n\t}\n\n\tfunction onFilterUpdate(filterId: string, updates: Partial<ColumnFilter>) {\n\t\ttable.setColumnFilters((prevFilters) => {\n\t\t\tif (!prevFilters) return prevFilters;\n\t\t\treturn prevFilters.map((filter) =>\n\t\t\t\tfilter.id === filterId ? { ...filter, ...updates } : filter\n\t\t\t);\n\t\t});\n\t}\n\n\tfunction onFilterRemove(filterId: string) {\n\t\ttable.setColumnFilters((prevFilters) =>\n\t\t\tprevFilters.filter((item) => item.id !== filterId)\n\t\t);\n\t}\n\n\tfunction onFiltersReset() {\n\t\ttable.setColumnFilters(table.initialState.columnFilters ?? []);\n\t}\n\n\tfunction handleKeyDown(event: KeyboardEvent) {\n\t\tif (\n\t\t\tevent.target instanceof HTMLInputElement ||\n\t\t\tevent.target instanceof HTMLTextAreaElement ||\n\t\t\t(event.target instanceof HTMLElement && event.target.contentEditable === 'true')\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (\n\t\t\tevent.key.toLowerCase() === FILTER_SHORTCUT_KEY &&\n\t\t\t(event.ctrlKey || event.metaKey) &&\n\t\t\tevent.shiftKey\n\t\t) {\n\t\t\tevent.preventDefault();\n\t\t\topen = !open;\n\t\t}\n\t}\n\n\tfunction onTriggerKeyDown(event: KeyboardEvent) {\n\t\tif (REMOVE_FILTER_SHORTCUTS.includes(event.key.toLowerCase()) && columnFilters.length > 0) {\n\t\t\tevent.preventDefault();\n\t\t\tonFiltersReset();\n\t\t}\n\t}\n\n\tfunction handleDndConsider(e: CustomEvent<{ items: ColumnFilter[] }>) {\n\t\tfilterItems = e.detail.items;\n\t}\n\n\tfunction handleDndFinalize(e: CustomEvent<{ items: ColumnFilter[] }>) {\n\t\tfilterItems = e.detail.items;\n\t\t// Filter out shadow items and update table filters\n\t\tconst cleanItems = filterItems.filter((item) => !(item as unknown as Record<string, unknown>)[SHADOW_ITEM_MARKER_PROPERTY_NAME]);\n\t\ttable.setColumnFilters(cleanItems);\n\t}\n\n\tfunction getColumnOptions(columnId: string): CellSelectOption[] {\n\t\tconst column = table.getColumn(columnId);\n\t\tconst cellVariant = column?.columnDef.meta?.cell;\n\t\tif (cellVariant?.variant === 'select' || cellVariant?.variant === 'multi-select') {\n\t\t\treturn cellVariant.options;\n\t\t}\n\t\treturn [];\n\t}\n\n\tfunction parseISOToCalendarDate(isoString: string | undefined): DateValue | undefined {\n\t\tif (!isoString) return undefined;\n\t\ttry {\n\t\t\t// Extract just the date part (YYYY-MM-DD)\n\t\t\tconst dateStr = isoString.split('T')[0];\n\t\t\tif (dateStr) {\n\t\t\t\treturn parseDate(dateStr);\n\t\t\t}\n\t\t} catch {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tfunction calendarDateToISO(date: DateValue | undefined): string | undefined {\n\t\tif (!date) return undefined;\n\t\treturn `${date.year}-${String(date.month).padStart(2, '0')}-${String(date.day).padStart(2, '0')}T00:00:00.000Z`;\n\t}\n\n</script>\n\n<svelte:window onkeydown={handleKeyDown} />\n\n<Popover bind:open>\n\t<PopoverTrigger>\n\t\t{#snippet child({ props })}\n\t\t\t<Button\n\t\t\t\t{...props}\n\t\t\t\tvariant=\"outline\"\n\t\t\t\tsize=\"sm\"\n\t\t\t\tclass={cn('font-normal', className)}\n\t\t\t\tonkeydown={onTriggerKeyDown}\n\t\t\t>\n\t\t\t\t<ListFilter class=\"text-muted-foreground\" />\n\t\t\t\tFilter\n\t\t\t\t{#if columnFilters.length > 0}\n\t\t\t\t\t<Badge\n\t\t\t\t\t\tvariant=\"secondary\"\n\t\t\t\t\t\tclass=\"h-[18.24px] rounded-[3.2px] px-[5.12px] font-mono font-normal text-[10.4px]\"\n\t\t\t\t\t>\n\t\t\t\t\t\t{columnFilters.length}\n\t\t\t\t\t</Badge>\n\t\t\t\t{/if}\n\t\t\t</Button>\n\t\t{/snippet}\n\t</PopoverTrigger>\n\t<PopoverContent\n\t\t{align}\n\t\tclass=\"flex w-full max-w-[var(--radix-popover-content-available-width)] flex-col gap-3.5 p-4 sm:min-w-[480px]\"\n\t>\n\t\t<div class=\"flex flex-col gap-1\">\n\t\t\t<h4 class=\"font-medium leading-none\">\n\t\t\t\t{columnFilters.length > 0 ? 'Filter by' : 'No filters applied'}\n\t\t\t</h4>\n\t\t\t<p class={cn('text-muted-foreground text-sm', columnFilters.length > 0 && 'sr-only')}>\n\t\t\t\t{columnFilters.length > 0\n\t\t\t\t\t? 'Modify filters to narrow down your data.'\n\t\t\t\t\t: 'Add filters to narrow down your data.'}\n\t\t\t</p>\n\t\t</div>\n\t\t{#if filterItems.length > 0}\n\t\t\t<ul\n\t\t\t\tclass=\"flex max-h-[400px] flex-col gap-2 overflow-y-auto p-1\"\n\t\t\t\tuse:dndzone={{\n\t\t\t\t\titems: filterItems,\n\t\t\t\t\tflipDurationMs: 150,\n\t\t\t\t\tdropTargetStyle: {},\n\t\t\t\t\ttype: 'filter-items'\n\t\t\t\t}}\n\t\t\t\tonconsider={handleDndConsider}\n\t\t\t\tonfinalize={handleDndFinalize}\n\t\t\t>\n\t\t\t\t{#each filterItems as filter, index (filter.id)}\n\t\t\t\t\t{@const variant = columnVariants.get(filter.id) ?? 'short-text'}\n\t\t\t\t\t{@const filterValue = filter.value as FilterValue | undefined}\n\t\t\t\t\t{@const operator = filterValue?.operator ?? getDefaultOperator(variant)}\n\t\t\t\t\t{@const operators = getOperatorsForVariant(variant)}\n\t\t\t\t\t{@const needsValue = !['isEmpty', 'isNotEmpty', 'isTrue', 'isFalse'].includes(operator)}\n\t\t\t\t\t{@const selectOptions = getColumnOptions(filter.id)}\n\t\t\t\t\t<li class=\"flex items-center gap-2\">\n\t\t\t\t\t\t<div class=\"min-w-[72px] text-center\">\n\t\t\t\t\t\t\t{#if index === 0}\n\t\t\t\t\t\t\t\t<span class=\"text-muted-foreground text-sm\">Where</span>\n\t\t\t\t\t\t\t{:else}\n\t\t\t\t\t\t\t\t<span class=\"text-muted-foreground text-sm\">And</span>\n\t\t\t\t\t\t\t{/if}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<!-- Column selector -->\n\t\t\t\t\t\t<Popover>\n\t\t\t\t\t\t\t<PopoverTrigger>\n\t\t\t\t\t\t\t\t{#snippet child({ props })}\n\t\t\t\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\t\t\t\t{...props}\n\t\t\t\t\t\t\t\t\t\tvariant=\"outline\"\n\t\t\t\t\t\t\t\t\t\tsize=\"sm\"\n\t\t\t\t\t\t\t\t\t\tclass=\"w-32 justify-between rounded font-normal\"\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t<span class=\"truncate\">{columnLabels.get(filter.id)}</span>\n\t\t\t\t\t\t\t\t\t\t<ChevronsUpDown class=\"opacity-50\" />\n\t\t\t\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t\t\t{/snippet}\n\t\t\t\t\t\t\t</PopoverTrigger>\n\t\t\t\t\t\t\t<PopoverContent align=\"start\" class=\"w-40 p-0\">\n\t\t\t\t\t\t\t\t<Command>\n\t\t\t\t\t\t\t\t\t<CommandInput placeholder=\"Search fields...\" />\n\t\t\t\t\t\t\t\t\t<CommandList>\n\t\t\t\t\t\t\t\t\t\t<CommandEmpty>No fields found.</CommandEmpty>\n\t\t\t\t\t\t\t\t\t\t<CommandGroup>\n\t\t\t\t\t\t\t\t\t\t\t{#each columns as col (col.value)}\n\t\t\t\t\t\t\t\t\t\t\t\t<CommandItem\n\t\t\t\t\t\t\t\t\t\t\t\t\tvalue={col.value}\n\t\t\t\t\t\t\t\t\t\t\t\t\tonSelect={() => {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tconst newVariant = columnVariants.get(col.value) ?? 'short-text';\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tconst newOperator = getDefaultOperator(newVariant);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttable.setColumnFilters((prevFilters) =>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tprevFilters.map((f) =>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tf.id === filter.id\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tid: col.value,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\toperator: newOperator,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: ''\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t: f\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"truncate\">{col.label}</span>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<Check\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tclass={cn(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'ml-auto',\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcol.value === filter.id ? 'opacity-100' : 'opacity-0'\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t\t\t\t\t</CommandItem>\n\t\t\t\t\t\t\t\t\t\t\t{/each}\n\t\t\t\t\t\t\t\t\t\t</CommandGroup>\n\t\t\t\t\t\t\t\t\t</CommandList>\n\t\t\t\t\t\t\t\t</Command>\n\t\t\t\t\t\t\t</PopoverContent>\n\t\t\t\t\t\t</Popover>\n\t\t\t\t\t\t<!-- Operator selector -->\n\t\t\t\t\t\t<Select\n\t\t\t\t\t\t\ttype=\"single\"\n\t\t\t\t\t\t\tvalue={operator}\n\t\t\t\t\t\t\tonValueChange={(newOperator: string) => {\n\t\t\t\t\t\t\t\tconst currentValue = filterValue?.value;\n\t\t\t\t\t\t\t\tconst currentValue2 = filterValue?.value2;\n\n\t\t\t\t\t\t\t\tonFilterUpdate(filter.id, {\n\t\t\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\t\t\toperator: newOperator as FilterOperator,\n\t\t\t\t\t\t\t\t\t\tvalue: currentValue,\n\t\t\t\t\t\t\t\t\t\tvalue2: currentValue2\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<SelectTrigger size=\"sm\" class=\"w-32 rounded lowercase\">\n\t\t\t\t\t\t\t\t<span data-slot=\"select-value\" class=\"truncate\">\n\t\t\t\t\t\t\t\t\t{operators.find((op) => op.value === operator)?.label ?? operator}\n\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t</SelectTrigger>\n\t\t\t\t\t\t\t<SelectContent>\n\t\t\t\t\t\t\t\t{#each operators as op (op.value)}\n\t\t\t\t\t\t\t\t\t<SelectItem value={op.value} class=\"lowercase\">\n\t\t\t\t\t\t\t\t\t\t{op.label}\n\t\t\t\t\t\t\t\t\t</SelectItem>\n\t\t\t\t\t\t\t\t{/each}\n\t\t\t\t\t\t\t</SelectContent>\n\t\t\t\t\t\t</Select>\n\t\t\t\t\t\t<!-- Value input -->\n\t\t\t\t\t\t<div class=\"min-w-36 flex-1\">\n\t\t\t\t\t\t\t{#if needsValue}\n\t\t\t\t\t\t\t\t{#if variant === 'number'}\n\t\t\t\t\t\t\t\t\t<Input\n\t\t\t\t\t\t\t\t\t\ttype=\"number\"\n\t\t\t\t\t\t\t\t\t\tinputmode=\"numeric\"\n\t\t\t\t\t\t\t\t\t\tplaceholder=\"Value\"\n\t\t\t\t\t\t\t\t\t\tvalue={String(filterValue?.value ?? '')}\n\t\t\t\t\t\t\t\t\t\toninput={(event) => {\n\t\t\t\t\t\t\t\t\t\t\tconst val = (event.target as HTMLInputElement).value;\n\t\t\t\t\t\t\t\t\t\t\tconst newValue = val === '' ? undefined : Number(val);\n\t\t\t\t\t\t\t\t\t\t\tonFilterUpdate(filter.id, {\n\t\t\t\t\t\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\t\t\t\t\t\toperator,\n\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: newValue,\n\t\t\t\t\t\t\t\t\t\t\t\t\tvalue2: filterValue?.value2\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t\tclass=\"h-8 w-full rounded\"\n\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t{:else if variant === 'date'}\n\t\t\t\t\t\t\t\t\t{@const calendarValue = parseISOToCalendarDate(filterValue?.value as string | undefined)}\n\t\t\t\t\t\t\t\t\t<Popover>\n\t\t\t\t\t\t\t\t\t\t<PopoverTrigger>\n\t\t\t\t\t\t\t\t\t\t\t{#snippet child({ props })}\n\t\t\t\t\t\t\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\t\t\t\t\t\t\t{...props}\n\t\t\t\t\t\t\t\t\t\t\t\t\tvariant=\"outline\"\n\t\t\t\t\t\t\t\t\t\t\t\t\tsize=\"sm\"\n\t\t\t\t\t\t\t\t\t\t\t\t\tclass={cn(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t'h-8 w-full justify-start rounded font-normal',\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t!calendarValue && 'text-muted-foreground'\n\t\t\t\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<CalendarIcon />\n\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"truncate\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{calendarValue\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t? `${calendarValue.month}/${calendarValue.day}/${calendarValue.year}`\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t: 'Select date'}\n\t\t\t\t\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t\t\t\t\t\t{/snippet}\n\t\t\t\t\t\t\t\t\t\t</PopoverTrigger>\n\t\t\t\t\t\t\t\t\t\t<PopoverContent align=\"start\" class=\"w-auto p-0\">\n\t\t\t\t\t\t\t\t\t\t\t<Calendar\n\t\t\t\t\t\t\t\t\t\t\t\ttype=\"single\"\n\t\t\t\t\t\t\t\t\t\t\t\tvalue={calendarValue}\n\t\t\t\t\t\t\t\t\t\t\t\tonValueChange={(date: DateValue | undefined) => {\n\t\t\t\t\t\t\t\t\t\t\t\t\tconst newValue = calendarDateToISO(date);\n\t\t\t\t\t\t\t\t\t\t\t\t\tonFilterUpdate(filter.id, {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\toperator,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: newValue,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue2: filterValue?.value2\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t\t\t</PopoverContent>\n\t\t\t\t\t\t\t\t\t</Popover>\n\t\t\t\t\t\t\t\t{:else if (variant === 'select' || variant === 'multi-select') && selectOptions.length > 0}\n\t\t\t\t\t\t\t\t\t{#if operator === 'isAnyOf' || operator === 'isNoneOf'}\n\t\t\t\t\t\t\t\t\t\t{@const selectedValues = Array.isArray(filterValue?.value) ? filterValue.value : []}\n\t\t\t\t\t\t\t\t\t\t{@const selectedOptions = selectOptions.filter((option) =>\n\t\t\t\t\t\t\t\t\t\t\tselectedValues.includes(option.value)\n\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t\t<Popover>\n\t\t\t\t\t\t\t\t\t\t\t<PopoverTrigger>\n\t\t\t\t\t\t\t\t\t\t\t\t{#snippet child({ props })}\n\t\t\t\t\t\t\t\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{...props}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tvariant=\"outline\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsize=\"sm\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tclass=\"h-8 w-full justify-start rounded font-normal\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{#if selectedOptions.length === 0}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"text-muted-foreground\">Select values</span>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{:else}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"truncate\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{selectedOptions.length > 1\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t? `${selectedOptions.length} selected`\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t: selectedOptions[0]?.label}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{/if}\n\t\t\t\t\t\t\t\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t\t\t\t\t\t\t{/snippet}\n\t\t\t\t\t\t\t\t\t\t\t</PopoverTrigger>\n\t\t\t\t\t\t\t\t\t\t\t<PopoverContent align=\"start\" class=\"w-48 p-0\">\n\t\t\t\t\t\t\t\t\t\t\t\t<Command>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<CommandInput placeholder=\"Search options...\" />\n\t\t\t\t\t\t\t\t\t\t\t\t\t<CommandList>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<CommandEmpty>No options found.</CommandEmpty>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<CommandGroup>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{#each selectOptions as option (option.value)}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{@const isSelected = selectedValues.includes(option.value)}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<CommandItem\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue={option.value}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tonSelect={() => {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tconst newValues = isSelected\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t? selectedValues.filter((v) => v !== option.value)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t: [...selectedValues, option.value];\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tonFilterUpdate(filter.id, {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\toperator,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: newValues.length > 0 ? newValues : undefined,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue2: filterValue?.value2\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"truncate\">{option.label}</span>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{#if option.count !== undefined}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"ml-auto font-mono text-xs\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{option.count}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{/if}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<Check\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tclass={cn('ml-auto', isSelected ? 'opacity-100' : 'opacity-0')}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</CommandItem>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{/each}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t</CommandGroup>\n\t\t\t\t\t\t\t\t\t\t\t\t\t</CommandList>\n\t\t\t\t\t\t\t\t\t\t\t\t</Command>\n\t\t\t\t\t\t\t\t\t\t\t</PopoverContent>\n\t\t\t\t\t\t\t\t\t\t</Popover>\n\t\t\t\t\t\t\t\t\t{:else}\n\t\t\t\t\t\t\t\t\t\t{@const selectedOption = selectOptions.find((opt) => opt.value === (filterValue?.value as string))}\n\t\t\t\t\t\t\t\t\t\t<Popover>\n\t\t\t\t\t\t\t\t\t\t\t<PopoverTrigger>\n\t\t\t\t\t\t\t\t\t\t\t\t{#snippet child({ props })}\n\t\t\t\t\t\t\t\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{...props}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tvariant=\"outline\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tsize=\"sm\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tclass=\"h-8 w-full justify-start rounded font-normal\"\n\t\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{#if selectedOption}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"truncate\">{selectedOption.label}</span>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{:else}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"text-muted-foreground\">Select value</span>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t{/if}\n\t\t\t\t\t\t\t\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t\t\t\t\t\t\t{/snippet}\n\t\t\t\t\t\t\t\t\t\t\t</PopoverTrigger>\n\t\t\t\t\t\t\t\t\t\t\t<PopoverContent align=\"start\" class=\"w-[200px] p-0\">\n\t\t\t\t\t\t\t\t\t\t\t\t<Command>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<CommandInput placeholder=\"Search options...\" />\n\t\t\t\t\t\t\t\t\t\t\t\t\t<CommandList>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<CommandEmpty>No options found.</CommandEmpty>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t<CommandGroup>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{#each selectOptions as option (option.value)}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<CommandItem\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue={option.value}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tonSelect={() => {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tonFilterUpdate(filter.id, {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\toperator,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: option.value,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tvalue2: filterValue?.value2\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"truncate\">{option.label}</span>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{#if option.count !== undefined}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"ml-auto font-mono text-xs\">\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{option.count}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{/if}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<Check\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tclass={cn(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t'ml-auto',\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfilterValue?.value === option.value ? 'opacity-100' : 'opacity-0'\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</CommandItem>\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t{/each}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t</CommandGroup>\n\t\t\t\t\t\t\t\t\t\t\t\t\t</CommandList>\n\t\t\t\t\t\t\t\t\t\t\t\t</Command>\n\t\t\t\t\t\t\t\t\t\t\t</PopoverContent>\n\t\t\t\t\t\t\t\t\t\t</Popover>\n\t\t\t\t\t\t\t\t\t{/if}\n\t\t\t\t\t\t\t\t{:else}\n\t\t\t\t\t\t\t\t\t<Input\n\t\t\t\t\t\t\t\t\t\ttype=\"text\"\n\t\t\t\t\t\t\t\t\t\tplaceholder=\"Value\"\n\t\t\t\t\t\t\t\t\t\tclass=\"h-8 w-full rounded\"\n\t\t\t\t\t\t\t\t\t\tvalue={(filterValue?.value as string | undefined) ?? ''}\n\t\t\t\t\t\t\t\t\t\toninput={(event) => {\n\t\t\t\t\t\t\t\t\t\t\tconst val = (event.target as HTMLInputElement).value;\n\t\t\t\t\t\t\t\t\t\t\tconst newValue = val === '' ? undefined : val;\n\t\t\t\t\t\t\t\t\t\t\tonFilterUpdate(filter.id, {\n\t\t\t\t\t\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\t\t\t\t\t\toperator,\n\t\t\t\t\t\t\t\t\t\t\t\t\tvalue: newValue,\n\t\t\t\t\t\t\t\t\t\t\t\t\tvalue2: filterValue?.value2\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t{/if}\n\t\t\t\t\t\t\t{:else}\n\t\t\t\t\t\t\t\t<div class=\"h-8 w-full rounded border bg-transparent dark:bg-input/30\"></div>\n\t\t\t\t\t\t\t{/if}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\tvariant=\"outline\"\n\t\t\t\t\t\t\tsize=\"icon\"\n\t\t\t\t\t\t\tclass=\"size-8 rounded\"\n\t\t\t\t\t\t\tonclick={() => onFilterRemove(filter.id)}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<Trash2 />\n\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t<Button variant=\"outline\" size=\"icon\" class=\"size-8 shrink-0 cursor-grab rounded\">\n\t\t\t\t\t\t\t<GripVertical />\n\t\t\t\t\t\t</Button>\n\t\t\t\t\t</li>\n\t\t\t\t{/each}\n\t\t\t</ul>\n\t\t{/if}\n\t\t<div class=\"flex w-full items-center gap-2\">\n\t\t\t<Button size=\"sm\" class=\"rounded\" onclick={onFilterAdd} disabled={columns.length === 0}>\n\t\t\t\tAdd filter\n\t\t\t</Button>\n\t\t\t{#if columnFilters.length > 0}\n\t\t\t\t<Button variant=\"outline\" size=\"sm\" class=\"rounded\" onclick={onFiltersReset}>\n\t\t\t\t\tReset filters\n\t\t\t\t</Button>\n\t\t\t{/if}\n\t\t</div>\n\t</PopoverContent>\n</Popover>\n",
			"type": "registry:component",
			"target": "data-grid-filter-menu.svelte"
		},
		{
			"content": "<script lang=\"ts\">\n\timport type { Table, HeaderGroup } from '@tanstack/table-core';\n\timport { FlexRender } from '$lib/table';\n\timport { dataGridStore } from '$lib/stores';\n\n\tinterface Props<TData> {\n\t\ttable: Table<TData>;\n\t}\n\n\tlet { table }: Props<any> = $props();\n\n\tconst headerGroups = $derived(table.getHeaderGroups());\n\n\tfunction handleHeaderClick(columnId: string) {\n\t\t// Select entire column\n\t\tdataGridStore.selectColumn(columnId);\n\t}\n\n\tfunction getSortIndicator(column: any): string {\n\t\tconst sorted = column.getIsSorted();\n\t\tif (sorted === 'asc') return ' ';\n\t\tif (sorted === 'desc') return ' ';\n\t\treturn '';\n\t}\n</script>\n\n<div class=\"sticky top-0 z-10 bg-background border-b border-border\">\n\t{#each headerGroups as headerGroup (headerGroup.id)}\n\t\t<div class=\"flex\">\n\t\t\t{#each headerGroup.headers as header (header.id)}\n\t\t\t\t<div\n\t\t\t\t\trole=\"columnheader\"\n\t\t\t\t\tclass=\"flex items-center p-2 font-medium text-muted-foreground bg-muted/50 border-r border-b border-border cursor-pointer select-none hover:bg-muted\"\n\t\t\t\t\tstyle=\"width: {header.getSize()}px; min-width: {header.getSize()}px;\"\n\t\t\t\t\tonclick={() => {\n\t\t\t\t\t\tif (header.column.getCanSort()) {\n\t\t\t\t\t\t\theader.column.toggleSorting();\n\t\t\t\t\t\t}\n\t\t\t\t\t}}\n\t\t\t\t\tonkeydown={(e) => {\n\t\t\t\t\t\tif (e.key === 'Enter' && header.column.getCanSort()) {\n\t\t\t\t\t\t\theader.column.toggleSorting();\n\t\t\t\t\t\t}\n\t\t\t\t\t}}\n\t\t\t\t\ttabindex=\"0\"\n\t\t\t\t\taria-sort={header.column.getIsSorted() === 'asc'\n\t\t\t\t\t\t? 'ascending'\n\t\t\t\t\t\t: header.column.getIsSorted() === 'desc'\n\t\t\t\t\t\t\t? 'descending'\n\t\t\t\t\t\t\t: 'none'}\n\t\t\t\t>\n\t\t\t\t\t{#if !header.isPlaceholder}\n\t\t\t\t\t\t<div class=\"flex items-center gap-1 truncate\">\n\t\t\t\t\t\t\t<FlexRender\n\t\t\t\t\t\t\t\tcontent={header.column.columnDef.header}\n\t\t\t\t\t\t\t\tcontext={header.getContext()}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t{#if header.column.getCanSort()}\n\t\t\t\t\t\t\t\t<span class=\"text-xs\">{getSortIndicator(header.column)}</span>\n\t\t\t\t\t\t\t{/if}\n\t\t\t\t\t\t</div>\n\t\t\t\t\t{/if}\n\n\t\t\t\t\t<!-- Column resize handle -->\n\t\t\t\t\t{#if header.column.getCanResize()}\n\t\t\t\t\t\t<div\n\t\t\t\t\t\t\trole=\"separator\"\n\t\t\t\t\t\t\tclass=\"absolute right-0 top-0 h-full w-1 cursor-col-resize bg-transparent hover:bg-primary/50\"\n\t\t\t\t\t\t\tonmousedown={header.getResizeHandler()}\n\t\t\t\t\t\t\tontouchstart={header.getResizeHandler()}\n\t\t\t\t\t\t\tclass:bg-primary={header.column.getIsResizing()}\n\t\t\t\t\t\t></div>\n\t\t\t\t\t{/if}\n\t\t\t\t</div>\n\t\t\t{/each}\n\t\t</div>\n\t{/each}\n</div>\n",
			"type": "registry:component",
			"target": "data-grid-header.svelte"
		},
		{
			"content": "<script lang=\"ts\">\n\timport { browser } from '$app/environment';\n\timport { Button } from '$lib/components/ui/button/index.js';\n\timport {\n\t\tDialog,\n\t\tDialogContent,\n\t\tDialogClose,\n\t\tDialogHeader,\n\t\tDialogTitle,\n\t\tDialogDescription\n\t} from '$lib/components/ui/dialog/index.js';\n\timport { Input } from '$lib/components/ui/input/index.js';\n\timport { Separator } from '$lib/components/ui/separator/index.js';\n\timport { Kbd, KbdGroup } from '$lib/components/ui/kbd/index.js';\n\n\t// Icons\n\timport Search from '@lucide/svelte/icons/search';\n\timport X from '@lucide/svelte/icons/x';\n\n\tconst SHORTCUT_KEY = '/';\n\n\tinterface ShortcutGroup {\n\t\ttitle: string;\n\t\tshortcuts: Array<{\n\t\t\tkeys: string[];\n\t\t\tdescription: string;\n\t\t}>;\n\t}\n\n\tinterface Props {\n\t\tenableSearch?: boolean;\n\t}\n\n\tlet { enableSearch = false }: Props = $props();\n\n\tlet open = $state(false);\n\tlet input = $state('');\n\tlet inputRef: HTMLInputElement | null = $state(null);\n\n\tconst isMac = browser ? /Mac|iPhone|iPad|iPod/.test(navigator.userAgent) : false;\n\tconst modKey = isMac ? '' : 'Ctrl';\n\n\tfunction onOpenChange(isOpen: boolean) {\n\t\topen = isOpen;\n\t\tif (!isOpen) {\n\t\t\tinput = '';\n\t\t}\n\t}\n\n\tfunction onOpenAutoFocus(event: Event) {\n\t\tevent.preventDefault();\n\t\tinputRef?.focus();\n\t}\n\n\tfunction onInputChange(event: Event) {\n\t\tconst target = event.target as HTMLInputElement;\n\t\tinput = target.value;\n\t}\n\n\tconst shortcutGroups = $derived.by((): ShortcutGroup[] => [\n\t\t{\n\t\t\ttitle: 'Navigation',\n\t\t\tshortcuts: [\n\t\t\t\t{ keys: ['', '', '', ''], description: 'Navigate between cells' },\n\t\t\t\t{ keys: ['Tab'], description: 'Move to next cell' },\n\t\t\t\t{ keys: ['Shift', 'Tab'], description: 'Move to previous cell' },\n\t\t\t\t{ keys: ['Home'], description: 'Move to first column' },\n\t\t\t\t{ keys: ['End'], description: 'Move to last column' },\n\t\t\t\t{ keys: [modKey, 'Home'], description: 'Move to first cell' },\n\t\t\t\t{ keys: [modKey, 'End'], description: 'Move to last cell' },\n\t\t\t\t{ keys: ['PgUp'], description: 'Move up one page' },\n\t\t\t\t{ keys: ['PgDn'], description: 'Move down one page' }\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\ttitle: 'Selection',\n\t\t\tshortcuts: [\n\t\t\t\t{ keys: ['Shift', ''], description: 'Extend selection' },\n\t\t\t\t{ keys: [modKey, 'A'], description: 'Select all cells' },\n\t\t\t\t{ keys: [modKey, 'Click'], description: 'Toggle cell selection' },\n\t\t\t\t{ keys: ['Shift', 'Click'], description: 'Select range' },\n\t\t\t\t{ keys: ['Esc'], description: 'Clear selection' }\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\ttitle: 'Editing',\n\t\t\tshortcuts: [\n\t\t\t\t{ keys: ['Enter'], description: 'Start editing cell' },\n\t\t\t\t{ keys: ['Double Click'], description: 'Start editing cell' },\n\t\t\t\t{ keys: [modKey, 'C'], description: 'Copy selected cells' },\n\t\t\t\t{ keys: [modKey, 'X'], description: 'Cut selected cells' },\n\t\t\t\t{ keys: [modKey, 'V'], description: 'Paste cells' },\n\t\t\t\t{ keys: ['Delete'], description: 'Clear selected cells' },\n\t\t\t\t{ keys: ['Backspace'], description: 'Clear selected cells' }\n\t\t\t]\n\t\t},\n\t\t...(enableSearch\n\t\t\t? [\n\t\t\t\t\t{\n\t\t\t\t\t\ttitle: 'Search',\n\t\t\t\t\t\tshortcuts: [\n\t\t\t\t\t\t\t{ keys: [modKey, 'F'], description: 'Open search' },\n\t\t\t\t\t\t\t{ keys: ['Enter'], description: 'Next match' },\n\t\t\t\t\t\t\t{ keys: ['Shift', 'Enter'], description: 'Previous match' },\n\t\t\t\t\t\t\t{ keys: ['Esc'], description: 'Close search' }\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t: []),\n\t\t{\n\t\t\ttitle: 'Filtering',\n\t\t\tshortcuts: [\n\t\t\t\t{ keys: [modKey, 'Shift', 'F'], description: 'Toggle the filter menu' },\n\t\t\t\t{ keys: ['Backspace'], description: 'Remove filter (when focused)' },\n\t\t\t\t{ keys: ['Delete'], description: 'Remove filter (when focused)' }\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\ttitle: 'Sorting',\n\t\t\tshortcuts: [\n\t\t\t\t{ keys: [modKey, 'Shift', 'S'], description: 'Toggle the sort menu' },\n\t\t\t\t{ keys: ['Backspace'], description: 'Remove sort (when focused)' },\n\t\t\t\t{ keys: ['Delete'], description: 'Remove sort (when focused)' }\n\t\t\t]\n\t\t},\n\t\t{\n\t\t\ttitle: 'General',\n\t\t\tshortcuts: [{ keys: [modKey, '/'], description: 'Show keyboard shortcuts' }]\n\t\t}\n\t]);\n\n\tconst filteredGroups = $derived.by(() => {\n\t\tif (!input.trim()) return shortcutGroups;\n\n\t\tconst query = input.toLowerCase();\n\t\treturn shortcutGroups\n\t\t\t.map((group) => ({\n\t\t\t\t...group,\n\t\t\t\tshortcuts: group.shortcuts.filter(\n\t\t\t\t\t(shortcut) =>\n\t\t\t\t\t\tshortcut.description.toLowerCase().includes(query) ||\n\t\t\t\t\t\tshortcut.keys.some((key) => key.toLowerCase().includes(query))\n\t\t\t\t)\n\t\t\t}))\n\t\t\t.filter((group) => group.shortcuts.length > 0);\n\t});\n\n\tfunction handleKeyDown(event: KeyboardEvent) {\n\t\tif ((event.ctrlKey || event.metaKey) && event.key === SHORTCUT_KEY) {\n\t\t\tevent.preventDefault();\n\t\t\topen = true;\n\t\t}\n\t}\n\n</script>\n\n<svelte:window onkeydown={handleKeyDown} />\n\n<Dialog {open} {onOpenChange}>\n\t<DialogContent class=\"max-w-2xl px-0\" onOpenAutoFocus={onOpenAutoFocus} showCloseButton={false}>\n\t\t<DialogClose class=\"absolute top-6 right-6\">\n\t\t\t{#snippet child({ props })}\n\t\t\t\t<Button {...props} variant=\"ghost\" size=\"icon\" class=\"size-6\">\n\t\t\t\t\t<X />\n\t\t\t\t</Button>\n\t\t\t{/snippet}\n\t\t</DialogClose>\n\t\t<DialogHeader class=\"px-6\">\n\t\t\t<DialogTitle>Keyboard shortcuts</DialogTitle>\n\t\t\t<DialogDescription class=\"sr-only\">\n\t\t\t\tUse these keyboard shortcuts to navigate and interact with the data grid more efficiently.\n\t\t\t</DialogDescription>\n\t\t</DialogHeader>\n\t\t<div class=\"px-6\">\n\t\t\t<div class=\"relative\">\n\t\t\t\t<Search\n\t\t\t\t\tclass=\"-translate-y-1/2 absolute top-1/2 left-3 size-3.5 text-muted-foreground\"\n\t\t\t\t/>\n\t\t\t\t<Input\n\t\t\t\t\tbind:ref={inputRef}\n\t\t\t\t\tplaceholder=\"Search shortcuts...\"\n\t\t\t\t\tclass=\"h-8 pl-8\"\n\t\t\t\t\tvalue={input}\n\t\t\t\t\toninput={onInputChange}\n\t\t\t\t/>\n\t\t\t</div>\n\t\t</div>\n\t\t<Separator class=\"mx-auto data-[orientation=horizontal]:w-[calc(100%-(--spacing(12)))]\" />\n\t\t<div class=\"h-[40vh] overflow-y-auto px-6\">\n\t\t\t{#if filteredGroups.length === 0}\n\t\t\t\t<div class=\"flex h-full flex-col items-center justify-center gap-3 text-center\">\n\t\t\t\t\t<div\n\t\t\t\t\t\tclass=\"flex size-10 shrink-0 items-center justify-center rounded-lg bg-muted text-foreground\"\n\t\t\t\t\t>\n\t\t\t\t\t\t<Search class=\"pointer-events-none size-6\" />\n\t\t\t\t\t</div>\n\t\t\t\t\t<div class=\"flex flex-col gap-1\">\n\t\t\t\t\t\t<div class=\"font-medium text-lg tracking-tight\">No shortcuts found</div>\n\t\t\t\t\t\t<p class=\"text-muted-foreground text-sm\">Try searching for a different term.</p>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t{:else}\n\t\t\t\t<div class=\"flex flex-col gap-6\">\n\t\t\t\t\t{#each filteredGroups as shortcutGroup (shortcutGroup.title)}\n\t\t\t\t\t\t<div class=\"flex flex-col gap-2\">\n\t\t\t\t\t\t\t<h3 class=\"font-semibold text-foreground text-sm\">\n\t\t\t\t\t\t\t\t{shortcutGroup.title}\n\t\t\t\t\t\t\t</h3>\n\t\t\t\t\t\t\t<div class=\"divide-y divide-border rounded-md border\">\n\t\t\t\t\t\t\t\t{#each shortcutGroup.shortcuts as shortcut, index (index)}\n\t\t\t\t\t\t\t\t\t<div class=\"flex items-center gap-4 px-3 py-2\">\n\t\t\t\t\t\t\t\t\t\t<span class=\"flex-1 text-sm\">{shortcut.description}</span>\n\t\t\t\t\t\t\t\t\t\t<KbdGroup class=\"shrink-0\">\n\t\t\t\t\t\t\t\t\t\t\t{#each shortcut.keys as key, keyIndex (key)}\n\t\t\t\t\t\t\t\t\t\t\t\t{#if keyIndex > 0}\n\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"text-muted-foreground text-xs\">+</span>\n\t\t\t\t\t\t\t\t\t\t\t\t{/if}\n\t\t\t\t\t\t\t\t\t\t\t\t<Kbd>{key}</Kbd>\n\t\t\t\t\t\t\t\t\t\t\t{/each}\n\t\t\t\t\t\t\t\t\t\t</KbdGroup>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t{/each}\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t{/each}\n\t\t\t\t</div>\n\t\t\t{/if}\n\t\t</div>\n\t</DialogContent>\n</Dialog>\n",
			"type": "registry:component",
			"target": "data-grid-keyboard-shortcuts.svelte"
		},
		{
			"content": "<script lang=\"ts\" generics=\"TData\">\n\timport type { Table } from '@tanstack/table-core';\n\timport { cn } from '$UTILS$.js';\n\timport { Button } from '$lib/components/ui/button/index.js';\n\timport {\n\t\tDialog,\n\t\tDialogContent,\n\t\tDialogDescription,\n\t\tDialogFooter,\n\t\tDialogHeader,\n\t\tDialogTitle\n\t} from '$lib/components/ui/dialog/index.js';\n\n\tinterface Props {\n\t\ttable: Table<TData>;\n\t}\n\n\tlet { table }: Props = $props();\n\n\tconst meta = $derived(table.options.meta);\n\tconst pasteDialog = $derived(meta?.pasteDialog);\n\tconst onPasteDialogOpenChange = $derived(meta?.onPasteDialogOpenChange);\n\tconst onPasteWithExpansion = $derived(meta?.onPasteWithExpansion);\n\tconst onPasteWithoutExpansion = $derived(meta?.onPasteWithoutExpansion);\n\n\tlet expandRadioRef = $state<HTMLInputElement | null>(null);\n\n\tfunction onCancel() {\n\t\tonPasteDialogOpenChange?.(false);\n\t}\n\n\tfunction onContinue() {\n\t\tif (expandRadioRef?.checked) {\n\t\t\tonPasteWithExpansion?.();\n\t\t} else {\n\t\t\tonPasteWithoutExpansion?.();\n\t\t}\n\t}\n</script>\n\n{#if pasteDialog}\n\t<Dialog open={pasteDialog.open} onOpenChange={onPasteDialogOpenChange}>\n\t\t<DialogContent data-grid-popover=\"\">\n\t\t\t<DialogHeader>\n\t\t\t\t<DialogTitle>Do you want to add more rows?</DialogTitle>\n\t\t\t\t<DialogDescription>\n\t\t\t\t\tWe need <strong>{pasteDialog.rowsNeeded}</strong> additional row{pasteDialog.rowsNeeded !==\n\t\t\t\t\t1\n\t\t\t\t\t\t? 's'\n\t\t\t\t\t\t: ''} to paste everything from your clipboard.\n\t\t\t\t</DialogDescription>\n\t\t\t</DialogHeader>\n\t\t\t<div class=\"flex flex-col gap-3 py-1\">\n\t\t\t\t<label class=\"flex cursor-pointer items-start gap-3\">\n\t\t\t\t\t<input\n\t\t\t\t\t\tbind:this={expandRadioRef}\n\t\t\t\t\t\ttype=\"radio\"\n\t\t\t\t\t\tname=\"expand-option\"\n\t\t\t\t\t\tvalue=\"expand\"\n\t\t\t\t\t\tchecked\n\t\t\t\t\t\tclass={cn(\n\t\t\t\t\t\t\t'relative size-4 shrink-0 appearance-none rounded-full border border-input bg-background shadow-xs outline-none transition-[color,box-shadow]',\n\t\t\t\t\t\t\t'text-primary focus-visible:border-ring focus-visible:ring-[3px] focus-visible:ring-ring/50',\n\t\t\t\t\t\t\t'disabled:cursor-not-allowed disabled:opacity-50',\n\t\t\t\t\t\t\t\"checked:before:-translate-x-1/2 checked:before:-translate-y-1/2 checked:before:absolute checked:before:top-1/2 checked:before:left-1/2 checked:before:size-2 checked:before:rounded-full checked:before:bg-primary checked:before:content-['']\",\n\t\t\t\t\t\t\t'dark:bg-input/30'\n\t\t\t\t\t\t)}\n\t\t\t\t\t/>\n\t\t\t\t\t<div class=\"flex flex-col gap-1\">\n\t\t\t\t\t\t<span class=\"font-medium text-sm leading-none\"> Create new rows </span>\n\t\t\t\t\t\t<span class=\"text-muted-foreground text-sm\">\n\t\t\t\t\t\t\tAdd {pasteDialog.rowsNeeded} new row{pasteDialog.rowsNeeded !== 1 ? 's' : ''} to the\n\t\t\t\t\t\t\ttable and paste all data\n\t\t\t\t\t\t</span>\n\t\t\t\t\t</div>\n\t\t\t\t</label>\n\t\t\t\t<label class=\"flex cursor-pointer items-start gap-3\">\n\t\t\t\t\t<input\n\t\t\t\t\t\ttype=\"radio\"\n\t\t\t\t\t\tname=\"expand-option\"\n\t\t\t\t\t\tvalue=\"no-expand\"\n\t\t\t\t\t\tclass={cn(\n\t\t\t\t\t\t\t'relative size-4 shrink-0 appearance-none rounded-full border border-input bg-background shadow-xs outline-none transition-[color,box-shadow]',\n\t\t\t\t\t\t\t'text-primary focus-visible:border-ring focus-visible:ring-[3px] focus-visible:ring-ring/50',\n\t\t\t\t\t\t\t'disabled:cursor-not-allowed disabled:opacity-50',\n\t\t\t\t\t\t\t\"checked:before:-translate-x-1/2 checked:before:-translate-y-1/2 checked:before:absolute checked:before:top-1/2 checked:before:left-1/2 checked:before:size-2 checked:before:rounded-full checked:before:bg-primary checked:before:content-['']\",\n\t\t\t\t\t\t\t'dark:bg-input/30'\n\t\t\t\t\t\t)}\n\t\t\t\t\t/>\n\t\t\t\t\t<div class=\"flex flex-col gap-1\">\n\t\t\t\t\t\t<span class=\"font-medium text-sm leading-none\"> Keep current rows </span>\n\t\t\t\t\t\t<span class=\"text-muted-foreground text-sm\">\n\t\t\t\t\t\t\tPaste only what fits in the existing rows\n\t\t\t\t\t\t</span>\n\t\t\t\t\t</div>\n\t\t\t\t</label>\n\t\t\t</div>\n\t\t\t<DialogFooter>\n\t\t\t\t<Button variant=\"outline\" onclick={onCancel}>Cancel</Button>\n\t\t\t\t<Button onclick={onContinue}>Continue</Button>\n\t\t\t</DialogFooter>\n\t\t</DialogContent>\n\t</Dialog>\n{/if}\n",
			"type": "registry:component",
			"target": "data-grid-paste-dialog.svelte"
		},
		{
			"content": "<script lang=\"ts\">\n\timport { cn } from '$UTILS$.js';\n\timport { onMount } from 'svelte';\n\timport type { HTMLAttributes } from 'svelte/elements';\n\n\tinterface Props extends HTMLAttributes<HTMLDivElement> {\n\t\tlabel?: string;\n\t\tclass?: string;\n\t}\n\n\tlet { label = 'Grid', class: className, ...restProps }: Props = $props();\n\n\tlet renderCount = $state(0);\n\tlet mounted = $state(false);\n\n\t// Increment on each render\n\trenderCount += 1;\n\n\tonMount(() => {\n\t\tmounted = true;\n\t});\n</script>\n\n{#if mounted}\n\t<div\n\t\tclass={cn(\n\t\t\t'fixed right-4 bottom-4 z-50 rounded-md border bg-background/95 px-3 py-2 font-mono text-xs shadow-lg backdrop-blur supports-[backdrop-filter]:bg-background/60',\n\t\t\tclassName\n\t\t)}\n\t\t{...restProps}\n\t>\n\t\t<div class=\"flex flex-col gap-1\">\n\t\t\t<div class=\"flex items-center justify-between gap-4\">\n\t\t\t\t<span class=\"text-muted-foreground\">{label} Renders:</span>\n\t\t\t\t<span class=\"font-semibold tabular-nums\">\n\t\t\t\t\t{renderCount}\n\t\t\t\t</span>\n\t\t\t</div>\n\t\t</div>\n\t</div>\n{/if}\n",
			"type": "registry:component",
			"target": "data-grid-render-count.svelte"
		},
		{
			"content": "<script lang=\"ts\" generics=\"TData\">\n\timport type { Table } from '@tanstack/table-core';\n\timport type { RowHeightValue } from '$lib/types/data-grid.js';\n\timport {\n\t\tSelect,\n\t\tSelectContent,\n\t\tSelectItem,\n\t\tSelectTrigger\n\t} from '$lib/components/ui/select/index.js';\n\timport type { Component } from 'svelte';\n\n\t// Icons\n\timport Minus from '@lucide/svelte/icons/minus';\n\timport Equal from '@lucide/svelte/icons/equal';\n\timport AlignVerticalSpaceAround from '@lucide/svelte/icons/align-vertical-space-around';\n\timport ChevronsDownUp from '@lucide/svelte/icons/chevrons-down-up';\n\n\tinterface RowHeightOption {\n\t\tlabel: string;\n\t\tvalue: RowHeightValue;\n\t\ticon: Component<{ class?: string }>;\n\t}\n\n\tconst rowHeights: RowHeightOption[] = [\n\t\t{ label: 'Short', value: 'short', icon: Minus },\n\t\t{ label: 'Medium', value: 'medium', icon: Equal },\n\t\t{ label: 'Tall', value: 'tall', icon: AlignVerticalSpaceAround },\n\t\t{ label: 'Extra Tall', value: 'extra-tall', icon: ChevronsDownUp }\n\t];\n\n\tinterface Props {\n\t\ttable: Table<TData>;\n\t\talign?: 'start' | 'center' | 'end';\n\t\tclass?: string;\n\t}\n\n\tlet { table, align = 'start', class: className }: Props = $props();\n\n\tconst rowHeight = $derived(table.options.meta?.rowHeight ?? 'short');\n\tconst onRowHeightChange = $derived(table.options.meta?.onRowHeightChange);\n\n\tconst selectedRowHeight = $derived(\n\t\trowHeights.find((opt) => opt.value === rowHeight) ?? rowHeights[0]\n\t);\n\n\tfunction handleValueChange(value: string) {\n\t\tonRowHeightChange?.(value as RowHeightValue);\n\t}\n</script>\n\n<Select type=\"single\" value={rowHeight} onValueChange={handleValueChange}>\n\t<SelectTrigger size=\"sm\" class=\"[&_svg:nth-child(2)]:hidden {className}\">\n\t\t<span data-slot=\"select-value\" class=\"flex items-center gap-2\">\n\t\t\t{#if selectedRowHeight}\n\t\t\t\t{@const Icon = selectedRowHeight.icon}\n\t\t\t\t<Icon class=\"size-4\" />\n\t\t\t\t{selectedRowHeight.label}\n\t\t\t{:else}\n\t\t\t\tRow height\n\t\t\t{/if}\n\t\t</span>\n\t</SelectTrigger>\n\t<SelectContent {align}>\n\t\t{#each rowHeights as option (option.value)}\n\t\t\t{@const OptionIcon = option.icon}\n\t\t\t<SelectItem value={option.value}>\n\t\t\t\t<OptionIcon class=\"size-4\" />\n\t\t\t\t{option.label}\n\t\t\t</SelectItem>\n\t\t{/each}\n\t</SelectContent>\n</Select>\n",
			"type": "registry:component",
			"target": "data-grid-row-height-menu.svelte"
		},
		{
			"content": "<script lang=\"ts\" generics=\"TData\">\n\timport type { Row, Table, Column, ColumnPinningState, VisibilityState } from '@tanstack/table-core';\n\timport type { CellPosition, RowHeightValue } from '$lib/types/data-grid.js';\n\timport { getRowHeightValue } from '$lib/types/data-grid.js';\n\timport { cn } from '$UTILS$.js';\n\timport DataGridCell from './data-grid-cell.svelte';\n\n\t// Use 'any' for VirtualizerReturn to avoid type conflicts between different definitions\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\ttype VirtualizerReturn = any;\n\n\tinterface Props {\n\t\trow: Row<TData>;\n\t\ttable: Table<TData>;\n\t\tcolumnPinning: ColumnPinningState;\n\t\tcolumnVisibility: VisibilityState;\n\t\trowVirtualizer: VirtualizerReturn;\n\t\tvirtualRowIndex: number;\n\t\tvirtualStart: number;\n\t\trowMapRef: Map<number, HTMLDivElement>;\n\t\trowHeight: RowHeightValue;\n\t\tfocusedCell: CellPosition | null;\n\t\tclass?: string;\n\t}\n\n\tlet {\n\t\trow,\n\t\ttable,\n\t\tcolumnPinning,\n\t\tcolumnVisibility,\n\t\tvirtualRowIndex,\n\t\tvirtualStart,\n\t\trowVirtualizer,\n\t\trowMapRef,\n\t\trowHeight,\n\t\tfocusedCell,\n\t\tclass: className\n\t}: Props = $props();\n\n\tlet rowRef = $state<HTMLDivElement | null>(null);\n\n\t// Handle row ref changes - measure and track in rowMap\n\t$effect(() => {\n\t\tif (rowRef) {\n\t\t\trowVirtualizer.measureElement(rowRef);\n\t\t\trowMapRef.set(virtualRowIndex, rowRef);\n\t\t}\n\n\t\treturn () => {\n\t\t\trowMapRef.delete(virtualRowIndex);\n\t\t};\n\t});\n\n\tconst isRowSelected = $derived(row.getIsSelected());\n\n\t// Get visible cells in correct order (left pinned -> center -> right pinned)\n\t// We manually construct the order using table's column methods since Row.getVisibleCells()\n\t// doesn't automatically update when pinning changes\n\tconst visibleCells = $derived.by(() => {\n\t\t// Read columnPinning and columnVisibility to create dependencies\n\t\tconst _pinning = columnPinning;\n\t\tconst _visibility = columnVisibility;\n\t\t\n\t\t// Helper to check if column is visible\n\t\tconst isColumnVisible = (colId: string) => columnVisibility[colId] !== false;\n\t\t\n\t\t// Get columns in correct order: left pinned, center (unpinned), right pinned\n\t\t// Filter by visibility\n\t\tconst leftCols = table.getLeftLeafColumns().filter(c => isColumnVisible(c.id));\n\t\tconst centerCols = table.getCenterLeafColumns().filter(c => isColumnVisible(c.id));\n\t\tconst rightCols = table.getRightLeafColumns().filter(c => isColumnVisible(c.id));\n\t\t\n\t\t// Combine in order\n\t\tconst orderedColumnIds = [\n\t\t\t...leftCols.map(c => c.id),\n\t\t\t...centerCols.map(c => c.id),\n\t\t\t...rightCols.map(c => c.id)\n\t\t];\n\t\t\n\t\t// Get all cells and create a lookup map\n\t\tconst allCells = row.getAllCells();\n\t\tconst cellMap = new Map(allCells.map(cell => [cell.column.id, cell]));\n\t\t\n\t\t// Return cells in the correct order, filtering out any missing ones\n\t\treturn orderedColumnIds\n\t\t\t.map(id => cellMap.get(id))\n\t\t\t.filter((cell): cell is NonNullable<typeof cell> => cell != null);\n\t});\n\n\t// Precompute ALL pinning styles - re-runs when columnPinning prop changes\n\tconst pinningStylesMap = $derived.by(() => {\n\t\t// Read columnPinning prop to ensure this re-runs when it changes\n\t\tconst _ = columnPinning;\n\t\t\n\t\tconst stylesMap = new Map<string, Record<string, string | number | undefined>>();\n\t\t\n\t\tfor (const cell of row.getAllCells()) {\n\t\t\tconst column = cell.column;\n\t\t\ttry {\n\t\t\t\tconst isPinned = column.getIsPinned();\n\t\t\t\tconst isLastLeftPinnedColumn = isPinned === 'left' && column.getIsLastColumn('left');\n\t\t\t\tconst isFirstRightPinnedColumn = isPinned === 'right' && column.getIsFirstColumn('right');\n\n\t\t\t\tstylesMap.set(column.id, {\n\t\t\t\t\tboxShadow: isLastLeftPinnedColumn\n\t\t\t\t\t\t? '-4px 0 4px -4px var(--border) inset'\n\t\t\t\t\t\t: isFirstRightPinnedColumn\n\t\t\t\t\t\t\t? '4px 0 4px -4px var(--border) inset'\n\t\t\t\t\t\t\t: undefined,\n\t\t\t\t\tleft: isPinned === 'left' ? `${column.getStart('left')}px` : undefined,\n\t\t\t\t\tright: isPinned === 'right' ? `${column.getAfter('right')}px` : undefined,\n\t\t\t\t\topacity: isPinned ? 0.97 : 1,\n\t\t\t\t\tposition: isPinned ? 'sticky' : 'relative',\n\t\t\t\t\tbackground: 'var(--background)',\n\t\t\t\t\tzIndex: isPinned ? 1 : undefined\n\t\t\t\t});\n\t\t\t} catch {\n\t\t\t\tstylesMap.set(column.id, {\n\t\t\t\t\tposition: 'relative',\n\t\t\t\t\tbackground: 'var(--background)',\n\t\t\t\t\tzIndex: undefined\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn stylesMap;\n\t});\n\n\t// Helper to get pinning styles - just looks up from the reactive map\n\tfunction getPinningStyles(columnId: string): Record<string, string | number | undefined> {\n\t\treturn pinningStylesMap.get(columnId) ?? {\n\t\t\tposition: 'relative',\n\t\t\tbackground: 'var(--background)',\n\t\t\tzIndex: undefined\n\t\t};\n\t}\n</script>\n\n<div\n\trole=\"row\"\n\taria-rowindex={virtualRowIndex + 2}\n\taria-selected={isRowSelected}\n\tdata-index={virtualRowIndex}\n\tdata-slot=\"grid-row\"\n\tbind:this={rowRef}\n\ttabindex={-1}\n\tclass={cn('absolute flex w-full border-b', className)}\n\tstyle=\"top: {virtualStart}px; height: {getRowHeightValue(rowHeight)}px;\"\n>\n\t{#each visibleCells as cell, colIndex (cell.id)}\n\t\t{@const isCellFocused =\n\t\t\tfocusedCell?.rowIndex === virtualRowIndex && focusedCell?.columnId === cell.column.id}\n\t\t{@const pinningStyles = getPinningStyles(cell.column.id)}\n\n\t\t<div\n\t\t\trole=\"gridcell\"\n\t\t\taria-colindex={colIndex + 1}\n\t\t\tdata-highlighted={isCellFocused ? '' : undefined}\n\t\t\tdata-slot=\"grid-cell\"\n\t\t\ttabindex={-1}\n\t\t\tclass={cn({\n\t\t\t\t'border-r': cell.column.id !== 'select'\n\t\t\t})}\n\t\t\tstyle=\"position: {pinningStyles.position}; left: {pinningStyles.left}; right: {pinningStyles.right}; background: {pinningStyles.background}; z-index: {pinningStyles.zIndex}; width: calc(var(--col-{cell.column.id}-size) * 1px);\"\n\t\t>\n\t\t\t<!-- Use DataGridCell for variant-based rendering (handles all cell types via meta.cell.variant) -->\n\t\t\t<DataGridCell {cell} {table} />\n\t\t</div>\n\t{/each}\n</div>\n",
			"type": "registry:component",
			"target": "data-grid-row.svelte"
		},
		{
			"content": "<script lang=\"ts\">\n\timport type { CellPosition } from '$lib/types/data-grid.js';\n\timport { Button } from '$lib/components/ui/button/index.js';\n\timport ChevronDown from '@lucide/svelte/icons/chevron-down';\n\timport ChevronUp from '@lucide/svelte/icons/chevron-up';\n\timport X from '@lucide/svelte/icons/x';\n\n\t// Pass individual values as props - NOT an object with getters\n\t// This is the Svelte 5 way: primitive/array props are properly reactive\n\tinterface Props {\n\t\tsearchOpen: boolean;\n\t\tsearchQuery: string;\n\t\tsearchMatches: CellPosition[];\n\t\tmatchIndex: number;\n\t\tonSearchOpenChange: (open: boolean) => void;\n\t\tonSearchQueryChange: (query: string) => void;\n\t\tonSearch: (query: string) => void;\n\t\tonNavigateToNextMatch: () => void;\n\t\tonNavigateToPrevMatch: () => void;\n\t}\n\n\tlet {\n\t\tsearchOpen,\n\t\tsearchQuery,\n\t\tsearchMatches,\n\t\tmatchIndex,\n\t\tonSearchOpenChange,\n\t\tonSearchQueryChange,\n\t\tonSearch,\n\t\tonNavigateToNextMatch,\n\t\tonNavigateToPrevMatch\n\t}: Props = $props();\n\n\t// Debug - DO NOT REMOVE until user says so\n\t$inspect('SearchComponent', { searchOpen, searchQuery, matchCount: searchMatches.length, matchIndex });\n\n\tlet inputRef = $state<HTMLInputElement | null>(null);\n\n\t// Debounce timer\n\tlet debounceTimer: ReturnType<typeof setTimeout> | null = null;\n\n\t// Focus input when opening\n\t$effect(() => {\n\t\tif (searchOpen && inputRef) {\n\t\t\trequestAnimationFrame(() => {\n\t\t\t\tinputRef?.focus();\n\t\t\t});\n\t\t}\n\t});\n\n\t// Cleanup debounce timer on unmount\n\t$effect(() => {\n\t\treturn () => {\n\t\t\tif (debounceTimer) {\n\t\t\t\tclearTimeout(debounceTimer);\n\t\t\t}\n\t\t};\n\t});\n\n\tfunction handleWindowKeydown(event: KeyboardEvent) {\n\t\tif (!searchOpen) return;\n\n\t\tif (event.key === 'Escape') {\n\t\t\tevent.preventDefault();\n\t\t\tonSearchOpenChange(false);\n\t\t}\n\t}\n\n\tfunction handleInput(event: Event) {\n\t\tconst target = event.target as HTMLInputElement;\n\t\tconst value = target.value;\n\n\t\t// Update query immediately for UI responsiveness\n\t\tonSearchQueryChange(value);\n\n\t\t// Clear previous timer\n\t\tif (debounceTimer) {\n\t\t\tclearTimeout(debounceTimer);\n\t\t}\n\n\t\t// Debounce the actual search (150ms like React)\n\t\tdebounceTimer = setTimeout(() => {\n\t\t\tonSearch(value);\n\t\t}, 150);\n\t}\n\n\tfunction onKeyDown(event: KeyboardEvent) {\n\t\tevent.stopPropagation();\n\n\t\tif (event.key === 'Enter') {\n\t\t\tevent.preventDefault();\n\t\t\tif (event.shiftKey) {\n\t\t\t\tonNavigateToPrevMatch();\n\t\t\t} else {\n\t\t\t\tonNavigateToNextMatch();\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction onClose() {\n\t\tonSearchOpenChange(false);\n\t}\n</script>\n\n<svelte:window onkeydown={handleWindowKeydown} />\n\n{#if searchOpen}\n\t<div\n\t\trole=\"search\"\n\t\tdata-slot=\"grid-search\"\n\t\tclass=\"fade-in-0 slide-in-from-top-2 absolute top-4 right-4 z-50 flex animate-in flex-col gap-2 rounded-lg border bg-background p-2 shadow-lg\"\n\t>\n\t\t<div class=\"flex items-center gap-2\">\n\t\t\t<input\n\t\t\t\tbind:this={inputRef}\n\t\t\t\ttype=\"text\"\n\t\t\t\tautocomplete=\"off\"\n\t\t\t\tautocorrect=\"off\"\n\t\t\t\tautocapitalize=\"off\"\n\t\t\t\tspellcheck=\"false\"\n\t\t\t\tplaceholder=\"Find in table...\"\n\t\t\t\tclass=\"flex h-8 w-64 rounded-md border border-input bg-transparent px-3 py-1 text-base shadow-sm transition-colors placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring md:text-sm\"\n\t\t\t\tvalue={searchQuery}\n\t\t\t\toninput={handleInput}\n\t\t\t\tonkeydown={onKeyDown}\n\t\t\t/>\n\t\t\t<div class=\"flex items-center gap-1\">\n\t\t\t\t<Button\n\t\t\t\t\taria-label=\"Previous match\"\n\t\t\t\t\tvariant=\"ghost\"\n\t\t\t\t\tsize=\"icon\"\n\t\t\t\t\tclass=\"size-7\"\n\t\t\t\t\tonclick={onNavigateToPrevMatch}\n\t\t\t\t\tdisabled={searchMatches.length === 0}\n\t\t\t\t>\n\t\t\t\t\t<ChevronUp />\n\t\t\t\t</Button>\n\t\t\t\t<Button\n\t\t\t\t\taria-label=\"Next match\"\n\t\t\t\t\tvariant=\"ghost\"\n\t\t\t\t\tsize=\"icon\"\n\t\t\t\t\tclass=\"size-7\"\n\t\t\t\t\tonclick={onNavigateToNextMatch}\n\t\t\t\t\tdisabled={searchMatches.length === 0}\n\t\t\t\t>\n\t\t\t\t\t<ChevronDown />\n\t\t\t\t</Button>\n\t\t\t\t<Button aria-label=\"Close search\" variant=\"ghost\" size=\"icon\" class=\"size-7\" onclick={onClose}>\n\t\t\t\t\t<X />\n\t\t\t\t</Button>\n\t\t\t</div>\n\t\t</div>\n\t\t<div class=\"flex items-center gap-1 whitespace-nowrap text-muted-foreground text-xs\">\n\t\t\t{#if searchMatches.length > 0}\n\t\t\t\t<span>\n\t\t\t\t\t{matchIndex + 1} of {searchMatches.length}\n\t\t\t\t</span>\n\t\t\t{:else if searchQuery}\n\t\t\t\t<span>No results</span>\n\t\t\t{:else}\n\t\t\t\t<span>Type to search</span>\n\t\t\t{/if}\n\t\t</div>\n\t</div>\n{/if}\n",
			"type": "registry:component",
			"target": "data-grid-search.svelte"
		},
		{
			"content": "<script lang=\"ts\" generics=\"TData\">\n\timport type { Table, ColumnSort, SortDirection, SortingState } from '@tanstack/table-core';\n\timport { dndzone, TRIGGERS, SHADOW_ITEM_MARKER_PROPERTY_NAME } from 'svelte-dnd-action';\n\timport { cn } from '$UTILS$.js';\n\timport { Button } from '$lib/components/ui/button/index.js';\n\timport { Badge } from '$lib/components/ui/badge/index.js';\n\timport {\n\t\tPopover,\n\t\tPopoverContent,\n\t\tPopoverTrigger\n\t} from '$lib/components/ui/popover/index.js';\n\timport {\n\t\tCommand,\n\t\tCommandEmpty,\n\t\tCommandGroup,\n\t\tCommandInput,\n\t\tCommandItem,\n\t\tCommandList\n\t} from '$lib/components/ui/command/index.js';\n\timport {\n\t\tSelect,\n\t\tSelectContent,\n\t\tSelectItem,\n\t\tSelectTrigger\n\t} from '$lib/components/ui/select/index.js';\n\n\t// Icons\n\timport ArrowDownUp from '@lucide/svelte/icons/arrow-down-up';\n\timport ChevronsUpDown from '@lucide/svelte/icons/chevrons-up-down';\n\timport GripVertical from '@lucide/svelte/icons/grip-vertical';\n\timport Trash2 from '@lucide/svelte/icons/trash-2';\n\n\tconst SORT_SHORTCUT_KEY = 's';\n\tconst REMOVE_SORT_SHORTCUTS = ['backspace', 'delete'];\n\n\tconst SORT_ORDERS = [\n\t\t{ label: 'Asc', value: 'asc' },\n\t\t{ label: 'Desc', value: 'desc' }\n\t] as const;\n\n\tinterface Props {\n\t\ttable: Table<TData>;\n\t\talign?: 'start' | 'center' | 'end';\n\t\tclass?: string;\n\t}\n\n\tlet { table, align = 'start', class: className }: Props = $props();\n\n\tlet open = $state(false);\n\n\tconst sorting = $derived(table.getState().sorting);\n\n\t// Create a mutable copy for DnD\n\tlet sortingItems = $state<ColumnSort[]>([]);\n\n\t$effect(() => {\n\t\tsortingItems = [...sorting];\n\t});\n\n\tconst { columnLabels, columns } = $derived.by(() => {\n\t\tconst labels = new Map<string, string>();\n\t\tconst sortingIds = new Set(sorting.map((s) => s.id));\n\t\tconst availableColumns: { id: string; label: string }[] = [];\n\n\t\tfor (const column of table.getAllColumns()) {\n\t\t\tif (!column.getCanSort()) continue;\n\n\t\t\tconst label = column.columnDef.meta?.label ?? column.id;\n\t\t\tlabels.set(column.id, label);\n\n\t\t\tif (!sortingIds.has(column.id)) {\n\t\t\t\tavailableColumns.push({ id: column.id, label });\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tcolumnLabels: labels,\n\t\t\tcolumns: availableColumns\n\t\t};\n\t});\n\n\tfunction onSortAdd() {\n\t\tconst firstColumn = columns[0];\n\t\tif (!firstColumn) return;\n\n\t\ttable.setSorting((prevSorting: SortingState) => [\n\t\t\t...prevSorting,\n\t\t\t{ id: firstColumn.id, desc: false }\n\t\t]);\n\t}\n\n\tfunction onSortUpdate(sortId: string, updates: Partial<ColumnSort>) {\n\t\ttable.setSorting((prevSorting: SortingState) => {\n\t\t\tif (!prevSorting) return prevSorting;\n\t\t\treturn prevSorting.map((sort) =>\n\t\t\t\tsort.id === sortId ? { ...sort, ...updates } : sort\n\t\t\t);\n\t\t});\n\t}\n\n\tfunction onSortRemove(sortId: string) {\n\t\ttable.setSorting((prevSorting: SortingState) =>\n\t\t\tprevSorting.filter((item) => item.id !== sortId)\n\t\t);\n\t}\n\n\tfunction onSortingReset() {\n\t\ttable.setSorting(table.initialState.sorting);\n\t}\n\n\tfunction handleKeyDown(event: KeyboardEvent) {\n\t\tif (\n\t\t\tevent.target instanceof HTMLInputElement ||\n\t\t\tevent.target instanceof HTMLTextAreaElement ||\n\t\t\t(event.target instanceof HTMLElement && event.target.contentEditable === 'true')\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (\n\t\t\tevent.key.toLowerCase() === SORT_SHORTCUT_KEY &&\n\t\t\t(event.ctrlKey || event.metaKey) &&\n\t\t\tevent.shiftKey\n\t\t) {\n\t\t\tevent.preventDefault();\n\t\t\topen = !open;\n\t\t}\n\t}\n\n\tfunction onTriggerKeyDown(event: KeyboardEvent) {\n\t\tif (REMOVE_SORT_SHORTCUTS.includes(event.key.toLowerCase()) && sorting.length > 0) {\n\t\t\tevent.preventDefault();\n\t\t\tonSortingReset();\n\t\t}\n\t}\n\n\tfunction handleDndConsider(e: CustomEvent<{ items: ColumnSort[] }>) {\n\t\tsortingItems = e.detail.items;\n\t}\n\n\tfunction handleDndFinalize(e: CustomEvent<{ items: ColumnSort[] }>) {\n\t\tsortingItems = e.detail.items;\n\t\t// Filter out shadow items and update table sorting\n\t\tconst cleanItems = sortingItems.filter((item) => !(item as unknown as Record<string, unknown>)[SHADOW_ITEM_MARKER_PROPERTY_NAME]);\n\t\ttable.setSorting(cleanItems);\n\t}\n\n</script>\n\n<svelte:window onkeydown={handleKeyDown} />\n\n<Popover bind:open>\n\t<PopoverTrigger>\n\t\t{#snippet child({ props })}\n\t\t\t<Button\n\t\t\t\t{...props}\n\t\t\t\tvariant=\"outline\"\n\t\t\t\tsize=\"sm\"\n\t\t\t\tclass={cn('font-normal', className)}\n\t\t\t\tonkeydown={onTriggerKeyDown}\n\t\t\t>\n\t\t\t\t<ArrowDownUp class=\"text-muted-foreground\" />\n\t\t\t\tSort\n\t\t\t\t{#if sorting.length > 0}\n\t\t\t\t\t<Badge\n\t\t\t\t\t\tvariant=\"secondary\"\n\t\t\t\t\t\tclass=\"h-[18.24px] rounded-[3.2px] px-[5.12px] font-mono font-normal text-[10.4px]\"\n\t\t\t\t\t>\n\t\t\t\t\t\t{sorting.length}\n\t\t\t\t\t</Badge>\n\t\t\t\t{/if}\n\t\t\t</Button>\n\t\t{/snippet}\n\t</PopoverTrigger>\n\t<PopoverContent\n\t\t{align}\n\t\tclass=\"flex w-full max-w-[var(--radix-popover-content-available-width)] flex-col gap-3.5 p-4 sm:min-w-[380px]\"\n\t>\n\t\t<div class=\"flex flex-col gap-1\">\n\t\t\t<h4 class=\"font-medium leading-none\">\n\t\t\t\t{sorting.length > 0 ? 'Sort by' : 'No sorting applied'}\n\t\t\t</h4>\n\t\t\t<p class={cn('text-muted-foreground text-sm', sorting.length > 0 && 'sr-only')}>\n\t\t\t\t{sorting.length > 0\n\t\t\t\t\t? 'Modify sorting to organize your rows.'\n\t\t\t\t\t: 'Add sorting to organize your rows.'}\n\t\t\t</p>\n\t\t</div>\n\t\t{#if sortingItems.length > 0}\n\t\t\t<ul\n\t\t\t\tclass=\"flex max-h-[300px] flex-col gap-2 overflow-y-auto p-1\"\n\t\t\t\tuse:dndzone={{\n\t\t\t\t\titems: sortingItems,\n\t\t\t\t\tflipDurationMs: 150,\n\t\t\t\t\tdropTargetStyle: {},\n\t\t\t\t\ttype: 'sort-items'\n\t\t\t\t}}\n\t\t\t\tonconsider={handleDndConsider}\n\t\t\t\tonfinalize={handleDndFinalize}\n\t\t\t>\n\t\t\t\t{#each sortingItems as sort (sort.id)}\n\t\t\t\t\t<li class=\"flex items-center gap-2\">\n\t\t\t\t\t\t<Popover>\n\t\t\t\t\t\t\t<PopoverTrigger>\n\t\t\t\t\t\t\t\t{#snippet child({ props })}\n\t\t\t\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\t\t\t\t{...props}\n\t\t\t\t\t\t\t\t\t\tvariant=\"outline\"\n\t\t\t\t\t\t\t\t\t\tsize=\"sm\"\n\t\t\t\t\t\t\t\t\t\tclass=\"w-44 justify-between rounded font-normal\"\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t<span class=\"truncate\">{columnLabels.get(sort.id)}</span>\n\t\t\t\t\t\t\t\t\t\t<ChevronsUpDown class=\"opacity-50\" />\n\t\t\t\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t\t\t{/snippet}\n\t\t\t\t\t\t\t</PopoverTrigger>\n\t\t\t\t\t\t\t<PopoverContent class=\"w-[var(--radix-popover-trigger-width)] p-0\">\n\t\t\t\t\t\t\t\t<Command>\n\t\t\t\t\t\t\t\t\t<CommandInput placeholder=\"Search fields...\" />\n\t\t\t\t\t\t\t\t\t<CommandList>\n\t\t\t\t\t\t\t\t\t\t<CommandEmpty>No fields found.</CommandEmpty>\n\t\t\t\t\t\t\t\t\t\t<CommandGroup>\n\t\t\t\t\t\t\t\t\t\t\t{#each columns as column (column.id)}\n\t\t\t\t\t\t\t\t\t\t\t\t<CommandItem\n\t\t\t\t\t\t\t\t\t\t\t\t\tvalue={column.id}\n\t\t\t\t\t\t\t\t\t\t\t\t\tonSelect={() => onSortUpdate(sort.id, { id: column.id })}\n\t\t\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"truncate\">{column.label}</span>\n\t\t\t\t\t\t\t\t\t\t\t\t</CommandItem>\n\t\t\t\t\t\t\t\t\t\t\t{/each}\n\t\t\t\t\t\t\t\t\t\t</CommandGroup>\n\t\t\t\t\t\t\t\t\t</CommandList>\n\t\t\t\t\t\t\t\t</Command>\n\t\t\t\t\t\t\t</PopoverContent>\n\t\t\t\t\t\t</Popover>\n\t\t\t\t\t\t<Select\n\t\t\t\t\t\t\ttype=\"single\"\n\t\t\t\t\t\t\tvalue={sort.desc ? 'desc' : 'asc'}\n\t\t\t\t\t\t\tonValueChange={(value: string) => onSortUpdate(sort.id, { desc: value === 'desc' })}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<SelectTrigger class=\"h-8 w-24 rounded data-size:h-8\">\n\t\t\t\t\t\t\t\t<span data-slot=\"select-value\">\n\t\t\t\t\t\t\t\t\t{sort.desc ? 'Desc' : 'Asc'}\n\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t</SelectTrigger>\n\t\t\t\t\t\t\t<SelectContent class=\"min-w-[var(--radix-select-trigger-width)]\">\n\t\t\t\t\t\t\t\t{#each SORT_ORDERS as order (order.value)}\n\t\t\t\t\t\t\t\t\t<SelectItem value={order.value}>\n\t\t\t\t\t\t\t\t\t\t{order.label}\n\t\t\t\t\t\t\t\t\t</SelectItem>\n\t\t\t\t\t\t\t\t{/each}\n\t\t\t\t\t\t\t</SelectContent>\n\t\t\t\t\t\t</Select>\n\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\tvariant=\"outline\"\n\t\t\t\t\t\t\tsize=\"icon\"\n\t\t\t\t\t\t\tclass=\"size-8 shrink-0 rounded\"\n\t\t\t\t\t\t\tonclick={() => onSortRemove(sort.id)}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<Trash2 />\n\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t<Button variant=\"outline\" size=\"icon\" class=\"size-8 shrink-0 cursor-grab rounded\">\n\t\t\t\t\t\t\t<GripVertical />\n\t\t\t\t\t\t</Button>\n\t\t\t\t\t</li>\n\t\t\t\t{/each}\n\t\t\t</ul>\n\t\t{/if}\n\t\t<div class=\"flex w-full items-center gap-2\">\n\t\t\t<Button size=\"sm\" class=\"rounded\" onclick={onSortAdd} disabled={columns.length === 0}>\n\t\t\t\tAdd sort\n\t\t\t</Button>\n\t\t\t{#if sorting.length > 0}\n\t\t\t\t<Button variant=\"outline\" size=\"sm\" class=\"rounded\" onclick={onSortingReset}>\n\t\t\t\t\tReset sorting\n\t\t\t\t</Button>\n\t\t\t{/if}\n\t\t</div>\n\t</PopoverContent>\n</Popover>\n",
			"type": "registry:component",
			"target": "data-grid-sort-menu.svelte"
		},
		{
			"content": "<script lang=\"ts\" generics=\"TData\">\n\timport type { Table } from '@tanstack/table-core';\n\timport { cn } from '$UTILS$.js';\n\timport { Button } from '$lib/components/ui/button/index.js';\n\timport {\n\t\tPopover,\n\t\tPopoverContent,\n\t\tPopoverTrigger\n\t} from '$lib/components/ui/popover/index.js';\n\timport {\n\t\tCommand,\n\t\tCommandEmpty,\n\t\tCommandGroup,\n\t\tCommandInput,\n\t\tCommandItem,\n\t\tCommandList\n\t} from '$lib/components/ui/command/index.js';\n\n\t// Icons\n\timport Settings2 from '@lucide/svelte/icons/settings-2';\n\timport Check from '@lucide/svelte/icons/check';\n\n\tinterface Props {\n\t\ttable: Table<TData>;\n\t\talign?: 'start' | 'center' | 'end';\n\t\tclass?: string;\n\t}\n\n\tlet { table, align = 'start', class: className }: Props = $props();\n\n\t// Get columns - table.getAllColumns() is reactive via our wrapper\n\tconst columns = $derived(\n\t\ttable\n\t\t\t.getAllColumns()\n\t\t\t.filter((column) => typeof column.accessorFn !== 'undefined' && column.getCanHide())\n\t);\n\n\t// Get visibility state reactively\n\tconst columnVisibility = $derived(table.getState().columnVisibility);\n\n\t// Helper to check if column is visible - reads from reactive state\n\tfunction isColumnVisible(columnId: string): boolean {\n\t\t// If not in visibility state, default to visible (true)\n\t\treturn columnVisibility[columnId] !== false;\n\t}\n</script>\n\n<Popover>\n\t<PopoverTrigger>\n\t\t{#snippet child({ props })}\n\t\t\t<Button\n\t\t\t\t{...props}\n\t\t\t\taria-label=\"Toggle columns\"\n\t\t\t\trole=\"combobox\"\n\t\t\t\tvariant=\"outline\"\n\t\t\t\tsize=\"sm\"\n\t\t\t\tclass={cn('ml-auto hidden h-8 font-normal lg:flex', className)}\n\t\t\t>\n\t\t\t\t<Settings2 class=\"text-muted-foreground\" />\n\t\t\t\tView\n\t\t\t</Button>\n\t\t{/snippet}\n\t</PopoverTrigger>\n\t<PopoverContent {align} class=\"w-44 p-0\">\n\t\t<Command>\n\t\t\t<CommandInput placeholder=\"Search columns...\" />\n\t\t\t<CommandList>\n\t\t\t\t<CommandEmpty>No columns found.</CommandEmpty>\n\t\t\t\t<CommandGroup>\n\t\t\t\t\t{#each columns as column (column.id)}\n\t\t\t\t\t\t{@const isVisible = isColumnVisible(column.id)}\n\t\t\t\t\t\t<CommandItem\n\t\t\t\t\t\t\tvalue={column.id}\n\t\t\t\t\t\t\tonSelect={() => column.toggleVisibility(!isVisible)}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<span class=\"truncate\">\n\t\t\t\t\t\t\t\t{column.columnDef.meta?.label ?? column.id}\n\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t<Check\n\t\t\t\t\t\t\t\tclass={cn(\n\t\t\t\t\t\t\t\t\t'ml-auto size-4 shrink-0',\n\t\t\t\t\t\t\t\t\tisVisible ? 'opacity-100' : 'opacity-0'\n\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t</CommandItem>\n\t\t\t\t\t{/each}\n\t\t\t\t</CommandGroup>\n\t\t\t</CommandList>\n\t\t</Command>\n\t</PopoverContent>\n</Popover>\n",
			"type": "registry:component",
			"target": "data-grid-view-menu.svelte"
		},
		{
			"content": "// Data Grid components - TableCN Svelte 5 Port\nexport { default as DataGrid } from './data-grid.svelte';\nexport { default as DataGridCell } from './data-grid-cell.svelte';\nexport { default as DataGridRow } from './data-grid-row.svelte';\nexport { default as DataGridColumnHeader } from './data-grid-column-header.svelte';\nexport { default as DataGridCellWrapper } from './data-grid-cell-wrapper.svelte';\nexport { default as DataGridSearch } from './data-grid-search.svelte';\nexport { default as DataGridContextMenu } from './data-grid-context-menu.svelte';\nexport { default as DataGridPasteDialog } from './data-grid-paste-dialog.svelte';\n\n// Menu components\nexport { default as DataGridFilterMenu } from './data-grid-filter-menu.svelte';\nexport { default as DataGridSortMenu } from './data-grid-sort-menu.svelte';\nexport { default as DataGridViewMenu } from './data-grid-view-menu.svelte';\nexport { default as DataGridRowHeightMenu } from './data-grid-row-height-menu.svelte';\n\n// Utility components\nexport { default as DataGridKeyboardShortcuts } from './data-grid-keyboard-shortcuts.svelte';\nexport { default as DataGridRenderCount } from './data-grid-render-count.svelte';\n\n// Cell variants\nexport * from './cells';\n\n// Re-export the hook\nexport { useDataGrid } from '$lib/hooks/use-data-grid.svelte.js';\nexport type { UseDataGridOptions, UseDataGridReturn } from '$lib/hooks/use-data-grid.svelte.js';\n\n// Re-export types\nexport * from '$lib/types/data-grid.js';\n\n// Re-export filter utilities\nexport * from '$lib/data-grid-filters.js';\n",
			"type": "registry:component",
			"target": "index.ts"
		},
		{
			"content": "<script lang=\"ts\" generics=\"TData\">\n\timport type { Cell, Table } from '@tanstack/table-core';\n\timport DataGridCellWrapper from '../data-grid-cell-wrapper.svelte';\n\timport { Checkbox } from '$lib/components/ui/checkbox/index.js';\n\n\tinterface Props {\n\t\tcell: Cell<TData, unknown>;\n\t\ttable: Table<TData>;\n\t\trowIndex: number;\n\t\tcolumnId: string;\n\t\tisFocused: boolean;\n\t\tisSelected: boolean;\n\t\treadOnly?: boolean;\n\t}\n\n\tlet {\n\t\tcell,\n\t\ttable,\n\t\trowIndex,\n\t\tcolumnId,\n\t\tisFocused,\n\t\tisSelected,\n\t\treadOnly = false\n\t}: Props = $props();\n\n\tconst initialValue = $derived(cell.getValue() as boolean);\n\tlet value = $state(false);\n\n\t// Initialize and sync value from cell data\n\t$effect(() => {\n\t\tconst iv = Boolean(initialValue);\n\t\tvalue = iv;\n\t});\n\n\tfunction handleCheckedChange(newValue: boolean) {\n\t\tif (readOnly) return;\n\t\tvalue = newValue;\n\t\ttable.options.meta?.onDataUpdate?.({ rowIndex, columnId, value: newValue });\n\t}\n\n\tfunction handleWrapperKeyDown(event: KeyboardEvent) {\n\t\tif (isFocused && !readOnly && (event.key === ' ' || event.key === 'Enter')) {\n\t\t\tevent.preventDefault();\n\t\t\tevent.stopPropagation();\n\t\t\thandleCheckedChange(!value);\n\t\t} else if (isFocused && event.key === 'Tab') {\n\t\t\tevent.preventDefault();\n\t\t\ttable.options.meta?.onCellEditingStop?.({\n\t\t\t\tdirection: event.shiftKey ? 'left' : 'right'\n\t\t\t});\n\t\t}\n\t}\n\n\tfunction handleCheckboxClick(event: MouseEvent) {\n\t\tevent.stopPropagation();\n\t\tif (!readOnly) {\n\t\t\thandleCheckedChange(!value);\n\t\t}\n\t}\n\n\tfunction handleCheckboxMouseDown(event: MouseEvent) {\n\t\tevent.stopPropagation();\n\t}\n</script>\n\n<DataGridCellWrapper\n\t{cell}\n\t{table}\n\t{rowIndex}\n\t{columnId}\n\tisEditing={false}\n\t{isFocused}\n\t{isSelected}\n\tclass=\"flex size-full justify-center\"\n\tonkeydown={handleWrapperKeyDown}\n>\n\t<Checkbox\n\t\tchecked={value}\n\t\tdisabled={readOnly}\n\t\tclass=\"border-primary\"\n\t\tonclick={handleCheckboxClick}\n\t\tonmousedown={handleCheckboxMouseDown}\n\t/>\n</DataGridCellWrapper>\n",
			"type": "registry:component",
			"target": "checkbox-cell.svelte"
		},
		{
			"content": "<script lang=\"ts\" generics=\"TData\">\n\timport type { CellVariantProps } from '$lib/types/data-grid.js';\n\timport DataGridCellWrapper from '../data-grid-cell-wrapper.svelte';\n\timport { Popover as PopoverPrimitive } from 'bits-ui';\n\timport { PopoverContent } from '$lib/components/ui/popover/index.js';\n\timport { Calendar } from '$lib/components/ui/calendar/index.js';\n\timport { type DateValue, parseDate, today, getLocalTimeZone } from '@internationalized/date';\n\n\tlet {\n\t\tcell,\n\t\ttable,\n\t\trowIndex,\n\t\tcolumnId,\n\t\tisEditing,\n\t\tisFocused,\n\t\tisSelected,\n\t\treadOnly = false\n\t}: CellVariantProps<TData> = $props();\n\n\tconst initialValue = $derived(cell.getValue() as string);\n\tlet value = $state('');\n\tlet containerRef = $state<HTMLDivElement | null>(null);\n\n\t// Initialize and sync value\n\t$effect(() => {\n\t\tconst iv = initialValue ?? '';\n\t\tif (iv !== value && !isEditing) {\n\t\t\tvalue = iv;\n\t\t}\n\t});\n\n\t// Parse value to DateValue for calendar\n\tconst selectedDate = $derived.by((): DateValue | undefined => {\n\t\tif (!value) return undefined;\n\t\ttry {\n\t\t\treturn parseDate(value);\n\t\t} catch {\n\t\t\treturn undefined;\n\t\t}\n\t});\n\n\t// Default month for calendar (selected date or today)\n\tconst defaultMonth = $derived(selectedDate ?? today(getLocalTimeZone()));\n\n\tfunction formatDateForDisplay(dateStr: string): string {\n\t\tif (!dateStr) return '';\n\t\ttry {\n\t\t\tconst date = new Date(dateStr);\n\t\t\treturn date.toLocaleDateString();\n\t\t} catch {\n\t\t\treturn dateStr;\n\t\t}\n\t}\n\n\tfunction handleDateSelect(date: DateValue | undefined) {\n\t\tif (!date || readOnly) return;\n\n\t\tconst formattedDate = `${date.year}-${String(date.month).padStart(2, '0')}-${String(date.day).padStart(2, '0')}`;\n\t\tvalue = formattedDate;\n\t\tconst meta = table.options.meta;\n\t\tmeta?.onDataUpdate?.({ rowIndex, columnId, value: formattedDate });\n\t\tmeta?.onCellEditingStop?.();\n\t}\n\n\tfunction handleOpenChange(isOpen: boolean) {\n\t\tconst meta = table.options.meta;\n\t\tif (isOpen && !readOnly) {\n\t\t\tmeta?.onCellEditingStart?.(rowIndex, columnId);\n\t\t} else {\n\t\t\tmeta?.onCellEditingStop?.();\n\t\t}\n\t}\n\n\tfunction handleWrapperKeyDown(event: KeyboardEvent) {\n\t\tconst meta = table.options.meta;\n\t\tif (isEditing && event.key === 'Escape') {\n\t\t\tevent.preventDefault();\n\t\t\tvalue = initialValue;\n\t\t\tmeta?.onCellEditingStop?.();\n\t\t} else if (!isEditing && isFocused && event.key === 'Tab') {\n\t\t\tevent.preventDefault();\n\t\t\tmeta?.onCellEditingStop?.({\n\t\t\t\tdirection: event.shiftKey ? 'left' : 'right'\n\t\t\t});\n\t\t}\n\t}\n</script>\n\n<DataGridCellWrapper\n\tbind:wrapperRef={containerRef}\n\t{cell}\n\t{table}\n\t{rowIndex}\n\t{columnId}\n\t{isEditing}\n\t{isFocused}\n\t{isSelected}\n\tonkeydown={handleWrapperKeyDown}\n>\n\t<span data-slot=\"grid-cell-content\">{formatDateForDisplay(value)}</span>\n</DataGridCellWrapper>\n\n{#if isEditing}\n\t<PopoverPrimitive.Root open={isEditing} onOpenChange={handleOpenChange}>\n\t\t<PopoverContent\n\t\t\tdata-grid-cell-editor=\"\"\n\t\t\talign=\"start\"\n\t\t\talignOffset={-8}\n\t\t\tclass=\"w-auto p-0\"\n\t\t\tcustomAnchor={containerRef}\n\t\t>\n\t\t\t<Calendar\n\t\t\t\ttype=\"single\"\n\t\t\t\tvalue={selectedDate}\n\t\t\t\tonValueChange={handleDateSelect}\n\t\t\t\tcaptionLayout=\"dropdown\"\n\t\t\t\tweekdayFormat=\"short\"\n\t\t\t/>\n\t\t</PopoverContent>\n\t</PopoverPrimitive.Root>\n{/if}\n",
			"type": "registry:component",
			"target": "date-cell.svelte"
		},
		{
			"content": "<script lang=\"ts\" generics=\"TData\">\n\timport type { CellVariantProps, FileCellData } from '$lib/types/data-grid.js';\n\timport { getCellKey, getLineCount } from '$lib/types/data-grid.js';\n\timport DataGridCellWrapper from '../data-grid-cell-wrapper.svelte';\n\timport { PopoverContent } from '$lib/components/ui/popover/index.js';\n\timport { Popover as PopoverPrimitive } from 'bits-ui';\n\timport { Badge } from '$lib/components/ui/badge/index.js';\n\timport { Button } from '$lib/components/ui/button/index.js';\n\timport { Skeleton } from '$lib/components/ui/skeleton/index.js';\n\timport { cn } from '$UTILS$.js';\n\timport { toast } from 'svelte-sonner';\n\timport Upload from '@lucide/svelte/icons/upload';\n\timport X from '@lucide/svelte/icons/x';\n\timport FileIcon from '@lucide/svelte/icons/file';\n\timport FileImage from '@lucide/svelte/icons/file-image';\n\timport FileVideo from '@lucide/svelte/icons/file-video';\n\timport FileAudio from '@lucide/svelte/icons/file-audio';\n\timport FileText from '@lucide/svelte/icons/file-text';\n\timport FileArchive from '@lucide/svelte/icons/file-archive';\n\timport FileSpreadsheet from '@lucide/svelte/icons/file-spreadsheet';\n\timport Presentation from '@lucide/svelte/icons/presentation';\n\timport type { Component } from 'svelte';\n\n\tlet {\n\t\tcell,\n\t\ttable,\n\t\trowIndex,\n\t\tcolumnId,\n\t\tisEditing,\n\t\tisFocused,\n\t\tisSelected,\n\t\treadOnly = false\n\t}: CellVariantProps<TData> = $props();\n\n\tconst cellValue = $derived((cell.getValue() as FileCellData[]) ?? []);\n\tconst cellKey = $derived(getCellKey(rowIndex, columnId));\n\tlet prevCellKey = $state('');\n\n\tlet files = $state<FileCellData[]>([]);\n\tlet uploadingFiles = $state<Set<string>>(new Set());\n\tlet isDraggingOver = $state(false);\n\tlet isDragging = $state(false);\n\tlet error = $state<string | null>(null);\n\tlet containerRef = $state<HTMLDivElement | null>(null);\n\tlet fileInputRef = $state<HTMLInputElement | null>(null);\n\tlet dropzoneRef = $state<HTMLDivElement | null>(null);\n\tconst cellOpts = $derived(cell.column.columnDef.meta?.cell);\n\tconst sideOffset = $derived(-(containerRef?.clientHeight ?? 0));\n\n\tconst fileCellOpts = $derived(cellOpts?.variant === 'file' ? cellOpts : null);\n\tconst maxFileSize = $derived(fileCellOpts?.maxFileSize ?? 10 * 1024 * 1024);\n\tconst maxFiles = $derived(fileCellOpts?.maxFiles ?? 10);\n\tconst accept = $derived(fileCellOpts?.accept);\n\tconst multiple = $derived(fileCellOpts?.multiple ?? true);\n\n\tconst acceptedTypes = $derived(accept ? accept.split(',').map((t) => t.trim()) : null);\n\n\t// Sync with cell value - compare by content, not reference\n\t$effect(() => {\n\t\tconst cv = cellValue;\n\t\tif (!isEditing) {\n\t\t\t// Only update if arrays differ by content (compare by id)\n\t\t\tconst cvIds = cv.map((f) => f.id).join(',');\n\t\t\tconst filesIds = files.map((f) => f.id).join(',');\n\t\t\tif (cvIds !== filesIds) {\n\t\t\t\tfiles = [...cv];\n\t\t\t\terror = null;\n\t\t\t}\n\t\t}\n\t});\n\n\t// Reset error when cell changes\n\t$effect(() => {\n\t\tif (prevCellKey !== cellKey) {\n\t\t\tprevCellKey = cellKey;\n\t\t\terror = null;\n\t\t}\n\t});\n\n\tfunction formatFileSize(bytes: number): string {\n\t\tif (bytes === 0) return '0 B';\n\t\tconst k = 1024;\n\t\tconst sizes = ['B', 'KB', 'MB', 'GB'];\n\t\tconst i = Math.floor(Math.log(bytes) / Math.log(k));\n\t\treturn `${Number.parseFloat((bytes / k ** i).toFixed(1))} ${sizes[i]}`;\n\t}\n\n\tfunction getFileIcon(type: string): Component {\n\t\tif (type.startsWith('image/')) return FileImage;\n\t\tif (type.startsWith('video/')) return FileVideo;\n\t\tif (type.startsWith('audio/')) return FileAudio;\n\t\tif (type.includes('pdf')) return FileText;\n\t\tif (type.includes('zip') || type.includes('rar')) return FileArchive;\n\t\tif (type.includes('word') || type.includes('document') || type.includes('doc')) return FileText;\n\t\tif (type.includes('sheet') || type.includes('excel') || type.includes('xls'))\n\t\t\treturn FileSpreadsheet;\n\t\tif (type.includes('presentation') || type.includes('powerpoint') || type.includes('ppt'))\n\t\t\treturn Presentation;\n\t\treturn FileIcon;\n\t}\n\n\tfunction validateFile(file: File): string | null {\n\t\tif (maxFileSize && file.size > maxFileSize) {\n\t\t\treturn `File size exceeds ${formatFileSize(maxFileSize)}`;\n\t\t}\n\t\tif (acceptedTypes) {\n\t\t\tconst fileExtension = `.${file.name.split('.').pop()}`;\n\t\t\tconst isAccepted = acceptedTypes.some((type) => {\n\t\t\t\tif (type.endsWith('/*')) {\n\t\t\t\t\tconst baseType = type.slice(0, -2);\n\t\t\t\t\treturn file.type.startsWith(`${baseType}/`);\n\t\t\t\t}\n\t\t\t\tif (type.startsWith('.')) {\n\t\t\t\t\treturn fileExtension.toLowerCase() === type.toLowerCase();\n\t\t\t\t}\n\t\t\t\treturn file.type === type;\n\t\t\t});\n\t\t\tif (!isAccepted) {\n\t\t\t\treturn 'File type not accepted';\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tasync function addFiles(newFiles: File[], skipUpload = false) {\n\t\tif (readOnly) return;\n\t\terror = null;\n\n\t\tif (maxFiles && files.length + newFiles.length > maxFiles) {\n\t\t\tconst errorMessage = `Maximum ${maxFiles} files allowed`;\n\t\t\terror = errorMessage;\n\t\t\ttoast.error(errorMessage);\n\t\t\tsetTimeout(() => {\n\t\t\t\terror = null;\n\t\t\t}, 2000);\n\t\t\treturn;\n\t\t}\n\n\t\tconst rejectedFiles: Array<{ name: string; reason: string }> = [];\n\t\tconst filesToValidate: File[] = [];\n\n\t\tfor (const file of newFiles) {\n\t\t\tconst validationError = validateFile(file);\n\t\t\tif (validationError) {\n\t\t\t\trejectedFiles.push({ name: file.name, reason: validationError });\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfilesToValidate.push(file);\n\t\t}\n\n\t\tif (rejectedFiles.length > 0) {\n\t\t\tconst firstError = rejectedFiles[0];\n\t\t\tif (firstError) {\n\t\t\t\terror = firstError.reason;\n\n\t\t\t\tconst truncatedName =\n\t\t\t\t\tfirstError.name.length > 20 ? `${firstError.name.slice(0, 20)}...` : firstError.name;\n\n\t\t\t\tif (rejectedFiles.length === 1) {\n\t\t\t\t\ttoast.error(firstError.reason, {\n\t\t\t\t\t\tdescription: `\"${truncatedName}\" has been rejected`\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\ttoast.error(firstError.reason, {\n\t\t\t\t\t\tdescription: `\"${truncatedName}\" and ${rejectedFiles.length - 1} more rejected`\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\terror = null;\n\t\t\t\t}, 2000);\n\t\t\t}\n\t\t}\n\n\t\tif (filesToValidate.length > 0) {\n\t\t\tif (!skipUpload) {\n\t\t\t\tconst tempFiles = filesToValidate.map((f) => ({\n\t\t\t\t\tid: crypto.randomUUID(),\n\t\t\t\t\tname: f.name,\n\t\t\t\t\tsize: f.size,\n\t\t\t\t\ttype: f.type,\n\t\t\t\t\turl: undefined\n\t\t\t\t}));\n\t\t\t\tconst filesWithTemp = [...files, ...tempFiles];\n\t\t\t\tfiles = filesWithTemp;\n\n\t\t\t\tconst uploadingIds = new Set<string>(tempFiles.map((f) => f.id));\n\t\t\t\tuploadingFiles = uploadingIds;\n\n\t\t\t\tlet uploadedFiles: FileCellData[] = [];\n\t\t\t\tconst rowData = table.options.data[rowIndex];\n\n\t\t\t\tif (table.options.meta?.onFilesUpload && rowData) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tuploadedFiles = await table.options.meta.onFilesUpload({\n\t\t\t\t\t\t\tfiles: filesToValidate,\n\t\t\t\t\t\t\trowIndex,\n\t\t\t\t\t\t\tcolumnId,\n\t\t\t\t\t\t\trow: rowData\n\t\t\t\t\t\t});\n\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\ttoast.error(\n\t\t\t\t\t\t\terr instanceof Error\n\t\t\t\t\t\t\t\t? err.message\n\t\t\t\t\t\t\t\t: `Failed to upload ${filesToValidate.length} file${filesToValidate.length !== 1 ? 's' : ''}`\n\t\t\t\t\t\t);\n\t\t\t\t\t\tfiles = files.filter((f) => !uploadingIds.has(f.id));\n\t\t\t\t\t\tuploadingFiles = new Set();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tawait new Promise((resolve) => setTimeout(resolve, 800));\n\t\t\t\t\tuploadedFiles = filesToValidate.map((f, i) => ({\n\t\t\t\t\t\tid: tempFiles[i]?.id ?? crypto.randomUUID(),\n\t\t\t\t\t\tname: f.name,\n\t\t\t\t\t\tsize: f.size,\n\t\t\t\t\t\ttype: f.type,\n\t\t\t\t\t\turl: URL.createObjectURL(f)\n\t\t\t\t\t}));\n\t\t\t\t}\n\n\t\t\t\tconst finalFiles = filesWithTemp\n\t\t\t\t\t.map((f) => {\n\t\t\t\t\t\tif (uploadingIds.has(f.id)) {\n\t\t\t\t\t\t\treturn uploadedFiles.find((uf) => uf.name === f.name) ?? f;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn f;\n\t\t\t\t\t})\n\t\t\t\t\t.filter((f) => f.url !== undefined);\n\n\t\t\t\tfiles = finalFiles;\n\t\t\t\tuploadingFiles = new Set();\n\t\t\t\ttable.options.meta?.onDataUpdate?.({ rowIndex, columnId, value: finalFiles });\n\t\t\t} else {\n\t\t\t\tconst newFilesData: FileCellData[] = filesToValidate.map((f) => ({\n\t\t\t\t\tid: crypto.randomUUID(),\n\t\t\t\t\tname: f.name,\n\t\t\t\t\tsize: f.size,\n\t\t\t\t\ttype: f.type,\n\t\t\t\t\turl: URL.createObjectURL(f)\n\t\t\t\t}));\n\t\t\t\tconst updatedFiles = [...files, ...newFilesData];\n\t\t\t\tfiles = updatedFiles;\n\t\t\t\ttable.options.meta?.onDataUpdate?.({ rowIndex, columnId, value: updatedFiles });\n\t\t\t}\n\t\t}\n\t}\n\n\tasync function removeFile(fileId: string) {\n\t\tif (readOnly) return;\n\t\terror = null;\n\n\t\tconst fileToRemove = files.find((f) => f.id === fileId);\n\t\tif (!fileToRemove) return;\n\n\t\tconst rowData = table.options.data[rowIndex];\n\t\tif (table.options.meta?.onFilesDelete && rowData) {\n\t\t\ttry {\n\t\t\t\tawait table.options.meta.onFilesDelete({\n\t\t\t\t\tfileIds: [fileId],\n\t\t\t\t\trowIndex,\n\t\t\t\t\tcolumnId,\n\t\t\t\t\trow: rowData\n\t\t\t\t});\n\t\t\t} catch (err) {\n\t\t\t\ttoast.error(err instanceof Error ? err.message : `Failed to delete ${fileToRemove.name}`);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (fileToRemove.url?.startsWith('blob:')) {\n\t\t\tURL.revokeObjectURL(fileToRemove.url);\n\t\t}\n\n\t\tconst updatedFiles = files.filter((f) => f.id !== fileId);\n\t\tfiles = updatedFiles;\n\t\ttable.options.meta?.onDataUpdate?.({ rowIndex, columnId, value: updatedFiles });\n\t}\n\n\tasync function clearAll() {\n\t\tif (readOnly) return;\n\t\terror = null;\n\n\t\tconst rowData = table.options.data[rowIndex];\n\t\tif (table.options.meta?.onFilesDelete && rowData && files.length > 0) {\n\t\t\ttry {\n\t\t\t\tawait table.options.meta.onFilesDelete({\n\t\t\t\t\tfileIds: files.map((f) => f.id),\n\t\t\t\t\trowIndex,\n\t\t\t\t\tcolumnId,\n\t\t\t\t\trow: rowData\n\t\t\t\t});\n\t\t\t} catch (err) {\n\t\t\t\ttoast.error(err instanceof Error ? err.message : 'Failed to delete files');\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tfor (const file of files) {\n\t\t\tif (file.url?.startsWith('blob:')) {\n\t\t\t\tURL.revokeObjectURL(file.url);\n\t\t\t}\n\t\t}\n\t\tfiles = [];\n\t\ttable.options.meta?.onDataUpdate?.({ rowIndex, columnId, value: [] });\n\t}\n\n\tfunction handleCellDragEnter(event: DragEvent) {\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\t\tif (event.dataTransfer?.types.includes('Files')) {\n\t\t\tisDraggingOver = true;\n\t\t}\n\t}\n\n\tfunction handleCellDragLeave(event: DragEvent) {\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\t\tconst rect = (event.currentTarget as HTMLElement).getBoundingClientRect();\n\t\tconst x = event.clientX;\n\t\tconst y = event.clientY;\n\n\t\tif (x <= rect.left || x >= rect.right || y <= rect.top || y >= rect.bottom) {\n\t\t\tisDraggingOver = false;\n\t\t}\n\t}\n\n\tfunction handleCellDragOver(event: DragEvent) {\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\t}\n\n\tfunction handleCellDrop(event: DragEvent) {\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\t\tisDraggingOver = false;\n\n\t\tconst droppedFiles = Array.from(event.dataTransfer?.files ?? []);\n\t\tif (droppedFiles.length > 0) {\n\t\t\taddFiles(droppedFiles, false);\n\t\t}\n\t}\n\n\tfunction handleDropzoneDragEnter(event: DragEvent) {\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\t\tisDragging = true;\n\t}\n\n\tfunction handleDropzoneDragLeave(event: DragEvent) {\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\t\tconst rect = (event.currentTarget as HTMLElement).getBoundingClientRect();\n\t\tconst x = event.clientX;\n\t\tconst y = event.clientY;\n\n\t\tif (x <= rect.left || x >= rect.right || y <= rect.top || y >= rect.bottom) {\n\t\t\tisDragging = false;\n\t\t}\n\t}\n\n\tfunction handleDropzoneDragOver(event: DragEvent) {\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\t}\n\n\tfunction handleDropzoneDrop(event: DragEvent) {\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\t\tisDragging = false;\n\n\t\tconst droppedFiles = Array.from(event.dataTransfer?.files ?? []);\n\t\taddFiles(droppedFiles, false);\n\t}\n\n\tfunction handleDropzoneClick() {\n\t\tfileInputRef?.click();\n\t}\n\n\tfunction handleDropzoneKeyDown(event: KeyboardEvent) {\n\t\tif (event.key === 'Enter' || event.key === ' ') {\n\t\t\tevent.preventDefault();\n\t\t\thandleDropzoneClick();\n\t\t}\n\t}\n\n\tfunction handleFileInputChange(event: Event) {\n\t\tconst target = event.target as HTMLInputElement;\n\t\tconst selectedFiles = Array.from(target.files ?? []);\n\t\taddFiles(selectedFiles, false);\n\t\ttarget.value = '';\n\t}\n\n\tfunction handleOpenChange(isOpen: boolean) {\n\t\tif (isOpen && !readOnly) {\n\t\t\terror = null;\n\t\t\ttable.options.meta?.onCellEditingStart?.(rowIndex, columnId);\n\t\t} else {\n\t\t\terror = null;\n\t\t\ttable.options.meta?.onCellEditingStop?.();\n\t\t}\n\t}\n\n\tfunction handleEscapeKeyDown(event: KeyboardEvent) {\n\t\tevent.stopPropagation();\n\t}\n\n\tfunction handleOpenAutoFocus(event: Event) {\n\t\tevent.preventDefault();\n\t\tqueueMicrotask(() => {\n\t\t\tdropzoneRef?.focus();\n\t\t});\n\t}\n\n\tfunction handleWrapperKeyDown(event: KeyboardEvent) {\n\t\tif (isEditing) {\n\t\t\tif (event.key === 'Escape') {\n\t\t\t\tevent.preventDefault();\n\t\t\t\tfiles = [...cellValue];\n\t\t\t\terror = null;\n\t\t\t\ttable.options.meta?.onCellEditingStop?.();\n\t\t\t} else if (event.key === ' ') {\n\t\t\t\tevent.preventDefault();\n\t\t\t\thandleDropzoneClick();\n\t\t\t}\n\t\t} else if (isFocused && event.key === 'Enter') {\n\t\t\tevent.preventDefault();\n\t\t\ttable.options.meta?.onCellEditingStart?.(rowIndex, columnId);\n\t\t} else if (!isEditing && isFocused && event.key === 'Tab') {\n\t\t\tevent.preventDefault();\n\t\t\ttable.options.meta?.onCellEditingStop?.({\n\t\t\t\tdirection: event.shiftKey ? 'left' : 'right'\n\t\t\t});\n\t\t}\n\t}\n\n\tconst rowHeight = $derived(table.options.meta?.rowHeight ?? 'short');\n\tconst lineCount = $derived(getLineCount(rowHeight));\n\n\t// Simple visible file calculation\n\tconst maxVisibleFiles = $derived(lineCount * 2);\n\tconst visibleFiles = $derived(files.slice(0, maxVisibleFiles));\n\tconst hiddenFileCount = $derived(Math.max(0, files.length - maxVisibleFiles));\n</script>\n\n<DataGridCellWrapper\n\tbind:wrapperRef={containerRef}\n\t{cell}\n\t{table}\n\t{rowIndex}\n\t{columnId}\n\t{isEditing}\n\t{isFocused}\n\t{isSelected}\n\tclass={cn({\n\t\t'ring-1 ring-primary/80 ring-inset': isDraggingOver\n\t})}\n\tondragenter={handleCellDragEnter}\n\tondragleave={handleCellDragLeave}\n\tondragover={handleCellDragOver}\n\tondrop={handleCellDrop}\n\tonkeydown={handleWrapperKeyDown}\n>\n\t{#if isEditing}\n\t\t<PopoverPrimitive.Root open={isEditing} onOpenChange={handleOpenChange}>\n\t\t\t<PopoverContent\n\t\t\t\tdata-grid-cell-editor=\"\"\n\t\t\t\talign=\"start\"\n\t\t\t\tsideOffset={sideOffset}\n\t\t\t\tclass=\"w-[400px] rounded-none p-0\"\n\t\t\t\tonkeydown={handleEscapeKeyDown}\n\t\t\t\tonOpenAutoFocus={handleOpenAutoFocus}\n\t\t\t\tcustomAnchor={containerRef}\n\t\t\t>\n\t\t\t\t<div class=\"flex flex-col gap-2 p-3\">\n\t\t\t\t\t<span class=\"sr-only\">File upload</span>\n\t\t\t\t\t<!-- svelte-ignore a11y_no_noninteractive_tabindex -->\n\t\t\t\t\t<div\n\t\t\t\t\t\trole=\"region\"\n\t\t\t\t\t\taria-invalid={!!error}\n\t\t\t\t\t\tdata-dragging={isDragging ? '' : undefined}\n\t\t\t\t\t\tdata-invalid={error ? '' : undefined}\n\t\t\t\t\t\ttabindex={isDragging ? -1 : 0}\n\t\t\t\t\t\tclass=\"flex cursor-pointer flex-col items-center justify-center gap-2 rounded-md border-2 border-dashed p-6 outline-none transition-colors hover:bg-accent/30 focus-visible:border-ring/50 data-[dragging]:border-primary/30 data-[invalid]:border-destructive data-[dragging]:bg-accent/30 data-[invalid]:ring-destructive/20\"\n\t\t\t\t\t\tbind:this={dropzoneRef}\n\t\t\t\t\t\tonclick={handleDropzoneClick}\n\t\t\t\t\t\tondragenter={handleDropzoneDragEnter}\n\t\t\t\t\t\tondragleave={handleDropzoneDragLeave}\n\t\t\t\t\t\tondragover={handleDropzoneDragOver}\n\t\t\t\t\t\tondrop={handleDropzoneDrop}\n\t\t\t\t\t\tonkeydown={handleDropzoneKeyDown}\n\t\t\t\t\t>\n\t\t\t\t\t\t<Upload class=\"size-8 text-muted-foreground\" />\n\t\t\t\t\t\t<div class=\"text-center text-sm\">\n\t\t\t\t\t\t\t<p class=\"font-medium\">\n\t\t\t\t\t\t\t\t{isDragging ? 'Drop files here' : 'Drag files here'}\n\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t\t<p class=\"text-muted-foreground text-xs\">or click to browse</p>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t\t<p class=\"text-muted-foreground text-xs\">\n\t\t\t\t\t\t\t{maxFileSize\n\t\t\t\t\t\t\t\t? `Max size: ${formatFileSize(maxFileSize)}${maxFiles ? `  Max ${maxFiles} files` : ''}`\n\t\t\t\t\t\t\t\t: maxFiles\n\t\t\t\t\t\t\t\t\t? `Max ${maxFiles} files`\n\t\t\t\t\t\t\t\t\t: 'Select files to upload'}\n\t\t\t\t\t\t</p>\n\t\t\t\t\t</div>\n\t\t\t\t\t<input\n\t\t\t\t\t\ttype=\"file\"\n\t\t\t\t\t\t{multiple}\n\t\t\t\t\t\t{accept}\n\t\t\t\t\t\tclass=\"sr-only\"\n\t\t\t\t\t\tbind:this={fileInputRef}\n\t\t\t\t\t\tonchange={handleFileInputChange}\n\t\t\t\t\t/>\n\t\t\t\t\t{#if files.length > 0}\n\t\t\t\t\t\t<div class=\"flex flex-col gap-2\">\n\t\t\t\t\t\t\t<div class=\"flex items-center justify-between\">\n\t\t\t\t\t\t\t\t<p class=\"font-medium text-muted-foreground text-xs\">\n\t\t\t\t\t\t\t\t\t{files.length}\n\t\t\t\t\t\t\t\t\t{files.length === 1 ? 'file' : 'files'}\n\t\t\t\t\t\t\t\t</p>\n\t\t\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\t\t\ttype=\"button\"\n\t\t\t\t\t\t\t\t\tvariant=\"ghost\"\n\t\t\t\t\t\t\t\t\tsize=\"sm\"\n\t\t\t\t\t\t\t\t\tclass=\"h-6 text-muted-foreground text-xs\"\n\t\t\t\t\t\t\t\t\tonclick={clearAll}\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\tClear all\n\t\t\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t<div class=\"max-h-[200px] space-y-1 overflow-y-auto\">\n\t\t\t\t\t\t\t\t{#each files as file (file.id)}\n\t\t\t\t\t\t\t\t\t{@const FileIcon = getFileIcon(file.type)}\n\t\t\t\t\t\t\t\t\t<div class=\"flex items-center gap-2 rounded-md border bg-muted/50 px-2 py-1.5\">\n\t\t\t\t\t\t\t\t\t\t<FileIcon class=\"size-4 shrink-0 text-muted-foreground\" />\n\t\t\t\t\t\t\t\t\t\t<div class=\"flex-1 overflow-hidden\">\n\t\t\t\t\t\t\t\t\t\t\t<p class=\"truncate text-sm\">{file.name}</p>\n\t\t\t\t\t\t\t\t\t\t\t<p class=\"text-muted-foreground text-xs\">{formatFileSize(file.size)}</p>\n\t\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t\t<Button\n\t\t\t\t\t\t\t\t\t\t\ttype=\"button\"\n\t\t\t\t\t\t\t\t\t\t\tvariant=\"ghost\"\n\t\t\t\t\t\t\t\t\t\t\tsize=\"icon\"\n\t\t\t\t\t\t\t\t\t\t\tclass=\"size-5 rounded-sm\"\n\t\t\t\t\t\t\t\t\t\t\tonclick={() => removeFile(file.id)}\n\t\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t\t<X class=\"size-3\" />\n\t\t\t\t\t\t\t\t\t\t</Button>\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t{/each}\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t{/if}\n\t\t\t\t</div>\n\t\t\t</PopoverContent>\n\t\t</PopoverPrimitive.Root>\n\t{/if}\n\t{#if isDraggingOver}\n\t\t<div class=\"flex items-center justify-center gap-2 text-primary text-sm\">\n\t\t\t<Upload class=\"size-4\" />\n\t\t\t<span>Drop files here</span>\n\t\t</div>\n\t{:else if files.length > 0}\n\t\t<div class=\"flex flex-wrap items-center gap-1 overflow-hidden\">\n\t\t\t{#each visibleFiles as file (file.id)}\n\t\t\t\t{@const isUploading = uploadingFiles.has(file.id)}\n\t\t\t\t{#if isUploading}\n\t\t\t\t\t<Skeleton\n\t\t\t\t\t\tclass=\"h-5 shrink-0 px-1.5\"\n\t\t\t\t\t\tstyle=\"width: {Math.min(file.name.length * 8 + 30, 100)}px\"\n\t\t\t\t\t/>\n\t\t\t\t{:else}\n\t\t\t\t\t{@const FileIcon = getFileIcon(file.type)}\n\t\t\t\t\t<Badge variant=\"secondary\" class=\"h-5 shrink-0 gap-1 px-1.5 text-xs\">\n\t\t\t\t\t\t<FileIcon class=\"size-3 shrink-0\" />\n\t\t\t\t\t\t<span class=\"max-w-[100px] truncate\">{file.name}</span>\n\t\t\t\t\t</Badge>\n\t\t\t\t{/if}\n\t\t\t{/each}\n\t\t\t{#if hiddenFileCount > 0}\n\t\t\t\t<Badge variant=\"outline\" class=\"h-5 shrink-0 px-1.5 text-muted-foreground text-xs\">\n\t\t\t\t\t+{hiddenFileCount}\n\t\t\t\t</Badge>\n\t\t\t{/if}\n\t\t</div>\n\t{/if}\n</DataGridCellWrapper>\n",
			"type": "registry:component",
			"target": "file-cell.svelte"
		},
		{
			"content": "<script lang=\"ts\" generics=\"TData\">\n\timport type { CellVariantProps } from '$lib/types/data-grid.js';\n\timport DataGridCellWrapper from '../data-grid-cell-wrapper.svelte';\n\timport { Popover as PopoverPrimitive } from 'bits-ui';\n\timport { PopoverContent } from '$lib/components/ui/popover/index.js';\n\timport { Textarea } from '$lib/components/ui/textarea/index.js';\n\n\tlet {\n\t\tcell,\n\t\ttable,\n\t\trowIndex,\n\t\tcolumnId,\n\t\tisEditing,\n\t\tisFocused,\n\t\tisSelected,\n\t\treadOnly = false\n\t}: CellVariantProps<TData> = $props();\n\n\tconst initialValue = $derived(cell.getValue() as string);\n\tlet value = $state('');\n\tlet textareaRef = $state<HTMLTextAreaElement | null>(null);\n\tlet containerRef = $state<HTMLDivElement | null>(null);\n\tconst sideOffset = $derived(-(containerRef?.clientHeight ?? 0));\n\n\t// Track timeout for debounced save\n\tlet saveTimeoutId: ReturnType<typeof setTimeout> | null = null;\n\n\t// Initialize and sync value\n\t$effect(() => {\n\t\tconst iv = initialValue ?? '';\n\t\tif (iv !== value && !isEditing) {\n\t\t\tvalue = iv;\n\t\t}\n\t});\n\n\t// Debounced auto-save (300ms delay)\n\tfunction debouncedSave(newValue: string) {\n\t\tif (saveTimeoutId) {\n\t\t\tclearTimeout(saveTimeoutId);\n\t\t}\n\t\tsaveTimeoutId = setTimeout(() => {\n\t\t\tif (!readOnly) {\n\t\t\t\ttable.options.meta?.onDataUpdate?.({ rowIndex, columnId, value: newValue });\n\t\t\t}\n\t\t}, 300);\n\t}\n\n\tfunction handleSave() {\n\t\tif (saveTimeoutId) {\n\t\t\tclearTimeout(saveTimeoutId);\n\t\t\tsaveTimeoutId = null;\n\t\t}\n\t\tconst meta = table.options.meta;\n\t\tif (!readOnly && value !== initialValue) {\n\t\t\tmeta?.onDataUpdate?.({ rowIndex, columnId, value });\n\t\t}\n\t\tmeta?.onCellEditingStop?.();\n\t}\n\n\tfunction handleCancel() {\n\t\tif (saveTimeoutId) {\n\t\t\tclearTimeout(saveTimeoutId);\n\t\t\tsaveTimeoutId = null;\n\t\t}\n\t\tvalue = initialValue ?? '';\n\t\tconst meta = table.options.meta;\n\t\tif (!readOnly) {\n\t\t\tmeta?.onDataUpdate?.({ rowIndex, columnId, value: initialValue });\n\t\t}\n\t\tmeta?.onCellEditingStop?.();\n\t}\n\n\tfunction handleOpenChange(isOpen: boolean) {\n\t\tconst meta = table.options.meta;\n\t\tif (isOpen && !readOnly) {\n\t\t\tmeta?.onCellEditingStart?.(rowIndex, columnId);\n\t\t} else {\n\t\t\tif (!readOnly && value !== initialValue) {\n\t\t\t\tmeta?.onDataUpdate?.({ rowIndex, columnId, value });\n\t\t\t}\n\t\t\tmeta?.onCellEditingStop?.();\n\t\t}\n\t}\n\n\tfunction handleOpenAutoFocus(event: Event) {\n\t\tevent.preventDefault();\n\t\tif (textareaRef) {\n\t\t\ttextareaRef.focus();\n\t\t\tconst length = textareaRef.value.length;\n\t\t\ttextareaRef.setSelectionRange(length, length);\n\t\t}\n\t}\n\n\tfunction handleBlur() {\n\t\tconst meta = table.options.meta;\n\t\tif (!readOnly && value !== initialValue) {\n\t\t\tmeta?.onDataUpdate?.({ rowIndex, columnId, value });\n\t\t}\n\t\tmeta?.onCellEditingStop?.();\n\t}\n\n\tfunction handleInput(event: Event) {\n\t\tconst target = event.currentTarget as HTMLTextAreaElement;\n\t\tconst newValue = target.value;\n\t\tvalue = newValue;\n\t\tdebouncedSave(newValue);\n\t}\n\n\tfunction handleKeyDown(event: KeyboardEvent) {\n\t\tif (event.key === 'Escape') {\n\t\t\tevent.preventDefault();\n\t\t\thandleCancel();\n\t\t} else if (event.key === 'Enter' && (event.ctrlKey || event.metaKey)) {\n\t\t\tevent.preventDefault();\n\t\t\thandleSave();\n\t\t} else if (event.key === 'Tab') {\n\t\t\tevent.preventDefault();\n\t\t\tconst meta = table.options.meta;\n\t\t\tif (value !== initialValue) {\n\t\t\t\tmeta?.onDataUpdate?.({ rowIndex, columnId, value });\n\t\t\t}\n\t\t\tmeta?.onCellEditingStop?.({\n\t\t\t\tdirection: event.shiftKey ? 'left' : 'right'\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\t\tevent.stopPropagation();\n\t}\n</script>\n\n<DataGridCellWrapper\n\tbind:wrapperRef={containerRef}\n\t{cell}\n\t{table}\n\t{rowIndex}\n\t{columnId}\n\t{isEditing}\n\t{isFocused}\n\t{isSelected}\n>\n\t<span data-slot=\"grid-cell-content\">{value}</span>\n</DataGridCellWrapper>\n\n{#if isEditing}\n\t<PopoverPrimitive.Root open={isEditing} onOpenChange={handleOpenChange}>\n\t\t<PopoverContent\n\t\t\tdata-grid-cell-editor=\"\"\n\t\t\talign=\"start\"\n\t\t\tside=\"bottom\"\n\t\t\tsideOffset={sideOffset}\n\t\t\tclass=\"w-[400px] rounded-none p-0\"\n\t\t\tonOpenAutoFocus={handleOpenAutoFocus}\n\t\t\tcustomAnchor={containerRef}\n\t\t>\n\t\t\t<Textarea\n\t\t\t\tbind:ref={textareaRef}\n\t\t\t\tplaceholder=\"Enter text...\"\n\t\t\t\tclass=\"min-h-[150px] resize-none rounded-none border-0 shadow-none focus-visible:ring-0\"\n\t\t\t\t{value}\n\t\t\t\tonblur={handleBlur}\n\t\t\t\toninput={handleInput}\n\t\t\t\tonkeydown={handleKeyDown}\n\t\t\t/>\n\t\t</PopoverContent>\n\t</PopoverPrimitive.Root>\n{/if}\n",
			"type": "registry:component",
			"target": "long-text-cell.svelte"
		},
		{
			"content": "<script lang=\"ts\" generics=\"TData\">\n\timport type { CellVariantProps } from '$lib/types/data-grid.js';\n\timport { getCellKey, getLineCount } from '$lib/types/data-grid.js';\n\timport DataGridCellWrapper from '../data-grid-cell-wrapper.svelte';\n\timport { Popover as PopoverPrimitive } from 'bits-ui';\n\timport { PopoverContent } from '$lib/components/ui/popover/index.js';\n\timport {\n\t\tCommand,\n\t\tCommandEmpty,\n\t\tCommandGroup,\n\t\tCommandInput,\n\t\tCommandItem,\n\t\tCommandList,\n\t\tCommandSeparator\n\t} from '$lib/components/ui/command/index.js';\n\timport { Badge } from '$lib/components/ui/badge/index.js';\n\timport { cn } from '$UTILS$.js';\n\timport Check from '@lucide/svelte/icons/check';\n\timport X from '@lucide/svelte/icons/x';\n\n\tlet {\n\t\tcell,\n\t\ttable,\n\t\trowIndex,\n\t\tcolumnId,\n\t\tisEditing,\n\t\tisFocused,\n\t\tisSelected,\n\t\treadOnly = false\n\t}: CellVariantProps<TData> = $props();\n\n\tconst cellValue = $derived((cell.getValue() as string[]) ?? []);\n\tconst cellKey = $derived(getCellKey(rowIndex, columnId));\n\tlet prevCellKey = $state('');\n\n\tlet selectedValues = $state<string[]>([]);\n\tlet searchValue = $state('');\n\tlet containerRef = $state<HTMLDivElement | null>(null);\n\tlet inputRef = $state<HTMLInputElement | null>(null);\n\tconst cellOpts = $derived(cell.column.columnDef.meta?.cell);\n\tconst options = $derived(cellOpts?.variant === 'multi-select' ? cellOpts.options : []);\n\tconst sideOffset = $derived(-(containerRef?.clientHeight ?? 0));\n\n\t// Sync with cell value - compare by content, not reference\n\t$effect(() => {\n\t\tconst cv = cellValue;\n\t\tif (!isEditing) {\n\t\t\t// Only update if arrays differ by content\n\t\t\tif (cv.length !== selectedValues.length || cv.some((v, i) => v !== selectedValues[i])) {\n\t\t\t\tselectedValues = [...cv];\n\t\t\t}\n\t\t}\n\t});\n\n\t// Reset search when cell changes\n\t$effect(() => {\n\t\tif (prevCellKey !== cellKey) {\n\t\t\tprevCellKey = cellKey;\n\t\t\tsearchValue = '';\n\t\t}\n\t});\n\n\tfunction handleValueChange(value: string) {\n\t\tif (readOnly) return;\n\t\tconst newValues = selectedValues.includes(value)\n\t\t\t? selectedValues.filter((v) => v !== value)\n\t\t\t: [...selectedValues, value];\n\n\t\tselectedValues = newValues;\n\t\ttable.options.meta?.onDataUpdate?.({ rowIndex, columnId, value: newValues });\n\t\tsearchValue = '';\n\t\tqueueMicrotask(() => inputRef?.focus());\n\t}\n\n\tfunction removeValue(valueToRemove: string, event?: MouseEvent) {\n\t\tif (readOnly) return;\n\t\tevent?.stopPropagation();\n\t\tevent?.preventDefault();\n\t\tconst newValues = selectedValues.filter((v) => v !== valueToRemove);\n\t\tselectedValues = newValues;\n\t\ttable.options.meta?.onDataUpdate?.({ rowIndex, columnId, value: newValues });\n\t\tsetTimeout(() => inputRef?.focus(), 0);\n\t}\n\n\tfunction clearAll() {\n\t\tif (readOnly) return;\n\t\tselectedValues = [];\n\t\ttable.options.meta?.onDataUpdate?.({ rowIndex, columnId, value: [] });\n\t\tqueueMicrotask(() => inputRef?.focus());\n\t}\n\n\tfunction handleOpenChange(isOpen: boolean) {\n\t\tconst meta = table.options.meta;\n\t\tif (isOpen && !readOnly) {\n\t\t\tmeta?.onCellEditingStart?.(rowIndex, columnId);\n\t\t} else {\n\t\t\tsearchValue = '';\n\t\t\tmeta?.onCellEditingStop?.();\n\t\t}\n\t}\n\n\tfunction handleOpenAutoFocus(event: Event) {\n\t\tevent.preventDefault();\n\t\tinputRef?.focus();\n\t}\n\n\tfunction handleWrapperKeyDown(event: KeyboardEvent) {\n\t\tconst meta = table.options.meta;\n\t\tif (isEditing && event.key === 'Escape') {\n\t\t\tevent.preventDefault();\n\t\t\tselectedValues = [...cellValue];\n\t\t\tsearchValue = '';\n\t\t\tmeta?.onCellEditingStop?.();\n\t\t} else if (!isEditing && isFocused && event.key === 'Tab') {\n\t\t\tevent.preventDefault();\n\t\t\tsearchValue = '';\n\t\t\tmeta?.onCellEditingStop?.({\n\t\t\t\tdirection: event.shiftKey ? 'left' : 'right'\n\t\t\t});\n\t\t}\n\t}\n\n\tfunction handleInputKeyDown(event: KeyboardEvent) {\n\t\t// Handle backspace when input is empty - remove last selected item\n\t\tif (event.key === 'Backspace' && searchValue === '' && selectedValues.length > 0) {\n\t\t\tevent.preventDefault();\n\t\t\tconst lastValue = selectedValues[selectedValues.length - 1];\n\t\t\tif (lastValue) {\n\t\t\t\tremoveValue(lastValue);\n\t\t\t}\n\t\t}\n\t\t// Prevent escape from propagating to close the popover immediately\n\t\tif (event.key === 'Escape') {\n\t\t\tevent.stopPropagation();\n\t\t}\n\t}\n\n\tconst displayLabels = $derived(\n\t\tselectedValues\n\t\t\t.map((val) => options.find((opt) => opt.value === val)?.label ?? val)\n\t\t\t.filter(Boolean)\n\t);\n\n\tconst rowHeight = $derived(table.options.meta?.rowHeight ?? 'short');\n\tconst lineCount = $derived(getLineCount(rowHeight));\n\n\t// Simple visible badge calculation (can be enhanced with useBadgeOverflow hook)\n\tconst maxVisibleBadges = $derived(lineCount * 2);\n\tconst visibleLabels = $derived(displayLabels.slice(0, maxVisibleBadges));\n\tconst hiddenBadgeCount = $derived(Math.max(0, displayLabels.length - maxVisibleBadges));\n</script>\n\n<DataGridCellWrapper\n\tbind:wrapperRef={containerRef}\n\t{cell}\n\t{table}\n\t{rowIndex}\n\t{columnId}\n\t{isEditing}\n\t{isFocused}\n\t{isSelected}\n\tonkeydown={handleWrapperKeyDown}\n>\n\t{#if isEditing}\n\t\t<PopoverPrimitive.Root open={isEditing} onOpenChange={handleOpenChange}>\n\t\t\t<PopoverContent\n\t\t\t\tdata-grid-cell-editor=\"\"\n\t\t\t\talign=\"start\"\n\t\t\t\tsideOffset={sideOffset}\n\t\t\t\tclass=\"w-[300px] rounded-none p-0\"\n\t\t\t\tonOpenAutoFocus={handleOpenAutoFocus}\n\t\t\t\tcustomAnchor={containerRef}\n\t\t\t>\n\t\t\t\t<Command\n\t\t\t\t\tclass=\"**:data-[slot=command-input-wrapper]:h-auto **:data-[slot=command-input-wrapper]:border-none **:data-[slot=command-input-wrapper]:p-0 [&_[data-slot=command-input-wrapper]_svg]:hidden\"\n\t\t\t\t>\n\t\t\t\t\t<div class=\"flex min-h-9 flex-wrap items-center gap-1 border-b px-3 py-1.5\">\n\t\t\t\t\t\t{#each selectedValues as val (val)}\n\t\t\t\t\t\t\t{@const option = options.find((opt) => opt.value === val)}\n\t\t\t\t\t\t\t{@const label = option?.label ?? val}\n\t\t\t\t\t\t\t<Badge variant=\"secondary\" class=\"h-5 gap-1 px-1.5 text-xs\">\n\t\t\t\t\t\t\t\t{label}\n\t\t\t\t\t\t\t\t<button\n\t\t\t\t\t\t\t\t\ttype=\"button\"\n\t\t\t\t\t\t\t\t\tonclick={(event) => removeValue(val, event)}\n\t\t\t\t\t\t\t\t\tonpointerdown={(event) => {\n\t\t\t\t\t\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t<X class=\"size-3\" />\n\t\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t\t</Badge>\n\t\t\t\t\t\t{/each}\n\t\t\t\t\t\t<CommandInput\n\t\t\t\t\t\t\tbind:ref={inputRef}\n\t\t\t\t\t\t\tbind:value={searchValue}\n\t\t\t\t\t\t\tonkeydown={handleInputKeyDown}\n\t\t\t\t\t\t\tplaceholder=\"Search...\"\n\t\t\t\t\t\t\tclass=\"h-auto flex-1 p-0\"\n\t\t\t\t\t\t/>\n\t\t\t\t\t</div>\n\t\t\t\t\t<CommandList class=\"max-h-full\">\n\t\t\t\t\t\t<CommandEmpty>No options found.</CommandEmpty>\n\t\t\t\t\t\t<CommandGroup class=\"max-h-[300px] scroll-py-1 overflow-y-auto overflow-x-hidden\">\n\t\t\t\t\t\t\t{#each options as option (option.value)}\n\t\t\t\t\t\t\t\t{@const isItemSelected = selectedValues.includes(option.value)}\n\t\t\t\t\t\t\t\t<CommandItem value={option.label} onSelect={() => handleValueChange(option.value)}>\n\t\t\t\t\t\t\t\t\t<div\n\t\t\t\t\t\t\t\t\t\tclass={cn(\n\t\t\t\t\t\t\t\t\t\t\t'flex size-4 items-center justify-center rounded-sm border border-primary',\n\t\t\t\t\t\t\t\t\t\t\tisItemSelected\n\t\t\t\t\t\t\t\t\t\t\t\t? 'bg-primary text-primary-foreground'\n\t\t\t\t\t\t\t\t\t\t\t\t: 'opacity-50 [&_svg]:invisible'\n\t\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t\t<Check class=\"size-3\" />\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t<span>{option.label}</span>\n\t\t\t\t\t\t\t\t</CommandItem>\n\t\t\t\t\t\t\t{/each}\n\t\t\t\t\t\t</CommandGroup>\n\t\t\t\t\t\t{#if selectedValues.length > 0}\n\t\t\t\t\t\t\t<CommandSeparator />\n\t\t\t\t\t\t\t<CommandGroup>\n\t\t\t\t\t\t\t\t<CommandItem onSelect={clearAll} class=\"justify-center text-muted-foreground\">\n\t\t\t\t\t\t\t\t\tClear all\n\t\t\t\t\t\t\t\t</CommandItem>\n\t\t\t\t\t\t\t</CommandGroup>\n\t\t\t\t\t\t{/if}\n\t\t\t\t\t</CommandList>\n\t\t\t\t</Command>\n\t\t\t</PopoverContent>\n\t\t</PopoverPrimitive.Root>\n\t{/if}\n\t{#if displayLabels.length > 0}\n\t\t<div class=\"flex flex-wrap items-center gap-1 overflow-hidden\">\n\t\t\t{#each visibleLabels as label, index (selectedValues[index])}\n\t\t\t\t<Badge variant=\"secondary\" class=\"h-5 shrink-0 px-1.5 text-xs\">\n\t\t\t\t\t{label}\n\t\t\t\t</Badge>\n\t\t\t{/each}\n\t\t\t{#if hiddenBadgeCount > 0}\n\t\t\t\t<Badge variant=\"outline\" class=\"h-5 shrink-0 px-1.5 text-muted-foreground text-xs\">\n\t\t\t\t\t+{hiddenBadgeCount}\n\t\t\t\t</Badge>\n\t\t\t{/if}\n\t\t</div>\n\t{/if}\n</DataGridCellWrapper>\n",
			"type": "registry:component",
			"target": "multi-select-cell.svelte"
		},
		{
			"content": "<script lang=\"ts\" generics=\"TData\">\n\timport type { CellVariantProps } from '$lib/types/data-grid.js';\n\timport DataGridCellWrapper from '../data-grid-cell-wrapper.svelte';\n\n\tlet {\n\t\tcell,\n\t\ttable,\n\t\trowIndex,\n\t\tcolumnId,\n\t\tisEditing,\n\t\tisFocused,\n\t\tisSelected,\n\t\treadOnly = false\n\t}: CellVariantProps<TData> = $props();\n\n\tconst initialValue = $derived(cell.getValue() as number);\n\tlet value = $state('');\n\tlet inputRef = $state<HTMLInputElement | null>(null);\n\tconst cellOpts = $derived(cell.column.columnDef.meta?.cell);\n\tconst min = $derived(cellOpts?.variant === 'number' ? cellOpts.min : undefined);\n\tconst max = $derived(cellOpts?.variant === 'number' ? cellOpts.max : undefined);\n\tconst step = $derived(cellOpts?.variant === 'number' ? cellOpts.step : undefined);\n\n\t// Initialize and sync value\n\t$effect(() => {\n\t\tconst iv = initialValue;\n\t\tconst ivStr = String(iv ?? '');\n\t\tif (ivStr !== value && !isEditing) {\n\t\t\tvalue = ivStr;\n\t\t}\n\t});\n\n\t// Focus input when entering edit mode\n\t$effect(() => {\n\t\tif (isEditing && inputRef) {\n\t\t\tinputRef.focus();\n\t\t\tinputRef.select();\n\t\t}\n\t});\n\n\tfunction handleBlur() {\n\t\tconst numValue = value === '' ? null : Number(value);\n\t\tconst meta = table.options.meta;\n\t\tif (!readOnly && numValue !== initialValue) {\n\t\t\tmeta?.onDataUpdate?.({ rowIndex, columnId, value: numValue });\n\t\t}\n\t\tmeta?.onCellEditingStop?.();\n\t}\n\n\tfunction handleInput(event: Event) {\n\t\tconst target = event.currentTarget as HTMLInputElement;\n\t\tvalue = target.value;\n\t}\n\n\tfunction handleWrapperKeyDown(event: KeyboardEvent) {\n\t\tconst meta = table.options.meta;\n\t\tif (isEditing) {\n\t\t\tif (event.key === 'Enter') {\n\t\t\t\tevent.preventDefault();\n\t\t\t\tconst numValue = value === '' ? null : Number(value);\n\t\t\t\tif (numValue !== initialValue) {\n\t\t\t\t\tmeta?.onDataUpdate?.({ rowIndex, columnId, value: numValue });\n\t\t\t\t}\n\t\t\t\tmeta?.onCellEditingStop?.({ moveToNextRow: true });\n\t\t\t} else if (event.key === 'Tab') {\n\t\t\t\tevent.preventDefault();\n\t\t\t\tconst numValue = value === '' ? null : Number(value);\n\t\t\t\tif (numValue !== initialValue) {\n\t\t\t\t\tmeta?.onDataUpdate?.({ rowIndex, columnId, value: numValue });\n\t\t\t\t}\n\t\t\t\tmeta?.onCellEditingStop?.({\n\t\t\t\t\tdirection: event.shiftKey ? 'left' : 'right'\n\t\t\t\t});\n\t\t\t} else if (event.key === 'Escape') {\n\t\t\t\tevent.preventDefault();\n\t\t\t\tvalue = String(initialValue ?? '');\n\t\t\t\tinputRef?.blur();\n\t\t\t}\n\t\t} else if (isFocused) {\n\t\t\t// Handle Backspace to start editing with empty value\n\t\t\tif (event.key === 'Backspace') {\n\t\t\t\tvalue = '';\n\t\t\t} else if (event.key.length === 1 && !event.ctrlKey && !event.metaKey) {\n\t\t\t\t// Handle typing to pre-fill the value when editing starts\n\t\t\t\tvalue = event.key;\n\t\t\t}\n\t\t}\n\t}\n</script>\n\n<DataGridCellWrapper\n\t{cell}\n\t{table}\n\t{rowIndex}\n\t{columnId}\n\t{isEditing}\n\t{isFocused}\n\t{isSelected}\n\tonkeydown={handleWrapperKeyDown}\n>\n\t{#if isEditing}\n\t\t<input\n\t\t\tbind:this={inputRef}\n\t\t\ttype=\"number\"\n\t\t\t{value}\n\t\t\t{min}\n\t\t\t{max}\n\t\t\t{step}\n\t\t\tonblur={handleBlur}\n\t\t\toninput={handleInput}\n\t\t\tclass=\"w-full border-none bg-transparent p-0 outline-none\"\n\t\t/>\n\t{:else}\n\t\t<span data-slot=\"grid-cell-content\">{value}</span>\n\t{/if}\n</DataGridCellWrapper>\n",
			"type": "registry:component",
			"target": "number-cell.svelte"
		},
		{
			"content": "<script lang=\"ts\" generics=\"TData\">\n\timport type { Row, Table } from '@tanstack/table-core';\n\timport { Checkbox } from '$lib/components/ui/checkbox/index.js';\n\n\tinterface Props {\n\t\trow: Row<TData>;\n\t\ttable: Table<TData>;\n\t\trowIndex: number;\n\t}\n\n\tlet { row, table, rowIndex }: Props = $props();\n\n\tconst isSelected = $derived(row.getIsSelected());\n\tconst meta = $derived(table.options.meta);\n\n\tfunction handleChange(event: Event) {\n\t\tconst target = event.target as HTMLInputElement;\n\t\tconst checked = target.checked;\n\t\tconst onRowSelect = meta?.onRowSelect;\n\t\tif (onRowSelect) {\n\t\t\tonRowSelect(rowIndex, checked, false);\n\t\t} else {\n\t\t\trow.toggleSelected(checked);\n\t\t}\n\t}\n\n\tfunction handleClick(event: MouseEvent) {\n\t\tif (event.shiftKey) {\n\t\t\tevent.preventDefault();\n\t\t\tconst onRowSelect = meta?.onRowSelect;\n\t\t\tif (onRowSelect) {\n\t\t\t\tonRowSelect(rowIndex, !isSelected, true);\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction handleMouseDown(event: MouseEvent) {\n\t\tevent.stopPropagation();\n\t}\n</script>\n\n<div\n\tclass=\"flex size-full items-center justify-center px-3 py-1.5 {isSelected ? 'bg-primary/10' : ''}\"\n>\n\t<Checkbox\n\t\taria-label=\"Select row\"\n\t\tclass=\"after:-inset-2.5 relative transition-[shadow,border] after:absolute after:content-[''] hover:border-primary/40\"\n\t\tchecked={isSelected}\n\t\tonchange={handleChange}\n\t\tonclick={handleClick}\n\t\tonmousedown={handleMouseDown}\n\t/>\n</div>\n",
			"type": "registry:component",
			"target": "row-select-cell.svelte"
		},
		{
			"content": "<script lang=\"ts\">\n\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\timport type { Table } from '@tanstack/table-core';\n\timport { Checkbox } from '$lib/components/ui/checkbox/index.js';\n\n\tinterface Props {\n\t\t// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\t\ttable: Table<any>;\n\t}\n\n\tlet { table }: Props = $props();\n\n\tconst isAllSelected = $derived(table.getIsAllPageRowsSelected());\n\tconst isSomeSelected = $derived(table.getIsSomePageRowsSelected());\n\n\tfunction handleChange(event: Event) {\n\t\tconst target = event.target as HTMLInputElement;\n\t\ttable.toggleAllPageRowsSelected(target.checked);\n\t}\n</script>\n\n<div class=\"flex size-full items-center justify-center px-3 py-1.5\">\n\t<Checkbox\n\t\taria-label=\"Select all\"\n\t\tclass=\"after:-inset-2.5 relative transition-[shadow,border] after:absolute after:content-[''] hover:border-primary/40\"\n\t\tchecked={isAllSelected}\n\t\tindeterminate={!isAllSelected && isSomeSelected}\n\t\tonchange={handleChange}\n\t/>\n</div>\n",
			"type": "registry:component",
			"target": "row-select-header.svelte"
		},
		{
			"content": "<script lang=\"ts\" generics=\"TData\">\n\timport type { CellVariantProps } from '$lib/types/data-grid.js';\n\timport DataGridCellWrapper from '../data-grid-cell-wrapper.svelte';\n\timport {\n\t\tSelect,\n\t\tSelectContent,\n\t\tSelectItem,\n\t\tSelectTrigger\n\t} from '$lib/components/ui/select/index.js';\n\n\tlet {\n\t\tcell,\n\t\ttable,\n\t\trowIndex,\n\t\tcolumnId,\n\t\tisEditing,\n\t\tisFocused,\n\t\tisSelected,\n\t\treadOnly = false\n\t}: CellVariantProps<TData> = $props();\n\n\tconst initialValue = $derived(cell.getValue() as string);\n\tlet value = $state('');\n\tconst cellOpts = $derived(cell.column.columnDef.meta?.cell);\n\tconst options = $derived(cellOpts?.variant === 'select' ? cellOpts.options : []);\n\n\t// Initialize and sync value\n\t$effect(() => {\n\t\tconst iv = initialValue;\n\t\tif (iv !== value && !isEditing) {\n\t\t\tvalue = iv;\n\t\t}\n\t});\n\n\tfunction handleValueChange(newValue: string | undefined) {\n\t\tif (readOnly || !newValue) return;\n\t\tvalue = newValue;\n\t\tconst meta = table.options.meta;\n\t\tmeta?.onDataUpdate?.({ rowIndex, columnId, value: newValue });\n\t\tmeta?.onCellEditingStop?.();\n\t}\n\n\tfunction handleOpenChange(isOpen: boolean) {\n\t\tconst meta = table.options.meta;\n\t\tif (isOpen && !readOnly) {\n\t\t\tmeta?.onCellEditingStart?.(rowIndex, columnId);\n\t\t} else {\n\t\t\tmeta?.onCellEditingStop?.();\n\t\t}\n\t}\n\n\tfunction handleWrapperKeyDown(event: KeyboardEvent) {\n\t\tconst meta = table.options.meta;\n\t\tif (isEditing && event.key === 'Escape') {\n\t\t\tevent.preventDefault();\n\t\t\tvalue = initialValue;\n\t\t\tmeta?.onCellEditingStop?.();\n\t\t} else if (!isEditing && isFocused && event.key === 'Tab') {\n\t\t\tevent.preventDefault();\n\t\t\tmeta?.onCellEditingStop?.({\n\t\t\t\tdirection: event.shiftKey ? 'left' : 'right'\n\t\t\t});\n\t\t}\n\t}\n\n\tconst displayLabel = $derived(options.find((opt) => opt.value === value)?.label ?? value);\n</script>\n\n<DataGridCellWrapper\n\t{cell}\n\t{table}\n\t{rowIndex}\n\t{columnId}\n\t{isEditing}\n\t{isFocused}\n\t{isSelected}\n\tonkeydown={handleWrapperKeyDown}\n>\n\t{#if isEditing}\n\t\t<Select\n\t\t\ttype=\"single\"\n\t\t\t{value}\n\t\t\tonValueChange={handleValueChange}\n\t\t\topen={isEditing}\n\t\t\tonOpenChange={handleOpenChange}\n\t\t>\n\t\t\t<SelectTrigger\n\t\t\t\tclass=\"size-full items-start border-none p-0 shadow-none focus-visible:ring-0 dark:bg-transparent [&_svg]:hidden\"\n\t\t\t>\n\t\t\t\t{displayLabel}\n\t\t\t</SelectTrigger>\n\t\t\t<SelectContent\n\t\t\t\tdata-grid-cell-editor=\"\"\n\t\t\t\talign=\"start\"\n\t\t\t\talignOffset={-8}\n\t\t\t\tsideOffset={-8}\n\t\t\t\tclass=\"min-w-[calc(var(--bits-select-trigger-width)+16px)]\"\n\t\t\t>\n\t\t\t\t{#each options as option (option.value)}\n\t\t\t\t\t<SelectItem value={option.value}>\n\t\t\t\t\t\t{option.label}\n\t\t\t\t\t</SelectItem>\n\t\t\t\t{/each}\n\t\t\t</SelectContent>\n\t\t</Select>\n\t{:else}\n\t\t<span data-slot=\"grid-cell-content\">{displayLabel}</span>\n\t{/if}\n</DataGridCellWrapper>\n",
			"type": "registry:component",
			"target": "select-cell.svelte"
		},
		{
			"content": "<script lang=\"ts\" generics=\"TData\">\n\timport type { CellVariantProps } from '$lib/types/data-grid.js';\n\timport DataGridCellWrapper from '../data-grid-cell-wrapper.svelte';\n\timport { cn } from '$UTILS$.js';\n\n\tlet {\n\t\tcell,\n\t\ttable,\n\t\trowIndex,\n\t\tcolumnId,\n\t\tisEditing,\n\t\tisFocused,\n\t\tisSelected,\n\t\treadOnly = false\n\t}: CellVariantProps<TData> = $props();\n\n\tconst initialValue = $derived(cell.getValue() as string);\n\tlet value = $state('');\n\tlet cellRef = $state<HTMLDivElement | null>(null);\n\n\t// Initialize and sync value\n\t$effect(() => {\n\t\tconst iv = initialValue ?? '';\n\t\tif (iv !== value && !isEditing) {\n\t\t\tvalue = iv;\n\t\t\tif (cellRef) {\n\t\t\t\tcellRef.textContent = iv;\n\t\t\t}\n\t\t}\n\t});\n\n\t// Focus cell when entering edit mode\n\t$effect(() => {\n\t\tif (isEditing && cellRef) {\n\t\t\tcellRef.focus();\n\n\t\t\tif (!cellRef.textContent && value) {\n\t\t\t\tcellRef.textContent = value;\n\t\t\t}\n\n\t\t\t// Move cursor to end\n\t\t\tif (cellRef.textContent) {\n\t\t\t\tconst range = document.createRange();\n\t\t\t\tconst selection = window.getSelection();\n\t\t\t\trange.selectNodeContents(cellRef);\n\t\t\t\trange.collapse(false);\n\t\t\t\tselection?.removeAllRanges();\n\t\t\t\tselection?.addRange(range);\n\t\t\t}\n\t\t}\n\t});\n\n\tfunction handleBlur() {\n\t\tconst currentValue = cellRef?.textContent ?? '';\n\t\tconst meta = table.options.meta;\n\t\tif (!readOnly && currentValue !== initialValue) {\n\t\t\tmeta?.onDataUpdate?.({ rowIndex, columnId, value: currentValue });\n\t\t}\n\t\tmeta?.onCellEditingStop?.();\n\t}\n\n\tfunction handleInput(event: Event) {\n\t\tconst target = event.currentTarget as HTMLDivElement;\n\t\tvalue = target.textContent ?? '';\n\t}\n\n\tfunction handleWrapperKeyDown(event: KeyboardEvent) {\n\t\tconst meta = table.options.meta;\n\t\tif (isEditing) {\n\t\t\tif (event.key === 'Enter') {\n\t\t\t\tevent.preventDefault();\n\t\t\t\tconst currentValue = cellRef?.textContent ?? '';\n\t\t\t\tif (currentValue !== initialValue) {\n\t\t\t\t\tmeta?.onDataUpdate?.({ rowIndex, columnId, value: currentValue });\n\t\t\t\t}\n\t\t\t\tmeta?.onCellEditingStop?.({ moveToNextRow: true });\n\t\t\t} else if (event.key === 'Tab') {\n\t\t\t\tevent.preventDefault();\n\t\t\t\tconst currentValue = cellRef?.textContent ?? '';\n\t\t\t\tif (currentValue !== initialValue) {\n\t\t\t\t\tmeta?.onDataUpdate?.({ rowIndex, columnId, value: currentValue });\n\t\t\t\t}\n\t\t\t\tmeta?.onCellEditingStop?.({\n\t\t\t\t\tdirection: event.shiftKey ? 'left' : 'right'\n\t\t\t\t});\n\t\t\t} else if (event.key === 'Escape') {\n\t\t\t\tevent.preventDefault();\n\t\t\t\tvalue = initialValue ?? '';\n\t\t\t\tcellRef?.blur();\n\t\t\t}\n\t\t} else if (isFocused && event.key.length === 1 && !event.ctrlKey && !event.metaKey) {\n\t\t\t// Pre-fill value when typing starts\n\t\t\tvalue = event.key;\n\n\t\t\tqueueMicrotask(() => {\n\t\t\t\tif (cellRef && cellRef.contentEditable === 'true') {\n\t\t\t\t\tcellRef.textContent = event.key;\n\t\t\t\t\tconst range = document.createRange();\n\t\t\t\t\tconst selection = window.getSelection();\n\t\t\t\t\trange.selectNodeContents(cellRef);\n\t\t\t\t\trange.collapse(false);\n\t\t\t\t\tselection?.removeAllRanges();\n\t\t\t\t\tselection?.addRange(range);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tconst displayValue = $derived(!isEditing ? (value ?? '') : '');\n</script>\n\n<DataGridCellWrapper\n\t{cell}\n\t{table}\n\t{rowIndex}\n\t{columnId}\n\t{isEditing}\n\t{isFocused}\n\t{isSelected}\n\tonkeydown={handleWrapperKeyDown}\n>\n\t<!-- svelte-ignore a11y_no_noninteractive_tabindex -->\n\t<div\n\t\trole=\"textbox\"\n\t\tdata-slot=\"grid-cell-content\"\n\t\tcontenteditable={isEditing}\n\t\ttabindex={-1}\n\t\tbind:this={cellRef}\n\t\tonblur={handleBlur}\n\t\toninput={handleInput}\n\t\tclass={cn('size-full overflow-hidden outline-none', {\n\t\t\t'whitespace-nowrap **:inline **:whitespace-nowrap [&_br]:hidden': isEditing\n\t\t})}\n\t>\n\t\t{displayValue}\n\t</div>\n</DataGridCellWrapper>\n",
			"type": "registry:component",
			"target": "short-text-cell.svelte"
		},
		{
			"content": "<script lang=\"ts\" generics=\"TData\">\n\timport type { CellVariantProps } from '$lib/types/data-grid.js';\n\timport DataGridCellWrapper from '../data-grid-cell-wrapper.svelte';\n\timport { cn } from '$UTILS$.js';\n\timport { toast } from 'svelte-sonner';\n\n\tlet {\n\t\tcell,\n\t\ttable,\n\t\trowIndex,\n\t\tcolumnId,\n\t\tisEditing,\n\t\tisFocused,\n\t\tisSelected,\n\t\treadOnly = false\n\t}: CellVariantProps<TData> = $props();\n\n\tconst initialValue = $derived(cell.getValue() as string);\n\tlet value = $state('');\n\tlet cellRef = $state<HTMLDivElement | null>(null);\n\n\t// Initialize and sync value\n\t$effect(() => {\n\t\tconst iv = initialValue ?? '';\n\t\tif (iv !== value && !isEditing) {\n\t\t\tvalue = iv;\n\t\t\tif (cellRef) {\n\t\t\t\tcellRef.textContent = iv;\n\t\t\t}\n\t\t}\n\t});\n\n\t// Focus cell when entering edit mode\n\t$effect(() => {\n\t\tif (isEditing && cellRef) {\n\t\t\tcellRef.focus();\n\n\t\t\tif (!cellRef.textContent && value) {\n\t\t\t\tcellRef.textContent = value;\n\t\t\t}\n\n\t\t\tif (cellRef.textContent) {\n\t\t\t\tconst range = document.createRange();\n\t\t\t\tconst selection = window.getSelection();\n\t\t\t\trange.selectNodeContents(cellRef);\n\t\t\t\trange.collapse(false);\n\t\t\t\tselection?.removeAllRanges();\n\t\t\t\tselection?.addRange(range);\n\t\t\t}\n\t\t}\n\t});\n\n\tfunction getUrlHref(urlString: string): string {\n\t\tif (!urlString || urlString.trim() === '') return '';\n\n\t\tconst trimmed = urlString.trim();\n\n\t\t// Reject dangerous protocols\n\t\tif (/^(javascript|data|vbscript|file):/i.test(trimmed)) {\n\t\t\treturn '';\n\t\t}\n\n\t\t// Check if it already has a protocol\n\t\tif (trimmed.startsWith('http://') || trimmed.startsWith('https://')) {\n\t\t\treturn trimmed;\n\t\t}\n\n\t\t// Add http:// prefix for links without protocol\n\t\treturn `http://${trimmed}`;\n\t}\n\n\tfunction handleBlur() {\n\t\tconst currentValue = cellRef?.textContent?.trim() ?? '';\n\t\tconst meta = table.options.meta;\n\n\t\tif (!readOnly && currentValue !== initialValue) {\n\t\t\tmeta?.onDataUpdate?.({\n\t\t\t\trowIndex,\n\t\t\t\tcolumnId,\n\t\t\t\tvalue: currentValue || null\n\t\t\t});\n\t\t}\n\t\tmeta?.onCellEditingStop?.();\n\t}\n\n\tfunction handleInput(event: Event) {\n\t\tconst target = event.currentTarget as HTMLDivElement;\n\t\tvalue = target.textContent ?? '';\n\t}\n\n\tfunction handleWrapperKeyDown(event: KeyboardEvent) {\n\t\tconst meta = table.options.meta;\n\t\tif (isEditing) {\n\t\t\tif (event.key === 'Enter') {\n\t\t\t\tevent.preventDefault();\n\t\t\t\tconst currentValue = cellRef?.textContent?.trim() ?? '';\n\t\t\t\tif (!readOnly && currentValue !== initialValue) {\n\t\t\t\t\tmeta?.onDataUpdate?.({\n\t\t\t\t\t\trowIndex,\n\t\t\t\t\t\tcolumnId,\n\t\t\t\t\t\tvalue: currentValue || null\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tmeta?.onCellEditingStop?.({ moveToNextRow: true });\n\t\t\t} else if (event.key === 'Tab') {\n\t\t\t\tevent.preventDefault();\n\t\t\t\tconst currentValue = cellRef?.textContent?.trim() ?? '';\n\t\t\t\tif (!readOnly && currentValue !== initialValue) {\n\t\t\t\t\tmeta?.onDataUpdate?.({\n\t\t\t\t\t\trowIndex,\n\t\t\t\t\t\tcolumnId,\n\t\t\t\t\t\tvalue: currentValue || null\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tmeta?.onCellEditingStop?.({\n\t\t\t\t\tdirection: event.shiftKey ? 'left' : 'right'\n\t\t\t\t});\n\t\t\t} else if (event.key === 'Escape') {\n\t\t\t\tevent.preventDefault();\n\t\t\t\tvalue = initialValue ?? '';\n\t\t\t\tcellRef?.blur();\n\t\t\t}\n\t\t} else if (isFocused && !readOnly && event.key.length === 1 && !event.ctrlKey && !event.metaKey) {\n\t\t\t// Handle typing to pre-fill the value when editing starts\n\t\t\tvalue = event.key;\n\n\t\t\tqueueMicrotask(() => {\n\t\t\t\tif (cellRef && cellRef.contentEditable === 'true') {\n\t\t\t\t\tcellRef.textContent = event.key;\n\t\t\t\t\tconst range = document.createRange();\n\t\t\t\t\tconst selection = window.getSelection();\n\t\t\t\t\trange.selectNodeContents(cellRef);\n\t\t\t\t\trange.collapse(false);\n\t\t\t\t\tselection?.removeAllRanges();\n\t\t\t\t\tselection?.addRange(range);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tfunction handleLinkClick(event: MouseEvent) {\n\t\tif (isEditing) {\n\t\t\tevent.preventDefault();\n\t\t\treturn;\n\t\t}\n\n\t\t// Check if URL was rejected due to dangerous protocol\n\t\tconst href = getUrlHref(value);\n\t\tif (!href) {\n\t\t\tevent.preventDefault();\n\t\t\ttoast.error('Invalid URL', {\n\t\t\t\tdescription: 'URL contains a dangerous protocol (javascript:, data:, vbscript:, or file:)'\n\t\t\t});\n\t\t\treturn;\n\t\t}\n\n\t\t// Stop propagation to prevent grid from interfering with link navigation\n\t\tevent.stopPropagation();\n\t}\n\n\tconst displayValue = $derived(!isEditing ? (value ?? '') : '');\n\tconst urlHref = $derived(displayValue ? getUrlHref(displayValue) : '');\n\tconst isDangerousUrl = $derived(displayValue && !urlHref);\n</script>\n\n<DataGridCellWrapper\n\t{cell}\n\t{table}\n\t{rowIndex}\n\t{columnId}\n\t{isEditing}\n\t{isFocused}\n\t{isSelected}\n\tonkeydown={handleWrapperKeyDown}\n>\n\t{#if !isEditing && displayValue}\n\t\t<div data-slot=\"grid-cell-content\" class=\"size-full overflow-hidden\">\n\t\t\t<a\n\t\t\t\tdata-focused={isFocused && !isDangerousUrl ? '' : undefined}\n\t\t\t\tdata-invalid={isDangerousUrl ? '' : undefined}\n\t\t\t\thref={urlHref}\n\t\t\t\ttarget=\"_blank\"\n\t\t\t\trel=\"noopener noreferrer\"\n\t\t\t\tclass=\"truncate text-primary underline decoration-primary/30 underline-offset-2 hover:decoration-primary/60 data-[invalid]:cursor-not-allowed data-[focused]:text-foreground data-[invalid]:text-destructive data-[focused]:decoration-foreground/50 data-[invalid]:decoration-destructive/50 data-[focused]:hover:decoration-foreground/70 data-[invalid]:hover:decoration-destructive/70\"\n\t\t\t\tonclick={handleLinkClick}\n\t\t\t>\n\t\t\t\t{displayValue}\n\t\t\t</a>\n\t\t</div>\n\t{:else}\n\t\t<!-- svelte-ignore a11y_no_noninteractive_tabindex -->\n\t\t<div\n\t\t\trole=\"textbox\"\n\t\t\tdata-slot=\"grid-cell-content\"\n\t\t\tcontenteditable={isEditing}\n\t\t\ttabindex={-1}\n\t\t\tbind:this={cellRef}\n\t\t\tonblur={handleBlur}\n\t\t\toninput={handleInput}\n\t\t\tclass={cn('size-full overflow-hidden outline-none', {\n\t\t\t\t'whitespace-nowrap **:inline **:whitespace-nowrap [&_br]:hidden': isEditing\n\t\t\t})}\n\t\t>\n\t\t\t{displayValue}\n\t\t</div>\n\t{/if}\n</DataGridCellWrapper>\n",
			"type": "registry:component",
			"target": "url-cell.svelte"
		},
		{
			"content": "// Cell variant components\nexport { default as ShortTextCell } from './short-text-cell.svelte';\nexport { default as LongTextCell } from './long-text-cell.svelte';\nexport { default as NumberCell } from './number-cell.svelte';\nexport { default as CheckboxCell } from './checkbox-cell.svelte';\nexport { default as SelectCell } from './select-cell.svelte';\nexport { default as MultiSelectCell } from './multi-select-cell.svelte';\nexport { default as DateCell } from './date-cell.svelte';\nexport { default as UrlCell } from './url-cell.svelte';\nexport { default as FileCell } from './file-cell.svelte';\n\n// Row selection components\nexport { default as RowSelectCell } from './row-select-cell.svelte';\nexport { default as RowSelectHeader } from './row-select-header.svelte';\n",
			"type": "registry:component",
			"target": "index.ts"
		},
		{
			"content": "/**\n * useDataGrid - Svelte 5 port of TableCN's useDataGrid React hook\n *\n * This is the core hook that manages all data grid state including:\n * - Cell focus and editing\n * - Cell selection (single, multi, range)\n * - Keyboard navigation\n * - Copy/paste functionality\n * - Search\n * - Context menus\n * - Row virtualization\n */\n\nimport { untrack } from 'svelte';\nimport { SvelteSet } from 'svelte/reactivity';\nimport {\n\tcreateTable,\n\tgetCoreRowModel,\n\tgetSortedRowModel,\n\tgetFilteredRowModel,\n\ttype ColumnDef,\n\ttype RowData,\n\ttype TableOptions,\n\ttype TableOptionsResolved,\n\ttype Table,\n\ttype SortingState,\n\ttype ColumnFiltersState,\n\ttype RowSelectionState,\n\ttype TableState,\n\ttype ColumnPinningState,\n\ttype VisibilityState,\n\ttype ColumnSizingState,\n\ttype ColumnSizingInfoState\n} from '@tanstack/table-core';\nimport {\n\tVirtualizer,\n\telementScroll,\n\tobserveElementOffset,\n\tobserveElementRect\n} from '@tanstack/virtual-core';\nimport type {\n\tCellPosition,\n\tCellRange,\n\tSelectionState,\n\tContextMenuState,\n\tPasteDialogState,\n\tRowHeightValue,\n\tNavigationDirection,\n\tUpdateCell,\n\tSearchState,\n\tFileCellData\n} from '$lib/types/data-grid.js';\nimport { getCellKey, parseCellKey, getRowHeightValue } from '$lib/types/data-grid.js';\nimport { toast } from 'svelte-sonner';\n\n// ============================================\n// Types\n// ============================================\n\nexport interface UseDataGridOptions<TData extends RowData> {\n\tcolumns: ColumnDef<TData, unknown>[];\n\tdata: TData[];\n\trowHeight?: RowHeightValue;\n\tautoFocus?: boolean | { rowIndex?: number; columnId?: string };\n\tenableColumnSelection?: boolean;\n\tenableSearch?: boolean;\n\tenablePaste?: boolean;\n\treadOnly?: boolean;\n\toverscan?: number;\n\tgetRowId?: (row: TData, index: number) => string;\n\tinitialState?: {\n\t\tsorting?: SortingState;\n\t\tcolumnFilters?: ColumnFiltersState;\n\t\tcolumnVisibility?: VisibilityState;\n\t\tcolumnPinning?: ColumnPinningState;\n\t\tcolumnSizing?: ColumnSizingState;\n\t\trowSelection?: RowSelectionState;\n\t};\n\tonDataChange?: (data: TData[]) => void;\n\tonRowAdd?: (event?: MouseEvent) => Partial<CellPosition> | void | Promise<Partial<CellPosition> | void>;\n\tonRowsAdd?: (count: number) => void | Promise<void>;\n\tonRowsDelete?: (rows: TData[], rowIndices: number[]) => void | Promise<void>;\n\tonPaste?: (updates: UpdateCell[]) => void | Promise<void>;\n\tonFilesUpload?: (params: {\n\t\tfiles: File[];\n\t\trowIndex: number;\n\t\tcolumnId: string;\n\t\trow: TData;\n\t}) => Promise<FileCellData[]>;\n\tonFilesDelete?: (params: {\n\t\tfileIds: string[];\n\t\trowIndex: number;\n\t\tcolumnId: string;\n\t\trow: TData;\n\t}) => void | Promise<void>;\n}\n\nexport interface UseDataGridReturn<TData extends RowData> {\n\t// Refs\n\tdataGridRef: HTMLDivElement | null;\n\theaderRef: HTMLDivElement | null;\n\trowMapRef: Map<number, HTMLDivElement>;\n\tfooterRef: HTMLDivElement | null;\n\n\t// Table instance\n\ttable: Table<TData>;\n\n\t// Virtualizer\n\trowVirtualizer: VirtualizerReturn;\n\n\t// Search state (if enabled)\n\tsearchState?: SearchState;\n\n\t// Column size CSS variables\n\tcolumnSizeVars: Record<string, number>;\n\n\t// Row add handler\n\tonRowAdd?: (event?: MouseEvent) => Promise<void>;\n\n\t// Setters for refs (for bind:this)\n\tsetDataGridRef: (el: HTMLDivElement | null) => void;\n\tsetHeaderRef: (el: HTMLDivElement | null) => void;\n\tsetFooterRef: (el: HTMLDivElement | null) => void;\n}\n\ninterface VirtualizerReturn {\n\t/** Use getter for reactive access in consuming components */\n\treadonly virtualItems: VirtualItem[];\n\t/** Use getter for reactive access in consuming components */\n\treadonly totalSize: number;\n\tscrollToIndex: (index: number, options?: { align?: 'start' | 'center' | 'end' | 'auto' }) => void;\n\tmeasureElement: (element: Element | null) => void;\n\treadonly isScrolling: boolean;\n\t/** Legacy method - prefer using virtualItems getter directly */\n\tgetVirtualItems: () => VirtualItem[];\n\t/** Legacy method - prefer using totalSize getter directly */\n\tgetTotalSize: () => number;\n}\n\ninterface VirtualItem {\n\tindex: number;\n\tkey: string | number | bigint;\n\tstart: number;\n\tend: number;\n\tsize: number;\n\tlane: number;\n}\n\n// ============================================\n// Non-navigable columns (skip during keyboard nav)\n// ============================================\n\nconst NON_NAVIGABLE_COLUMNS = new Set(['select', 'actions']);\n\n// ============================================\n// Main Hook\n// ============================================\n\nexport function useDataGrid<TData extends RowData>(\n\toptions: UseDataGridOptions<TData>\n): UseDataGridReturn<TData> {\n\t// IMPORTANT: We use a getter function for data to maintain reactivity\n\t// The caller passes data as a property, and we need to read it fresh each time\n\t// This allows the hook to react to data changes from onDataChange callbacks\n\tconst getData = () => options.data;\n\t\n\tconst {\n\t\tcolumns,\n\t\trowHeight: initialRowHeight = 'short',\n\t\tautoFocus = false,\n\t\tenableColumnSelection = false,\n\t\tenableSearch = true,\n\t\tenablePaste = true,\n\t\treadOnly = false,\n\t\toverscan = 3,\n\t\tgetRowId,\n\t\tinitialState,\n\t\tonDataChange,\n\t\tonRowAdd: onRowAddProp,\n\t\tonRowsAdd,\n\t\tonRowsDelete: onRowsDeleteProp,\n\t\tonPaste,\n\t\tonFilesUpload,\n\t\tonFilesDelete\n\t} = options;\n\n\t// ========================================\n\t// Reactive State using Svelte 5 runes\n\t// ========================================\n\n\t// Refs\n\tlet dataGridRef = $state<HTMLDivElement | null>(null);\n\tlet headerRef = $state<HTMLDivElement | null>(null);\n\tlet footerRef = $state<HTMLDivElement | null>(null);\n\tlet rowMapRef = $state(new Map<number, HTMLDivElement>());\n\tlet cellMapRef = $state(new Map<string, HTMLDivElement>());\n\n\t// Table state - use initialState if provided\n\tlet sorting = $state<SortingState>(initialState?.sorting ?? []);\n\tlet columnFilters = $state<ColumnFiltersState>(initialState?.columnFilters ?? []);\n\tlet rowSelection = $state<RowSelectionState>(initialState?.rowSelection ?? {});\n\tlet columnPinning = $state<ColumnPinningState>(initialState?.columnPinning ?? {});\n\tlet columnVisibility = $state<VisibilityState>(initialState?.columnVisibility ?? {});\n\tlet columnSizing = $state<ColumnSizingState>(initialState?.columnSizing ?? {});\n\tlet columnSizingInfo = $state<ColumnSizingInfoState>({\n\t\tstartOffset: null,\n\t\tstartSize: null,\n\t\tdeltaOffset: null,\n\t\tdeltaPercentage: null,\n\t\tisResizingColumn: false,\n\t\tcolumnSizingStart: []\n\t});\n\tlet rowHeight = $state<RowHeightValue>(initialRowHeight);\n\n\t// Cell state\n\tlet focusedCell = $state<CellPosition | null>(null);\n\tlet editingCell = $state<CellPosition | null>(null);\n\tlet selectionState = $state<SelectionState>({\n\t\tselectedCells: new Set(),\n\t\tselectionRange: null,\n\t\tisSelecting: false\n\t});\n\tlet cutCells = $state<Set<string>>(new Set());\n\t// Track the anchor cell for shift+arrow range selection\n\tlet selectionAnchor = $state<CellPosition | null>(null);\n\n\t// Context menu state\n\tlet contextMenu = $state<ContextMenuState>({\n\t\topen: false,\n\t\tx: 0,\n\t\ty: 0\n\t});\n\n\t// Paste dialog state\n\tlet pasteDialog = $state<PasteDialogState>({\n\t\topen: false,\n\t\trowsNeeded: 0,\n\t\tclipboardText: ''\n\t});\n\n\t// Search state\n\tlet searchOpen = $state(false);\n\tlet searchQuery = $state('');\n\tlet searchMatches = $state<CellPosition[]>([]);\n\tlet matchIndex = $state(0);\n\t\n\t// SvelteSet for O(1) reactive search match lookups\n\tlet searchMatchSet = new SvelteSet<string>();\n\t\n\t// Debug search state\n\t$inspect('useDataGrid search', { searchOpen, searchQuery, matchCount: searchMatches.length, matchIndex });\n\n\t// Track last clicked row for shift-click selection\n\tlet lastClickedRowIndex = $state<number | null>(null);\n\n\t// Virtualizer state\n\tlet virtualItems = $state<VirtualItem[]>([]);\n\tlet totalSize = $state(0);\n\tlet isScrolling = $state(false);\n\n\t// ========================================\n\t// Derived values (declared later after table is created)\n\t// ========================================\n\n\n\t// ========================================\n\t// Helper Functions\n\t// ========================================\n\n\tfunction getNavigableColumns() {\n\t\treturn table\n\t\t\t.getAllColumns()\n\t\t\t.filter((col) => col.getIsVisible() && !NON_NAVIGABLE_COLUMNS.has(col.id));\n\t}\n\n\tfunction getFirstNavigableColumnId(): string | null {\n\t\tconst cols = getNavigableColumns();\n\t\treturn cols[0]?.id ?? null;\n\t}\n\n\tfunction getLastNavigableColumnId(): string | null {\n\t\tconst cols = getNavigableColumns();\n\t\treturn cols[cols.length - 1]?.id ?? null;\n\t}\n\n\tfunction getNextNavigableColumnId(currentColumnId: string, direction: 'left' | 'right'): string | null {\n\t\tconst cols = getNavigableColumns();\n\t\tconst currentIndex = cols.findIndex((col) => col.id === currentColumnId);\n\t\tif (currentIndex === -1) return null;\n\n\t\tconst nextIndex = direction === 'right' ? currentIndex + 1 : currentIndex - 1;\n\t\treturn cols[nextIndex]?.id ?? null;\n\t}\n\n\tfunction getIsCellSelected(rowIndex: number, columnId: string): boolean {\n\t\treturn selectionState.selectedCells.has(getCellKey(rowIndex, columnId));\n\t}\n\n\tfunction getIsSearchMatch(rowIndex: number, columnId: string): boolean {\n\t\t// O(1) lookup using the derived Set instead of O(n) .some()\n\t\treturn searchMatchSet.has(getCellKey(rowIndex, columnId));\n\t}\n\n\tfunction getIsActiveSearchMatch(rowIndex: number, columnId: string): boolean {\n\t\tconst activeMatch = searchMatches[matchIndex];\n\t\treturn activeMatch?.rowIndex === rowIndex && activeMatch?.columnId === columnId;\n\t}\n\n\t// ========================================\n\t// Cell Focus & Navigation\n\t// ========================================\n\n\tfunction focusCell(rowIndex: number, columnId: string, opts?: { keepAnchor?: boolean }) {\n\t\tfocusedCell = { rowIndex, columnId };\n\n\t\tconst cellKey = getCellKey(rowIndex, columnId);\n\n\t\t// Clear selection when focusing new cell (unless holding shift or explicitly keeping anchor)\n\t\tif (!selectionState.isSelecting && !opts?.keepAnchor) {\n\t\t\tselectionState = {\n\t\t\t\tselectedCells: new Set([cellKey]),\n\t\t\t\tselectionRange: null,\n\t\t\t\tisSelecting: false\n\t\t\t};\n\t\t\t// Set anchor to the newly focused cell\n\t\t\tselectionAnchor = { rowIndex, columnId };\n\t\t}\n\n\t\t// Scroll to row if needed (for virtualization)\n\t\tif (virtualizer) {\n\t\t\tvirtualizer.scrollToIndex(rowIndex, { align: 'auto' });\n\t\t}\n\n\t\t// Focus the cell element - use multiple attempts to handle virtualization\n\t\tconst attemptFocus = (attempts = 0) => {\n\t\t\tconst cellElement = cellMapRef.get(cellKey);\n\t\t\tif (cellElement) {\n\t\t\t\tcellElement.scrollIntoView({ block: 'nearest', inline: 'nearest' });\n\t\t\t\tcellElement.focus();\n\t\t\t} else if (attempts < 3) {\n\t\t\t\t// Retry if cell not in DOM yet (virtualization)\n\t\t\t\trequestAnimationFrame(() => attemptFocus(attempts + 1));\n\t\t\t}\n\t\t};\n\n\t\t// Start first attempt immediately, then use RAF for subsequent attempts\n\t\trequestAnimationFrame(() => attemptFocus());\n\t}\n\n\tfunction blurCell() {\n\t\tfocusedCell = null;\n\t\teditingCell = null;\n\t}\n\n\tfunction navigateCell(direction: NavigationDirection) {\n\t\tif (!focusedCell) return;\n\n\t\tconst rows = table.getRowModel().rows;\n\t\tconst { rowIndex, columnId } = focusedCell;\n\n\t\tlet newRowIndex = rowIndex;\n\t\tlet newColumnId: string | null = columnId;\n\n\t\tswitch (direction) {\n\t\t\tcase 'up':\n\t\t\t\tnewRowIndex = Math.max(0, rowIndex - 1);\n\t\t\t\tbreak;\n\t\t\tcase 'down':\n\t\t\t\tnewRowIndex = Math.min(rows.length - 1, rowIndex + 1);\n\t\t\t\tbreak;\n\t\t\tcase 'left': {\n\t\t\t\tconst prevCol = getNextNavigableColumnId(columnId, 'left');\n\t\t\t\tif (prevCol) {\n\t\t\t\t\tnewColumnId = prevCol;\n\t\t\t\t} else if (rowIndex > 0) {\n\t\t\t\t\t// Wrap to end of previous row\n\t\t\t\t\tnewRowIndex = rowIndex - 1;\n\t\t\t\t\tnewColumnId = getLastNavigableColumnId();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'right': {\n\t\t\t\tconst nextCol = getNextNavigableColumnId(columnId, 'right');\n\t\t\t\tif (nextCol) {\n\t\t\t\t\tnewColumnId = nextCol;\n\t\t\t\t} else if (rowIndex < rows.length - 1) {\n\t\t\t\t\t// Wrap to beginning of next row\n\t\t\t\t\tnewRowIndex = rowIndex + 1;\n\t\t\t\t\tnewColumnId = getFirstNavigableColumnId();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase 'home':\n\t\t\t\tnewColumnId = getFirstNavigableColumnId();\n\t\t\t\tbreak;\n\t\t\tcase 'end':\n\t\t\t\tnewColumnId = getLastNavigableColumnId();\n\t\t\t\tbreak;\n\t\t\tcase 'ctrl+home':\n\t\t\t\tnewRowIndex = 0;\n\t\t\t\tnewColumnId = getFirstNavigableColumnId();\n\t\t\t\tbreak;\n\t\t\tcase 'ctrl+end':\n\t\t\t\tnewRowIndex = rows.length - 1;\n\t\t\t\tnewColumnId = getLastNavigableColumnId();\n\t\t\t\tbreak;\n\t\t\tcase 'pageup':\n\t\t\t\tnewRowIndex = Math.max(0, rowIndex - 10);\n\t\t\t\tbreak;\n\t\t\tcase 'pagedown':\n\t\t\t\tnewRowIndex = Math.min(rows.length - 1, rowIndex + 10);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (newColumnId && (newRowIndex !== rowIndex || newColumnId !== columnId)) {\n\t\t\tfocusCell(newRowIndex, newColumnId);\n\t\t}\n\t}\n\n\t// ========================================\n\t// Cell Editing\n\t// ========================================\n\n\tfunction startEditing(rowIndex: number, columnId: string) {\n\t\tif (readOnly) return;\n\t\teditingCell = { rowIndex, columnId };\n\t}\n\n\tfunction stopEditing(opts?: { direction?: NavigationDirection; moveToNextRow?: boolean }) {\n\t\teditingCell = null;\n\n\t\tif (opts?.direction) {\n\t\t\tnavigateCell(opts.direction);\n\t\t} else if (opts?.moveToNextRow && focusedCell) {\n\t\t\tnavigateCell('down');\n\t\t}\n\t}\n\n\t// ========================================\n\t// Cell Selection\n\t// ========================================\n\n\tfunction selectCell(rowIndex: number, columnId: string, event?: MouseEvent) {\n\t\tconst cellKey = getCellKey(rowIndex, columnId);\n\n\t\tif (event?.ctrlKey || event?.metaKey) {\n\t\t\t// Toggle selection\n\t\t\tconst newSelected = new Set(selectionState.selectedCells);\n\t\t\tif (newSelected.has(cellKey)) {\n\t\t\t\tnewSelected.delete(cellKey);\n\t\t\t} else {\n\t\t\t\tnewSelected.add(cellKey);\n\t\t\t}\n\t\t\tselectionState = {\n\t\t\t\t...selectionState,\n\t\t\t\tselectedCells: newSelected\n\t\t\t};\n\t\t} else if (event?.shiftKey && focusedCell) {\n\t\t\t// Range selection\n\t\t\tselectRange(focusedCell, { rowIndex, columnId });\n\t\t} else {\n\t\t\t// Single selection\n\t\t\tselectionState = {\n\t\t\t\tselectedCells: new Set([cellKey]),\n\t\t\t\tselectionRange: null,\n\t\t\t\tisSelecting: false\n\t\t\t};\n\t\t}\n\n\t\tfocusCell(rowIndex, columnId);\n\t}\n\n\tfunction selectRange(start: CellPosition, end: CellPosition, keepSelecting = false) {\n\t\tconst cols = getNavigableColumns();\n\t\tconst startColIndex = cols.findIndex((c) => c.id === start.columnId);\n\t\tconst endColIndex = cols.findIndex((c) => c.id === end.columnId);\n\n\t\tconst minRow = Math.min(start.rowIndex, end.rowIndex);\n\t\tconst maxRow = Math.max(start.rowIndex, end.rowIndex);\n\t\tconst minCol = Math.min(startColIndex, endColIndex);\n\t\tconst maxCol = Math.max(startColIndex, endColIndex);\n\n\t\tconst newSelected = new Set<string>();\n\t\tfor (let row = minRow; row <= maxRow; row++) {\n\t\t\tfor (let col = minCol; col <= maxCol; col++) {\n\t\t\t\tconst colId = cols[col]?.id;\n\t\t\t\tif (colId) {\n\t\t\t\t\tnewSelected.add(getCellKey(row, colId));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tselectionState = {\n\t\t\tselectedCells: newSelected,\n\t\t\tselectionRange: { start, end },\n\t\t\tisSelecting: keepSelecting ? selectionState.isSelecting : false\n\t\t};\n\t}\n\n\tfunction selectAll() {\n\t\tconst rows = table.getRowModel().rows;\n\t\tconst cols = getNavigableColumns();\n\t\tconst newSelected = new Set<string>();\n\n\t\tfor (let row = 0; row < rows.length; row++) {\n\t\t\tfor (const col of cols) {\n\t\t\t\tnewSelected.add(getCellKey(row, col.id));\n\t\t\t}\n\t\t}\n\n\t\tselectionState = {\n\t\t\tselectedCells: newSelected,\n\t\t\tselectionRange: null,\n\t\t\tisSelecting: false\n\t\t};\n\t}\n\n\tfunction clearSelection() {\n\t\tselectionState = {\n\t\t\tselectedCells: new Set(),\n\t\t\tselectionRange: null,\n\t\t\tisSelecting: false\n\t\t};\n\t\tblurCell();\n\t}\n\n\t// ========================================\n\t// Mouse Selection (Drag)\n\t// ========================================\n\n\tfunction onCellMouseDown(rowIndex: number, columnId: string, event: MouseEvent) {\n\t\tif (event.button !== 0) return; // Only left click\n\n\t\t// Set selection anchor for drag selection\n\t\tconst cellKey = getCellKey(rowIndex, columnId);\n\t\t\n\t\tif (event.ctrlKey || event.metaKey) {\n\t\t\t// Toggle selection - don't start drag, keep anchor\n\t\t\tconst newSelected = new Set(selectionState.selectedCells);\n\t\t\tif (newSelected.has(cellKey)) {\n\t\t\t\tnewSelected.delete(cellKey);\n\t\t\t} else {\n\t\t\t\tnewSelected.add(cellKey);\n\t\t\t}\n\t\t\tselectionState = {\n\t\t\t\t...selectionState,\n\t\t\t\tselectedCells: newSelected,\n\t\t\t\tisSelecting: false\n\t\t\t};\n\t\t\t// Update focused cell but keep anchor for future shift-clicks\n\t\t\tfocusedCell = { rowIndex, columnId };\n\t\t\tscrollAndFocusCell(rowIndex, columnId);\n\t\t} else if (event.shiftKey && (selectionAnchor || focusedCell)) {\n\t\t\t// Range selection from anchor (or focused cell if no anchor) to this cell\n\t\t\tconst anchor = selectionAnchor || focusedCell!;\n\t\t\tselectRange(anchor, { rowIndex, columnId });\n\t\t\tselectionState = { ...selectionState, isSelecting: false };\n\t\t\t// Update focused cell but keep anchor for future shift-clicks\n\t\t\tfocusedCell = { rowIndex, columnId };\n\t\t\tscrollAndFocusCell(rowIndex, columnId);\n\t\t} else {\n\t\t\t// Start drag selection - set this cell as anchor\n\t\t\tselectionState = {\n\t\t\t\tselectedCells: new Set([cellKey]),\n\t\t\t\tselectionRange: null,\n\t\t\t\tisSelecting: true\n\t\t\t};\n\t\t\tselectionAnchor = { rowIndex, columnId };\n\t\t\tfocusCell(rowIndex, columnId);\n\t\t}\n\t}\n\t\n\t// Helper to scroll to cell and focus it without changing selection anchor\n\tfunction scrollAndFocusCell(rowIndex: number, columnId: string) {\n\t\tconst cellKey = getCellKey(rowIndex, columnId);\n\t\t\n\t\t// Scroll to row if needed (for virtualization)\n\t\tif (virtualizer) {\n\t\t\tvirtualizer.scrollToIndex(rowIndex, { align: 'auto' });\n\t\t}\n\n\t\t// Focus the cell element\n\t\trequestAnimationFrame(() => {\n\t\t\tconst cellElement = cellMapRef.get(cellKey);\n\t\t\tif (cellElement) {\n\t\t\t\tcellElement.scrollIntoView({ block: 'nearest', inline: 'nearest' });\n\t\t\t\tcellElement.focus();\n\t\t\t}\n\t\t});\n\t}\n\n\tfunction onCellMouseEnter(rowIndex: number, columnId: string, event: MouseEvent) {\n\t\tif (!selectionState.isSelecting || !selectionAnchor) return;\n\n\t\t// Extend selection from anchor to current cell, keeping isSelecting true\n\t\tselectRange(selectionAnchor, { rowIndex, columnId }, true);\n\t}\n\n\tfunction onCellMouseUp() {\n\t\tselectionState = { ...selectionState, isSelecting: false };\n\t}\n\n\t// ========================================\n\t// Clipboard Operations\n\t// ========================================\n\n\tfunction copySelectedCells() {\n\t\tif (selectionState.selectedCells.size === 0) return;\n\n\t\tconst rows = table.getRowModel().rows;\n\t\tconst cols = getNavigableColumns();\n\n\t\t// Get bounds of selection\n\t\tlet minRow = Infinity,\n\t\t\tmaxRow = -Infinity;\n\t\tlet minCol = Infinity,\n\t\t\tmaxCol = -Infinity;\n\n\t\tfor (const cellKey of selectionState.selectedCells) {\n\t\t\tconst { rowIndex, columnId } = parseCellKey(cellKey);\n\t\t\tconst colIndex = cols.findIndex((c) => c.id === columnId);\n\t\t\tif (colIndex >= 0) {\n\t\t\t\tminRow = Math.min(minRow, rowIndex);\n\t\t\t\tmaxRow = Math.max(maxRow, rowIndex);\n\t\t\t\tminCol = Math.min(minCol, colIndex);\n\t\t\t\tmaxCol = Math.max(maxCol, colIndex);\n\t\t\t}\n\t\t}\n\n\t\t// Build TSV string\n\t\tconst lines: string[] = [];\n\t\tfor (let row = minRow; row <= maxRow; row++) {\n\t\t\tconst rowData = rows[row];\n\t\t\tif (!rowData) continue;\n\n\t\t\tconst cells: string[] = [];\n\t\t\tfor (let col = minCol; col <= maxCol; col++) {\n\t\t\t\tconst colId = cols[col]?.id;\n\t\t\t\tif (!colId) continue;\n\n\t\t\t\tconst cellKey = getCellKey(row, colId);\n\t\t\t\tif (selectionState.selectedCells.has(cellKey)) {\n\t\t\t\t\tconst value = rowData.getValue(colId);\n\t\t\t\t\tcells.push(formatCellValueForCopy(value));\n\t\t\t\t} else {\n\t\t\t\t\tcells.push('');\n\t\t\t\t}\n\t\t\t}\n\t\t\tlines.push(cells.join('\\t'));\n\t\t}\n\n\t\tconst text = lines.join('\\n');\n\t\tnavigator.clipboard.writeText(text).then(() => {\n\t\t\tconst cellCount = selectionState.selectedCells.size;\n\t\t\ttoast.success(`${cellCount} cell${cellCount !== 1 ? 's' : ''} copied`);\n\t\t}).catch((error) => {\n\t\t\ttoast.error(error instanceof Error ? error.message : 'Failed to copy to clipboard');\n\t\t});\n\t}\n\n\tfunction cutSelectedCells() {\n\t\tif (readOnly) return;\n\n\t\tconst cellCount = selectionState.selectedCells.size;\n\t\tcopySelectedCells();\n\t\tcutCells = new Set(selectionState.selectedCells);\n\t\t// Note: Toast for cut is handled separately since copy already shows success\n\t}\n\n\tasync function pasteFromClipboard() {\n\t\tif (readOnly || !enablePaste) return;\n\n\t\ttry {\n\t\t\tconst text = await navigator.clipboard.readText();\n\t\t\tif (!text.trim()) return;\n\n\t\t\tconst rows = table.getRowModel().rows;\n\t\t\tconst cols = getNavigableColumns();\n\n\t\t\t// Parse clipboard as TSV\n\t\t\tconst lines = text.split('\\n').map((line) => line.split('\\t'));\n\n\t\t\t// Determine paste target\n\t\t\tconst startPos = focusedCell || { rowIndex: 0, columnId: cols[0]?.id || '' };\n\t\t\tconst startColIndex = cols.findIndex((c) => c.id === startPos.columnId);\n\n\t\t\t// Check if we need more rows\n\t\t\tconst rowsNeeded = startPos.rowIndex + lines.length - rows.length;\n\n\t\t\tif (rowsNeeded > 0 && onRowsAdd) {\n\t\t\t\tpasteDialog = {\n\t\t\t\t\topen: true,\n\t\t\t\t\trowsNeeded,\n\t\t\t\t\tclipboardText: text\n\t\t\t\t};\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Perform paste\n\t\t\tperformPaste(text, startPos, startColIndex);\n\t\t} catch {\n\t\t\t// Clipboard access denied\n\t\t}\n\t}\n\n\tfunction performPaste(text: string, startPos: CellPosition, startColIndex: number) {\n\t\tconst rows = table.getRowModel().rows;\n\t\tconst cols = getNavigableColumns();\n\t\tconst lines = text.split('\\n').map((line) => line.split('\\t'));\n\n\t\tconst updates: UpdateCell[] = [];\n\n\t\tfor (let lineIdx = 0; lineIdx < lines.length; lineIdx++) {\n\t\t\tconst line = lines[lineIdx];\n\t\t\tif (!line) continue;\n\n\t\t\tconst rowIndex = startPos.rowIndex + lineIdx;\n\t\t\tif (rowIndex >= rows.length) break;\n\n\t\t\tfor (let cellIdx = 0; cellIdx < line.length; cellIdx++) {\n\t\t\t\tconst colIndex = startColIndex + cellIdx;\n\t\t\t\tconst col = cols[colIndex];\n\t\t\t\tif (!col) break;\n\n\t\t\t\tconst value = parseCellValueForPaste(line[cellIdx] || '', col.id);\n\t\t\t\tupdates.push({ rowIndex, columnId: col.id, value });\n\t\t\t}\n\t\t}\n\n\t\tif (updates.length > 0) {\n\t\t\t// Clear cut cells first if we had any (to merge all updates together)\n\t\t\tif (cutCells.size > 0) {\n\t\t\t\tfor (const cellKey of cutCells) {\n\t\t\t\t\tconst { rowIndex, columnId } = parseCellKey(cellKey);\n\t\t\t\t\tupdates.push({ rowIndex, columnId, value: null });\n\t\t\t\t}\n\t\t\t\tcutCells = new Set();\n\t\t\t}\n\n\t\t\thandleDataUpdate(updates);\n\t\t\tonPaste?.(updates);\n\t\t\t\n\t\t\ttoast.success(`${updates.length} cell${updates.length !== 1 ? 's' : ''} pasted`);\n\t\t}\n\t}\n\n\tfunction formatCellValueForCopy(value: unknown): string {\n\t\tif (value === null || value === undefined) return '';\n\t\tif (Array.isArray(value)) return JSON.stringify(value);\n\t\treturn String(value);\n\t}\n\n\tfunction parseCellValueForPaste(text: string, _columnId: string): unknown {\n\t\t// Try to parse as JSON (for arrays)\n\t\tif (text.startsWith('[') || text.startsWith('{')) {\n\t\t\ttry {\n\t\t\t\treturn JSON.parse(text);\n\t\t\t} catch {\n\t\t\t\t// Not valid JSON\n\t\t\t}\n\t\t}\n\n\t\t// Try to parse as number\n\t\tconst num = Number(text);\n\t\tif (!isNaN(num) && text.trim() !== '') {\n\t\t\treturn num;\n\t\t}\n\n\t\t// Try to parse as boolean\n\t\tif (text.toLowerCase() === 'true') return true;\n\t\tif (text.toLowerCase() === 'false') return false;\n\n\t\treturn text;\n\t}\n\n\t// ========================================\n\t// Delete/Clear Operations\n\t// ========================================\n\n\tfunction clearSelectedCells() {\n\t\tif (readOnly) return;\n\n\t\tconst updates: UpdateCell[] = [];\n\t\tfor (const cellKey of selectionState.selectedCells) {\n\t\t\tconst { rowIndex, columnId } = parseCellKey(cellKey);\n\t\t\tupdates.push({ rowIndex, columnId, value: null });\n\t\t}\n\n\t\tif (updates.length > 0) {\n\t\t\thandleDataUpdate(updates);\n\t\t}\n\t}\n\n\tfunction deleteSelectedRows() {\n\t\tif (readOnly || !onRowsDeleteProp) return;\n\n\t\tconst rows = table.getRowModel().rows;\n\t\tconst selectedRowIndices = new Set<number>();\n\n\t\tfor (const cellKey of selectionState.selectedCells) {\n\t\t\tconst { rowIndex } = parseCellKey(cellKey);\n\t\t\tselectedRowIndices.add(rowIndex);\n\t\t}\n\n\t\tconst rowIndices = Array.from(selectedRowIndices).sort((a, b) => b - a);\n\t\tconst rowsToDelete = rowIndices.map((idx) => rows[idx]?.original).filter(Boolean) as TData[];\n\n\t\tif (rowsToDelete.length > 0) {\n\t\t\tonRowsDeleteProp(rowsToDelete, rowIndices);\n\t\t\tclearSelection();\n\t\t}\n\t}\n\n\t// ========================================\n\t// Search\n\t// ========================================\n\n\tfunction performSearch(query: string) {\n\t\tif (!query.trim()) {\n\t\t\tsearchMatches = [];\n\t\t\tsearchMatchSet.clear();\n\t\t\tmatchIndex = 0;\n\t\t\treturn;\n\t\t}\n\n\t\tconst rows = table.getRowModel().rows;\n\t\tconst cols = getNavigableColumns();\n\t\tconst matches: CellPosition[] = [];\n\t\tconst lowerQuery = query.toLowerCase();\n\t\t\n\t\t// Clear set before building - we'll add during the same loop\n\t\tsearchMatchSet.clear();\n\n\t\tfor (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {\n\t\t\tconst row = rows[rowIndex];\n\t\t\tif (!row) continue;\n\n\t\t\tfor (const col of cols) {\n\t\t\t\tconst value = row.getValue(col.id);\n\t\t\t\tconst strValue = String(value ?? '').toLowerCase();\n\t\t\t\tif (strValue.includes(lowerQuery)) {\n\t\t\t\t\tconst columnId = col.id;\n\t\t\t\t\tmatches.push({ rowIndex, columnId });\n\t\t\t\t\t// Build Set in same loop - single pass\n\t\t\t\t\tsearchMatchSet.add(getCellKey(rowIndex, columnId));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsearchMatches = matches;\n\t\tmatchIndex = matches.length > 0 ? 0 : 0;\n\n\t\t// Scroll to first match (like React version - just scroll, don't focus)\n\t\tif (matches.length > 0 && matches[0]) {\n\t\t\tvirtualizer?.scrollToIndex(matches[0].rowIndex, { align: 'center' });\n\t\t}\n\t}\n\n\tfunction navigateToNextMatch() {\n\t\tif (searchMatches.length === 0) return;\n\n\t\tconst newIndex = (matchIndex + 1) % searchMatches.length;\n\t\tmatchIndex = newIndex;\n\n\t\tconst match = searchMatches[newIndex];\n\t\tif (match) {\n\t\t\tvirtualizer?.scrollToIndex(match.rowIndex, { align: 'center' });\n\t\t}\n\t}\n\n\tfunction navigateToPrevMatch() {\n\t\tif (searchMatches.length === 0) return;\n\n\t\tconst newIndex = (matchIndex - 1 + searchMatches.length) % searchMatches.length;\n\t\tmatchIndex = newIndex;\n\n\t\tconst match = searchMatches[newIndex];\n\t\tif (match) {\n\t\t\tvirtualizer?.scrollToIndex(match.rowIndex, { align: 'center' });\n\t\t}\n\t}\n\n\t// ========================================\n\t// Context Menu\n\t// ========================================\n\n\tfunction onCellContextMenu(rowIndex: number, columnId: string, event: MouseEvent) {\n\t\tevent.preventDefault();\n\n\t\t// Select cell if not already selected\n\t\tconst cellKey = getCellKey(rowIndex, columnId);\n\t\tif (!selectionState.selectedCells.has(cellKey)) {\n\t\t\tselectCell(rowIndex, columnId);\n\t\t}\n\n\t\tcontextMenu = {\n\t\t\topen: true,\n\t\t\tx: event.clientX,\n\t\t\ty: event.clientY\n\t\t};\n\t}\n\n\t// ========================================\n\t// Keyboard Handler\n\t// ========================================\n\n\tfunction handleKeyDown(event: KeyboardEvent) {\n\t\t// Search shortcut\n\t\tif ((event.ctrlKey || event.metaKey) && event.key === 'f' && enableSearch) {\n\t\t\tevent.preventDefault();\n\t\t\tevent.stopPropagation();\n\t\t\tsearchOpen = !searchOpen;\n\t\t\treturn;\n\t\t}\n\n\t\t// Copy\n\t\tif ((event.ctrlKey || event.metaKey) && event.key === 'c') {\n\t\t\tevent.preventDefault();\n\t\t\tevent.stopPropagation();\n\t\t\tcopySelectedCells();\n\t\t\treturn;\n\t\t}\n\n\t\t// Cut\n\t\tif ((event.ctrlKey || event.metaKey) && event.key === 'x') {\n\t\t\tevent.preventDefault();\n\t\t\tevent.stopPropagation();\n\t\t\tcutSelectedCells();\n\t\t\treturn;\n\t\t}\n\n\t\t// Paste\n\t\tif ((event.ctrlKey || event.metaKey) && event.key === 'v') {\n\t\t\tevent.preventDefault();\n\t\t\tevent.stopPropagation();\n\t\t\tpasteFromClipboard();\n\t\t\treturn;\n\t\t}\n\n\t\t// Select all\n\t\tif ((event.ctrlKey || event.metaKey) && event.key === 'a') {\n\t\t\tevent.preventDefault();\n\t\t\tevent.stopPropagation();\n\t\t\tselectAll();\n\t\t\treturn;\n\t\t}\n\n\t\t// Delete/Backspace\n\t\tif (event.key === 'Delete' || event.key === 'Backspace') {\n\t\t\tif (!editingCell) {\n\t\t\t\tevent.preventDefault();\n\t\t\t\tevent.stopPropagation();\n\t\t\t\tclearSelectedCells();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Escape\n\t\tif (event.key === 'Escape') {\n\t\t\tevent.preventDefault();\n\t\t\tevent.stopPropagation();\n\t\t\tif (editingCell) {\n\t\t\t\tstopEditing();\n\t\t\t} else if (searchOpen) {\n\t\t\t\tsearchOpen = false;\n\t\t\t} else {\n\t\t\t\tclearSelection();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// Don't handle navigation while editing\n\t\tif (editingCell) return;\n\n\t\t// Navigation\n\t\tconst navigationMap: Record<string, NavigationDirection> = {\n\t\t\tArrowUp: 'up',\n\t\t\tArrowDown: 'down',\n\t\t\tArrowLeft: 'left',\n\t\t\tArrowRight: 'right',\n\t\t\tHome: event.ctrlKey || event.metaKey ? 'ctrl+home' : 'home',\n\t\t\tEnd: event.ctrlKey || event.metaKey ? 'ctrl+end' : 'end',\n\t\t\tPageUp: 'pageup',\n\t\t\tPageDown: 'pagedown'\n\t\t};\n\n\t\tconst direction = navigationMap[event.key];\n\t\tif (direction) {\n\t\t\tevent.preventDefault();\n\t\t\tevent.stopPropagation();\n\n\t\t\tif (event.shiftKey && focusedCell) {\n\t\t\t\t// Extend selection from anchor\n\t\t\t\tconst anchor = selectionAnchor || focusedCell;\n\t\t\t\tconst newPos = getNavigationTarget(direction);\n\t\t\t\tif (newPos) {\n\t\t\t\t\t// Select range from anchor to new position\n\t\t\t\t\tselectRange(anchor, newPos);\n\t\t\t\t\t// Update focused cell position to the new position for continued shift-selection\n\t\t\t\t\tfocusedCell = newPos;\n\n\t\t\t\t\t// Scroll to the new position\n\t\t\t\t\tif (virtualizer) {\n\t\t\t\t\t\tvirtualizer.scrollToIndex(newPos.rowIndex, { align: 'auto' });\n\t\t\t\t\t}\n\n\t\t\t\t\t// Focus the cell element\n\t\t\t\t\trequestAnimationFrame(() => {\n\t\t\t\t\t\tconst cellKey = getCellKey(newPos.rowIndex, newPos.columnId);\n\t\t\t\t\t\tconst cellElement = cellMapRef.get(cellKey);\n\t\t\t\t\t\tif (cellElement) {\n\t\t\t\t\t\t\tcellElement.scrollIntoView({ block: 'nearest', inline: 'nearest' });\n\t\t\t\t\t\t\tcellElement.focus();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnavigateCell(direction);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// Tab navigation\n\t\tif (event.key === 'Tab') {\n\t\t\tevent.preventDefault();\n\t\t\tevent.stopPropagation();\n\t\t\tnavigateCell(event.shiftKey ? 'left' : 'right');\n\t\t\treturn;\n\t\t}\n\n\t\t// Enter to start editing or move down\n\t\tif (event.key === 'Enter' && focusedCell) {\n\t\t\tevent.preventDefault();\n\t\t\tevent.stopPropagation();\n\t\t\tstartEditing(focusedCell.rowIndex, focusedCell.columnId);\n\t\t\treturn;\n\t\t}\n\n\t\t// F2 to start editing\n\t\tif (event.key === 'F2' && focusedCell) {\n\t\t\tevent.preventDefault();\n\t\t\tevent.stopPropagation();\n\t\t\tstartEditing(focusedCell.rowIndex, focusedCell.columnId);\n\t\t\treturn;\n\t\t}\n\n\t\t// Typing starts editing\n\t\tif (\n\t\t\tfocusedCell &&\n\t\t\t!readOnly &&\n\t\t\tevent.key.length === 1 &&\n\t\t\t!event.ctrlKey &&\n\t\t\t!event.metaKey\n\t\t) {\n\t\t\tstartEditing(focusedCell.rowIndex, focusedCell.columnId);\n\t\t}\n\t}\n\n\tfunction getNavigationTarget(direction: NavigationDirection): CellPosition | null {\n\t\tif (!focusedCell) return null;\n\n\t\tconst rows = table.getRowModel().rows;\n\t\tconst { rowIndex, columnId } = focusedCell;\n\n\t\tlet newRowIndex = rowIndex;\n\t\tlet newColumnId: string | null = columnId;\n\n\t\tswitch (direction) {\n\t\t\tcase 'up':\n\t\t\t\tnewRowIndex = Math.max(0, rowIndex - 1);\n\t\t\t\tbreak;\n\t\t\tcase 'down':\n\t\t\t\tnewRowIndex = Math.min(rows.length - 1, rowIndex + 1);\n\t\t\t\tbreak;\n\t\t\tcase 'left':\n\t\t\t\tnewColumnId = getNextNavigableColumnId(columnId, 'left');\n\t\t\t\tbreak;\n\t\t\tcase 'right':\n\t\t\t\tnewColumnId = getNextNavigableColumnId(columnId, 'right');\n\t\t\t\tbreak;\n\t\t\tcase 'home':\n\t\t\t\tnewColumnId = getFirstNavigableColumnId();\n\t\t\t\tbreak;\n\t\t\tcase 'end':\n\t\t\t\tnewColumnId = getLastNavigableColumnId();\n\t\t\t\tbreak;\n\t\t\tcase 'ctrl+home':\n\t\t\t\tnewRowIndex = 0;\n\t\t\t\tnewColumnId = getFirstNavigableColumnId();\n\t\t\t\tbreak;\n\t\t\tcase 'ctrl+end':\n\t\t\t\tnewRowIndex = rows.length - 1;\n\t\t\t\tnewColumnId = getLastNavigableColumnId();\n\t\t\t\tbreak;\n\t\t\tcase 'pageup':\n\t\t\t\tnewRowIndex = Math.max(0, rowIndex - 10);\n\t\t\t\tbreak;\n\t\t\tcase 'pagedown':\n\t\t\t\tnewRowIndex = Math.min(rows.length - 1, rowIndex + 10);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (newColumnId) {\n\t\t\treturn { rowIndex: newRowIndex, columnId: newColumnId };\n\t\t}\n\t\treturn null;\n\t}\n\n\t// ========================================\n\t// Row Add Handler\n\t// ========================================\n\n\tasync function handleRowAdd(event?: MouseEvent) {\n\t\tif (!onRowAddProp) return;\n\n\t\tconst result = await onRowAddProp(event);\n\t\tif (result) {\n\t\t\tconst rows = table.getRowModel().rows;\n\t\t\tconst newRowIndex = result.rowIndex ?? rows.length;\n\t\t\tconst newColumnId = result.columnId ?? getFirstNavigableColumnId();\n\n\t\t\tif (newColumnId) {\n\t\t\t\t// Wait for table to update\n\t\t\t\tqueueMicrotask(() => {\n\t\t\t\t\tfocusCell(newRowIndex, newColumnId);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\t// ========================================\n\t// Data Update Handler\n\t// ========================================\n\n\tfunction handleDataUpdate(updates: UpdateCell | UpdateCell[]) {\n\t\tif (readOnly) return;\n\n\t\tconst updateArray = Array.isArray(updates) ? updates : [updates];\n\t\tif (updateArray.length === 0) return;\n\n\t\tconst rows = table.getRowModel().rows;\n\n\t\t// Group updates by row\n\t\tconst rowUpdatesMap = new Map<number, Array<{ columnId: string; value: unknown }>>();\n\n\t\tfor (const update of updateArray) {\n\t\t\tconst row = rows[update.rowIndex];\n\t\t\tif (!row) continue;\n\n\t\t\tconst originalData = row.original;\n\t\t\tconst originalRowIndex = getData().indexOf(originalData);\n\t\t\tconst targetIndex = originalRowIndex !== -1 ? originalRowIndex : update.rowIndex;\n\n\t\t\tconst existingUpdates = rowUpdatesMap.get(targetIndex) ?? [];\n\t\t\texistingUpdates.push({ columnId: update.columnId, value: update.value });\n\t\t\trowUpdatesMap.set(targetIndex, existingUpdates);\n\t\t}\n\n\t\t// Build new data array\n\t\tconst tableRowCount = rows?.length ?? getData().length;\n\t\tconst newData: TData[] = [];\n\n\t\tfor (let i = 0; i < tableRowCount; i++) {\n\t\t\tconst rowUpdates = rowUpdatesMap.get(i);\n\t\t\tconst existingRow = getData()[i];\n\t\t\tconst tableRow = rows?.[i];\n\n\t\t\tif (rowUpdates) {\n\t\t\t\tconst baseRow = (existingRow ?? tableRow?.original ?? {}) as Record<string, unknown>;\n\t\t\t\tconst updatedRow = { ...baseRow };\n\t\t\t\tfor (const { columnId, value } of rowUpdates) {\n\t\t\t\t\tupdatedRow[columnId] = value;\n\t\t\t\t}\n\t\t\t\tnewData.push(updatedRow as TData);\n\t\t\t} else {\n\t\t\t\tnewData.push(existingRow ?? tableRow?.original ?? ({} as TData));\n\t\t\t}\n\t\t}\n\n\t\tonDataChange?.(newData);\n\t}\n\n\t// ========================================\n\t// Create TanStack Table\n\t// ========================================\n\n\t// Initialize column sizing state from column definitions (only if not provided in initialState)\n\t$effect.pre(() => {\n\t\tif (Object.keys(columnSizing).length === 0) {\n\t\t\tconst sizing: Record<string, number> = {};\n\t\t\tfor (const col of columns) {\n\t\t\t\tif (col.size) {\n\t\t\t\t\tsizing[col.id as string] = col.size;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (Object.keys(sizing).length > 0) {\n\t\t\t\tcolumnSizing = sizing;\n\t\t\t}\n\t\t}\n\t});\n\n\t// Create a reactive meta object using getters so that components always get fresh values\n\t// This is critical - without getters, the meta values are captured at creation time and never update\n\tconst meta = {\n\t\tget dataGridRef() {\n\t\t\treturn dataGridRef;\n\t\t},\n\t\tget cellMapRef() {\n\t\t\treturn cellMapRef;\n\t\t},\n\t\tget focusedCell() {\n\t\t\treturn focusedCell;\n\t\t},\n\t\tget editingCell() {\n\t\t\treturn editingCell;\n\t\t},\n\t\tget selectionState() {\n\t\t\treturn selectionState;\n\t\t},\n\t\tget searchOpen() {\n\t\t\treturn searchOpen;\n\t\t},\n\t\tget readOnly() {\n\t\t\treturn readOnly;\n\t\t},\n\t\tget rowHeight() {\n\t\t\treturn rowHeight;\n\t\t},\n\t\tget contextMenu() {\n\t\t\treturn contextMenu;\n\t\t},\n\t\tget pasteDialog() {\n\t\t\treturn pasteDialog;\n\t\t},\n\t\tgetIsCellSelected,\n\t\t// Expose SvelteSet directly for fine-grained reactivity\n\t\t// Cells can call searchMatchSet.has(key) directly in template\n\t\tsearchMatchSet,\n\t\tget activeSearchMatch() {\n\t\t\treturn searchMatches[matchIndex] ?? null;\n\t\t},\n\t\t// Keep functions for backwards compatibility\n\t\tgetIsSearchMatch,\n\t\tgetIsActiveSearchMatch,\n\t\tonRowHeightChange: (value: RowHeightValue) => {\n\t\t\trowHeight = value;\n\t\t},\n\t\tonCellClick: selectCell,\n\t\tonCellDoubleClick: (ri: number, colId: string) => startEditing(ri, colId),\n\t\tonCellMouseDown,\n\t\tonCellMouseEnter,\n\t\tonCellMouseUp,\n\t\tonCellContextMenu,\n\t\tonCellEditingStart: startEditing,\n\t\tonCellEditingStop: stopEditing,\n\t\tonDataUpdate: handleDataUpdate,\n\t\tonRowsDelete: (rowIndices: number[]) => {\n\t\t\tconst rows = table.getRowModel().rows;\n\t\t\tconst rowsToDelete = rowIndices.map((idx) => rows[idx]?.original).filter(Boolean) as TData[];\n\t\t\tonRowsDeleteProp?.(rowsToDelete, rowIndices);\n\t\t},\n\t\tonCellsCopy: copySelectedCells,\n\t\tonCellsCut: cutSelectedCells,\n\t\tonFilesUpload,\n\t\tonFilesDelete,\n\t\tonRowSelect: (rowIndex: number, selected: boolean, shiftKey: boolean) => {\n\t\t\tconst rows = table.getRowModel().rows;\n\t\t\tconst currentRow = rows[rowIndex];\n\t\t\tif (!currentRow) return;\n\n\t\t\tif (shiftKey && lastClickedRowIndex !== null) {\n\t\t\t\t// Shift-click range selection\n\t\t\t\tconst startIndex = Math.min(lastClickedRowIndex, rowIndex);\n\t\t\t\tconst endIndex = Math.max(lastClickedRowIndex, rowIndex);\n\n\t\t\t\tconst newRowSelection = { ...rowSelection };\n\t\t\t\tfor (let i = startIndex; i <= endIndex; i++) {\n\t\t\t\t\tconst row = rows[i];\n\t\t\t\t\tif (row) {\n\t\t\t\t\t\tnewRowSelection[row.id] = selected;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trowSelection = newRowSelection;\n\t\t\t} else {\n\t\t\t\t// Regular click\n\t\t\t\trowSelection = {\n\t\t\t\t\t...rowSelection,\n\t\t\t\t\t[currentRow.id]: selected\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tlastClickedRowIndex = rowIndex;\n\t\t},\n\t\tonContextMenuOpenChange: (open: boolean) => {\n\t\t\tcontextMenu = { ...contextMenu, open };\n\t\t},\n\t\tonPasteDialogOpenChange: (open: boolean) => {\n\t\t\tpasteDialog = { ...pasteDialog, open };\n\t\t},\n\t\tonPasteWithExpansion: async () => {\n\t\t\tif (onRowsAdd) {\n\t\t\t\tawait onRowsAdd(pasteDialog.rowsNeeded);\n\t\t\t\tconst cols = getNavigableColumns();\n\t\t\t\tconst startPos = focusedCell || { rowIndex: 0, columnId: cols[0]?.id || '' };\n\t\t\t\tconst startColIndex = cols.findIndex((c) => c.id === startPos.columnId);\n\t\t\t\tperformPaste(pasteDialog.clipboardText, startPos, startColIndex);\n\t\t\t}\n\t\t\tpasteDialog = { ...pasteDialog, open: false };\n\t\t},\n\t\tonPasteWithoutExpansion: () => {\n\t\t\tconst cols = getNavigableColumns();\n\t\t\tconst startPos = focusedCell || { rowIndex: 0, columnId: cols[0]?.id || '' };\n\t\t\tconst startColIndex = cols.findIndex((c) => c.id === startPos.columnId);\n\t\t\tperformPaste(pasteDialog.clipboardText, startPos, startColIndex);\n\t\t\tpasteDialog = { ...pasteDialog, open: false };\n\t\t}\n\t};\n\n\t// Create the base table options\n\tconst baseTableOptions: TableOptionsResolved<TData> = {\n\t\tdata: getData(),\n\t\tcolumns,\n\t\t...(getRowId ? { getRowId } : {}),\n\t\tstate: {\n\t\t\tsorting,\n\t\t\tcolumnFilters,\n\t\t\trowSelection,\n\t\t\tcolumnPinning,\n\t\t\tcolumnVisibility,\n\t\t\tcolumnSizing,\n\t\t\tcolumnSizingInfo\n\t\t},\n\t\tonColumnSizingChange: (updater) => {\n\t\t\tcolumnSizing = typeof updater === 'function' ? updater(columnSizing) : updater;\n\t\t},\n\t\tonColumnSizingInfoChange: (updater) => {\n\t\t\tcolumnSizingInfo = typeof updater === 'function' ? updater(columnSizingInfo) : updater;\n\t\t},\n\t\tonColumnPinningChange: (updater) => {\n\t\t\tcolumnPinning = typeof updater === 'function' ? updater(columnPinning) : updater;\n\t\t},\n\t\tonColumnVisibilityChange: (updater) => {\n\t\t\tcolumnVisibility = typeof updater === 'function' ? updater(columnVisibility) : updater;\n\t\t},\n\t\tonSortingChange: (updater) => {\n\t\t\tsorting = typeof updater === 'function' ? updater(sorting) : updater;\n\t\t},\n\t\tonColumnFiltersChange: (updater) => {\n\t\t\tcolumnFilters = typeof updater === 'function' ? updater(columnFilters) : updater;\n\t\t},\n\t\tonRowSelectionChange: (updater) => {\n\t\t\trowSelection = typeof updater === 'function' ? updater(rowSelection) : updater;\n\t\t},\n\t\tgetCoreRowModel: getCoreRowModel(),\n\t\tgetSortedRowModel: getSortedRowModel(),\n\t\tgetFilteredRowModel: getFilteredRowModel(),\n\t\tcolumnResizeMode: 'onChange',\n\t\tenableColumnResizing: true,\n\t\tdefaultColumn: {\n\t\t\tminSize: 60,\n\t\t\tmaxSize: 1000,\n\t\t\tsize: 150\n\t\t},\n\t\tenableRowSelection: true,\n\t\tenableColumnFilters: true,\n\t\tenableFilters: true,\n\t\trenderFallbackValue: null,\n\t\tonStateChange: () => {},\n\t\tmergeOptions: (defaultOptions: TableOptions<TData>, newOptions: Partial<TableOptions<TData>>) => {\n\t\t\treturn { ...defaultOptions, ...newOptions };\n\t\t},\n\t\tmeta\n\t};\n\n\tconst table = createTable(baseTableOptions);\n\n\t// This is the key to reactivity: update table options in $effect.pre\n\t// whenever any of the state values change\n\t$effect.pre(() => {\n\t\t// Read all reactive state to create dependencies\n\t\tconst currentState = {\n\t\t\tsorting,\n\t\t\tcolumnFilters,\n\t\t\trowSelection,\n\t\t\tcolumnPinning,\n\t\t\tcolumnVisibility,\n\t\t\tcolumnSizing,\n\t\t\tcolumnSizingInfo\n\t\t};\n\t\tconst currentData = getData();\n\n\t\t// Update table with current state\n\t\ttable.setOptions((prev) => ({\n\t\t\t...prev,\n\t\t\tdata: currentData,\n\t\t\tstate: {\n\t\t\t\t...prev.state,\n\t\t\t\t...currentState\n\t\t\t},\n\t\t\tmeta\n\t\t}));\n\t});\n\n\t// ========================================\n\t// Compute columnSizeVars (now that table exists)\n\t// ========================================\n\n\t// Compute column sizes based on columnSizing and columnSizingInfo state\n\tfunction getColumnSizeVars(): Record<string, number> {\n\t\t// Read both columnSizing and columnSizingInfo to create reactive dependencies\n\t\t// columnSizingInfo updates during resize drag, columnSizing updates on release\n\t\tconst _ = columnSizing;\n\t\tconst __ = columnSizingInfo;\n\t\t\n\t\tconst vars: Record<string, number> = {};\n\t\ttry {\n\t\t\tconst headers = table.getFlatHeaders();\n\t\t\tfor (const header of headers) {\n\t\t\t\tconst size = header.getSize();\n\t\t\t\tvars[`--header-${header.id}-size`] = size;\n\t\t\t\tvars[`--col-${header.column.id}-size`] = size;\n\t\t\t}\n\t\t} catch {\n\t\t\t// Table not ready yet\n\t\t}\n\t\treturn vars;\n\t}\n\n\t// ========================================\n\t// Create Virtualizer\n\t// ========================================\n\n\tlet virtualizer: Virtualizer<HTMLDivElement, Element> | null = null;\n\n\t// Virtualizer onChange handler - called when scroll position or size changes\n\tfunction handleVirtualizerChange(instance: Virtualizer<HTMLDivElement, Element>) {\n\t\tvirtualItems = instance.getVirtualItems();\n\t\ttotalSize = instance.getTotalSize();\n\t\tisScrolling = instance.isScrolling;\n\t}\n\n\t// Effect to create virtualizer when ref becomes available\n\t$effect(() => {\n\t\tconst ref = dataGridRef;\n\t\tif (!ref) return;\n\n\t\t// Only create virtualizer once\n\t\tif (virtualizer) return;\n\n\t\t// Use filtered row count, not raw data length\n\t\tconst rowCount = untrack(() => table.getRowModel().rows.length);\n\n\t\tvirtualizer = new Virtualizer<HTMLDivElement, Element>({\n\t\t\tcount: rowCount,\n\t\t\tgetScrollElement: () => ref,\n\t\t\testimateSize: () => getRowHeightValue(rowHeight),\n\t\t\toverscan,\n\t\t\tobserveElementRect,\n\t\t\tobserveElementOffset,\n\t\t\tscrollToFn: elementScroll,\n\t\t\tonChange: handleVirtualizerChange\n\t\t});\n\n\t\tvirtualizer._willUpdate();\n\t\thandleVirtualizerChange(virtualizer);\n\t});\n\n\t// Separate effect to update virtualizer count when filtered rows change\n\t// Track columnFilters, sorting, and data to trigger updates\n\t$effect(() => {\n\t\t// Read these to create dependencies - when filters/sorting change, row count changes\n\t\tconst _ = columnFilters;\n\t\tconst __ = sorting;\n\t\tconst ___ = getData();\n\t\t\n\t\t// Get the filtered/sorted row count from the table\n\t\tconst rowCount = table.getRowModel().rows.length;\n\n\t\tuntrack(() => {\n\t\t\tconst ref = dataGridRef;\n\t\t\tif (virtualizer && ref) {\n\t\t\t\tvirtualizer.setOptions({\n\t\t\t\t\tcount: rowCount,\n\t\t\t\t\tgetScrollElement: () => ref,\n\t\t\t\t\testimateSize: () => getRowHeightValue(rowHeight),\n\t\t\t\t\toverscan,\n\t\t\t\t\tobserveElementRect,\n\t\t\t\t\tobserveElementOffset,\n\t\t\t\t\tscrollToFn: elementScroll,\n\t\t\t\t\tonChange: handleVirtualizerChange\n\t\t\t\t});\n\t\t\t\tvirtualizer._willUpdate();\n\t\t\t}\n\t\t});\n\t});\n\n\t// Setup keyboard handler on data grid element\n\t$effect(() => {\n\t\tif (dataGridRef) {\n\t\t\tdataGridRef.addEventListener('keydown', handleKeyDown);\n\t\t\treturn () => {\n\t\t\t\tdataGridRef?.removeEventListener('keydown', handleKeyDown);\n\t\t\t};\n\t\t}\n\t});\n\n\t// Global keyboard handler for search shortcut (Cmd+F / Ctrl+F)\n\t$effect(() => {\n\t\tif (!enableSearch) return;\n\n\t\tfunction onGlobalKeyDown(event: KeyboardEvent) {\n\t\t\tconst target = event.target;\n\t\t\tif (!(target instanceof HTMLElement)) return;\n\n\t\t\tconst { key, ctrlKey, metaKey, shiftKey } = event;\n\t\t\tconst isCtrlPressed = ctrlKey || metaKey;\n\n\t\t\t// Handle Cmd+F / Ctrl+F for search\n\t\t\tif (isCtrlPressed && !shiftKey && key === 'f') {\n\t\t\t\tconst isInInput = target.tagName === 'INPUT' || target.tagName === 'TEXTAREA';\n\t\t\t\tconst isInDataGrid = dataGridRef?.contains(target) ?? false;\n\t\t\t\tconst isInSearchInput = target.closest('[role=\"search\"]') !== null;\n\n\t\t\t\tif (isInDataGrid || isInSearchInput || !isInInput) {\n\t\t\t\t\tevent.preventDefault();\n\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\tsearchOpen = !searchOpen;\n\n\t\t\t\t\tif (!isInDataGrid && !isInSearchInput && dataGridRef) {\n\t\t\t\t\t\trequestAnimationFrame(() => {\n\t\t\t\t\t\t\tdataGridRef?.focus();\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twindow.addEventListener('keydown', onGlobalKeyDown, true);\n\t\treturn () => {\n\t\t\twindow.removeEventListener('keydown', onGlobalKeyDown, true);\n\t\t};\n\t});\n\n\t// Auto-focus on mount\n\t$effect(() => {\n\t\tif (autoFocus && dataGridRef) {\n\t\t\tqueueMicrotask(() => {\n\t\t\t\tdataGridRef?.focus();\n\n\t\t\t\tconst firstColumnId = getFirstNavigableColumnId();\n\t\t\t\tif (firstColumnId) {\n\t\t\t\t\tif (typeof autoFocus === 'object') {\n\t\t\t\t\t\tfocusCell(autoFocus.rowIndex ?? 0, autoFocus.columnId ?? firstColumnId);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfocusCell(0, firstColumnId);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n\n\t// ========================================\n\t// Create Search State (if enabled)\n\t// ========================================\n\n\t// Note: searchState is returned as a getter in the return object\n\t// This allows the consuming component to get fresh values each render\n\n\t// ========================================\n\t// Create Virtualizer Return Object\n\t// ========================================\n\n\t// Use getters to ensure reactivity is preserved when accessing from consuming components\n\tconst rowVirtualizer: VirtualizerReturn = {\n\t\t// Reactive getters - these allow Svelte to track dependencies\n\t\tget virtualItems() {\n\t\t\treturn virtualItems;\n\t\t},\n\t\tget totalSize() {\n\t\t\treturn totalSize;\n\t\t},\n\t\tget isScrolling() {\n\t\t\treturn isScrolling;\n\t\t},\n\t\t// Methods\n\t\tscrollToIndex: (index, options) => virtualizer?.scrollToIndex(index, options),\n\t\tmeasureElement: (element) => virtualizer?.measureElement(element),\n\t\t// Legacy function-based accessors (kept for compatibility)\n\t\tgetVirtualItems: () => virtualItems,\n\t\tgetTotalSize: () => totalSize\n\t};\n\n\t// ========================================\n\t// Return\n\t// ========================================\n\n\t// Create a reactive table wrapper that exposes state-dependent getters\n\t// This is key to making the table reactive in Svelte 5\n\tconst reactiveTable = {\n\t\t// Expose all original table methods and properties\n\t\t...table,\n\t\t// Override methods that depend on state to create reactive dependencies\n\t\tgetRowModel: () => {\n\t\t\t// Read state to create Svelte dependencies\n\t\t\tconst _ = sorting;\n\t\t\tconst __ = columnFilters;\n\t\t\tconst ___ = getData();\n\t\t\treturn table.getRowModel();\n\t\t},\n\t\tgetHeaderGroups: () => {\n\t\t\t// Read state to create Svelte dependencies\n\t\t\tconst _ = columnVisibility;\n\t\t\tconst __ = columnPinning;\n\t\t\tconst ___ = columnSizing;\n\t\t\treturn table.getHeaderGroups();\n\t\t},\n\t\tgetAllColumns: () => {\n\t\t\t// Read state to create Svelte dependencies  \n\t\t\tconst _ = columnVisibility;\n\t\t\tconst __ = columnPinning;\n\t\t\treturn table.getAllColumns();\n\t\t},\n\t\tgetVisibleLeafColumns: () => {\n\t\t\tconst _ = columnVisibility;\n\t\t\treturn table.getVisibleLeafColumns();\n\t\t},\n\t\tgetState: () => {\n\t\t\t// Read all state to create dependencies\n\t\t\tconst _ = sorting;\n\t\t\tconst __ = columnFilters;\n\t\t\tconst ___ = rowSelection;\n\t\t\tconst ____ = columnPinning;\n\t\t\tconst _____ = columnVisibility;\n\t\t\tconst ______ = columnSizing;\n\t\t\tconst _______ = columnSizingInfo;\n\t\t\treturn table.getState();\n\t\t},\n\t\tgetColumn: (columnId: string) => table.getColumn(columnId),\n\t\t// Forward all other methods to the original table\n\t\tsetColumnFilters: table.setColumnFilters.bind(table),\n\t\tsetSorting: table.setSorting.bind(table),\n\t\tsetColumnPinning: table.setColumnPinning.bind(table),\n\t\tsetColumnVisibility: table.setColumnVisibility.bind(table),\n\t\tsetRowSelection: table.setRowSelection.bind(table),\n\t\tsetColumnSizing: table.setColumnSizing.bind(table),\n\t\tsetOptions: table.setOptions.bind(table),\n\t\tgetFlatHeaders: () => {\n\t\t\tconst _ = columnSizing;\n\t\t\tconst __ = columnVisibility;\n\t\t\tconst ___ = columnSizingInfo;\n\t\t\treturn table.getFlatHeaders();\n\t\t},\n\t\tgetTotalSize: () => {\n\t\t\tconst _ = columnSizing;\n\t\t\treturn table.getTotalSize();\n\t\t},\n\t\tgetLeftLeafColumns: () => {\n\t\t\tconst _ = columnPinning;\n\t\t\treturn table.getLeftLeafColumns();\n\t\t},\n\t\tgetRightLeafColumns: () => {\n\t\t\tconst _ = columnPinning;\n\t\t\treturn table.getRightLeafColumns();\n\t\t},\n\t\tgetCenterLeafColumns: () => {\n\t\t\tconst _ = columnPinning;\n\t\t\treturn table.getCenterLeafColumns();\n\t\t},\n\t\tgetIsAllRowsSelected: () => {\n\t\t\tconst _ = rowSelection;\n\t\t\treturn table.getIsAllRowsSelected();\n\t\t},\n\t\tgetIsSomeRowsSelected: () => {\n\t\t\tconst _ = rowSelection;\n\t\t\treturn table.getIsSomeRowsSelected();\n\t\t},\n\t\tgetIsAllPageRowsSelected: () => {\n\t\t\tconst _ = rowSelection;\n\t\t\treturn table.getIsAllPageRowsSelected();\n\t\t},\n\t\tgetIsSomePageRowsSelected: () => {\n\t\t\tconst _ = rowSelection;\n\t\t\treturn table.getIsSomePageRowsSelected();\n\t\t},\n\t\ttoggleAllRowsSelected: table.toggleAllRowsSelected.bind(table),\n\t\ttoggleAllPageRowsSelected: table.toggleAllPageRowsSelected.bind(table),\n\t\t// Keep table reference for any other property access\n\t\t_getDefaultColumnDef: table._getDefaultColumnDef.bind(table),\n\t\toptions: table.options,\n\t\tinitialState: table.initialState\n\t} as unknown as Table<TData>;\n\n\t// Search callbacks - these are stable references\n\tfunction handleSearchOpenChange(open: boolean) {\n\t\tsearchOpen = open;\n\t\tif (!open) {\n\t\t\tsearchQuery = '';\n\t\t\tsearchMatches = [];\n\t\t\tsearchMatchSet.clear();\n\t\t\tmatchIndex = 0;\n\t\t}\n\t}\n\n\tfunction handleSearchQueryChange(query: string) {\n\t\tsearchQuery = query;\n\t}\n\n\treturn {\n\t\tdataGridRef,\n\t\theaderRef,\n\t\trowMapRef,\n\t\tfooterRef,\n\t\ttable: reactiveTable,\n\t\trowVirtualizer,\n\t\t// Search state with getters for reactive values\n\t\tsearchState: enableSearch\n\t\t\t? {\n\t\t\t\t\tget searchMatches() { return searchMatches; },\n\t\t\t\t\tget matchIndex() { return matchIndex; },\n\t\t\t\t\tget searchOpen() { return searchOpen; },\n\t\t\t\t\tget searchQuery() { return searchQuery; },\n\t\t\t\t\tonSearchOpenChange: handleSearchOpenChange,\n\t\t\t\t\tonSearchQueryChange: handleSearchQueryChange,\n\t\t\t\t\tonSearch: performSearch,\n\t\t\t\t\tonNavigateToNextMatch: navigateToNextMatch,\n\t\t\t\t\tonNavigateToPrevMatch: navigateToPrevMatch\n\t\t\t\t}\n\t\t\t: undefined,\n\t\tget columnSizeVars() {\n\t\t\treturn getColumnSizeVars();\n\t\t},\n\t\tonRowAdd: onRowAddProp ? handleRowAdd : undefined,\n\t\tsetDataGridRef: (el: HTMLDivElement | null) => {\n\t\t\tdataGridRef = el;\n\t\t},\n\t\tsetHeaderRef: (el: HTMLDivElement | null) => {\n\t\t\theaderRef = el;\n\t\t},\n\t\tsetFooterRef: (el: HTMLDivElement | null) => {\n\t\t\tfooterRef = el;\n\t\t}\n\t};\n}\n\n",
			"type": "registry:hook",
			"target": "use-data-grid.svelte.ts"
		},
		{
			"content": "// Data Grid Types for TableCN-Svelte\n// Exact port of TableCN React types for Svelte 5\n\nimport type {\n\tColumnDef,\n\tTable,\n\tRow,\n\tCell,\n\tColumn,\n\tRowData\n} from '@tanstack/table-core';\nimport type { Snippet, Component } from 'svelte';\n\n// ============================================\n// Base Types\n// ============================================\n\nexport interface Option {\n\tlabel: string;\n\tvalue: string;\n}\n\nexport type RowHeightValue = 'short' | 'medium' | 'tall' | 'extra-tall';\n\nexport interface CellSelectOption {\n\tlabel: string;\n\tvalue: string;\n\ticon?: Component;\n\tcount?: number;\n}\n\n// ============================================\n// Cell Types\n// ============================================\n\nexport type CellOpts =\n\t| { variant: 'short-text' }\n\t| { variant: 'long-text' }\n\t| { variant: 'number'; min?: number; max?: number; step?: number }\n\t| { variant: 'select'; options: CellSelectOption[] }\n\t| { variant: 'multi-select'; options: CellSelectOption[] }\n\t| { variant: 'checkbox' }\n\t| { variant: 'date' }\n\t| { variant: 'url' }\n\t| { variant: 'row-select' }\n\t| {\n\t\t\tvariant: 'file';\n\t\t\tmaxFileSize?: number;\n\t\t\tmaxFiles?: number;\n\t\t\taccept?: string;\n\t\t\tmultiple?: boolean;\n\t  };\n\nexport interface UpdateCell {\n\trowIndex: number;\n\tcolumnId: string;\n\tvalue: unknown;\n}\n\n// ============================================\n// Position & Selection Types\n// ============================================\n\nexport interface CellPosition {\n\trowIndex: number;\n\tcolumnId: string;\n}\n\nexport interface CellRange {\n\tstart: CellPosition;\n\tend: CellPosition;\n}\n\nexport interface SelectionState {\n\tselectedCells: Set<string>;\n\tselectionRange: CellRange | null;\n\tisSelecting: boolean;\n}\n\n// ============================================\n// Context Menu Types\n// ============================================\n\nexport interface ContextMenuState {\n\topen: boolean;\n\tx: number;\n\ty: number;\n}\n\n// ============================================\n// Paste Dialog Types\n// ============================================\n\nexport interface PasteDialogState {\n\topen: boolean;\n\trowsNeeded: number;\n\tclipboardText: string;\n}\n\n// ============================================\n// Navigation Types\n// ============================================\n\nexport type NavigationDirection =\n\t| 'up'\n\t| 'down'\n\t| 'left'\n\t| 'right'\n\t| 'home'\n\t| 'end'\n\t| 'ctrl+home'\n\t| 'ctrl+end'\n\t| 'pageup'\n\t| 'pagedown';\n\n// ============================================\n// Search Types\n// ============================================\n\n// Type alias for search match - same as CellPosition\nexport type SearchMatch = CellPosition;\n\n// Data-only search state (used by stores)\nexport interface SearchStateData {\n\tsearchOpen: boolean;\n\tsearchQuery: string;\n\tsearchMatches: SearchMatch[];\n\tmatchIndex: number;\n}\n\n// Full search state with callbacks (used by components)\nexport interface SearchState extends SearchStateData {\n\tonSearchOpenChange: (open: boolean) => void;\n\tonSearchQueryChange: (query: string) => void;\n\tonSearch: (query: string) => void;\n\tonNavigateToNextMatch: () => void;\n\tonNavigateToPrevMatch: () => void;\n}\n\n// ============================================\n// Cell Variant Props\n// ============================================\n\nexport interface CellVariantProps<TData> {\n\tcell: Cell<TData, unknown>;\n\ttable: Table<TData>;\n\trowIndex: number;\n\tcolumnId: string;\n\tisEditing: boolean;\n\tisFocused: boolean;\n\tisSelected: boolean;\n\treadOnly?: boolean;\n}\n\n// ============================================\n// File Cell Types\n// ============================================\n\nexport interface FileCellData {\n\tid: string;\n\tname: string;\n\tsize: number;\n\ttype: string;\n\turl?: string;\n}\n\n// ============================================\n// Filter Types\n// ============================================\n\nexport type TextFilterOperator =\n\t| 'contains'\n\t| 'notContains'\n\t| 'equals'\n\t| 'notEquals'\n\t| 'startsWith'\n\t| 'endsWith'\n\t| 'isEmpty'\n\t| 'isNotEmpty';\n\nexport type NumberFilterOperator =\n\t| 'equals'\n\t| 'notEquals'\n\t| 'lessThan'\n\t| 'lessThanOrEqual'\n\t| 'greaterThan'\n\t| 'greaterThanOrEqual'\n\t| 'between'\n\t| 'isEmpty'\n\t| 'isNotEmpty';\n\nexport type DateFilterOperator =\n\t| 'equals'\n\t| 'notEquals'\n\t| 'before'\n\t| 'after'\n\t| 'onOrBefore'\n\t| 'onOrAfter'\n\t| 'between'\n\t| 'isEmpty'\n\t| 'isNotEmpty';\n\nexport type SelectFilterOperator =\n\t| 'is'\n\t| 'isNot'\n\t| 'isAnyOf'\n\t| 'isNoneOf'\n\t| 'isEmpty'\n\t| 'isNotEmpty';\n\nexport type BooleanFilterOperator = 'isTrue' | 'isFalse';\n\nexport type FilterOperator =\n\t| TextFilterOperator\n\t| NumberFilterOperator\n\t| DateFilterOperator\n\t| SelectFilterOperator\n\t| BooleanFilterOperator;\n\nexport interface FilterValue {\n\toperator: FilterOperator;\n\tvalue?: string | number | string[];\n\tvalue2?: string | number;\n}\n\n// ============================================\n// TanStack Table Meta Extension\n// ============================================\n\ndeclare module '@tanstack/table-core' {\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\tinterface ColumnMeta<TData extends RowData, TValue> {\n\t\tlabel?: string;\n\t\tcell?: CellOpts;\n\t}\n\n\tinterface TableMeta<TData extends RowData> {\n\t\tdataGridRef?: HTMLElement | null;\n\t\tcellMapRef?: Map<string, HTMLDivElement>;\n\t\tfocusedCell?: CellPosition | null;\n\t\teditingCell?: CellPosition | null;\n\t\tselectionState?: SelectionState;\n\t\tsearchOpen?: boolean;\n\t\treadOnly?: boolean;\n\t\tgetIsCellSelected?: (rowIndex: number, columnId: string) => boolean;\n\t\tgetIsSearchMatch?: (rowIndex: number, columnId: string) => boolean;\n\t\tgetIsActiveSearchMatch?: (rowIndex: number, columnId: string) => boolean;\n\t\t// SvelteSet for fine-grained reactive search match lookups\n\t\tsearchMatchSet?: Set<string>;\n\t\tactiveSearchMatch?: CellPosition | null;\n\t\trowHeight?: RowHeightValue;\n\t\tonRowHeightChange?: (value: RowHeightValue) => void;\n\t\tonRowSelect?: (rowIndex: number, checked: boolean, shiftKey: boolean) => void;\n\t\tonDataUpdate?: (params: UpdateCell | UpdateCell[]) => void;\n\t\tonRowsDelete?: (rowIndices: number[]) => void | Promise<void>;\n\t\tonColumnClick?: (columnId: string) => void;\n\t\tonCellClick?: (rowIndex: number, columnId: string, event?: MouseEvent) => void;\n\t\tonCellDoubleClick?: (rowIndex: number, columnId: string) => void;\n\t\tonCellMouseDown?: (rowIndex: number, columnId: string, event: MouseEvent) => void;\n\t\tonCellMouseEnter?: (rowIndex: number, columnId: string, event: MouseEvent) => void;\n\t\tonCellMouseUp?: () => void;\n\t\tonCellContextMenu?: (rowIndex: number, columnId: string, event: MouseEvent) => void;\n\t\tonCellEditingStart?: (rowIndex: number, columnId: string) => void;\n\t\tonCellEditingStop?: (opts?: {\n\t\t\tdirection?: NavigationDirection;\n\t\t\tmoveToNextRow?: boolean;\n\t\t}) => void;\n\t\tonCellsCopy?: () => void;\n\t\tonCellsCut?: () => void;\n\t\tonFilesUpload?: (params: {\n\t\t\tfiles: File[];\n\t\t\trowIndex: number;\n\t\t\tcolumnId: string;\n\t\t\trow: TData;\n\t\t}) => Promise<FileCellData[]>;\n\t\tonFilesDelete?: (params: {\n\t\t\tfileIds: string[];\n\t\t\trowIndex: number;\n\t\t\tcolumnId: string;\n\t\t\trow: TData;\n\t\t}) => void | Promise<void>;\n\t\tcontextMenu?: ContextMenuState;\n\t\tonContextMenuOpenChange?: (open: boolean) => void;\n\t\tpasteDialog?: PasteDialogState;\n\t\tonPasteDialogOpenChange?: (open: boolean) => void;\n\t\tonPasteWithExpansion?: () => void;\n\t\tonPasteWithoutExpansion?: () => void;\n\t}\n}\n\n// ============================================\n// Row Height Constants\n// ============================================\n\nexport const ROW_HEIGHT_VALUES: Record<RowHeightValue, number> = {\n\tshort: 36,\n\tmedium: 56,\n\ttall: 76,\n\t'extra-tall': 96\n};\n\nexport const ROW_LINE_COUNTS: Record<RowHeightValue, number> = {\n\tshort: 1,\n\tmedium: 2,\n\ttall: 3,\n\t'extra-tall': 4\n};\n\n// ============================================\n// Component Props Types\n// ============================================\n\nexport interface DataGridProps<TData> {\n\tdata: TData[];\n\tcolumns: ColumnDef<TData, unknown>[];\n\treadOnly?: boolean;\n\theight?: number;\n\trowHeight?: RowHeightValue;\n\tautoFocus?: boolean | { rowIndex?: number; columnId?: string };\n\tenableColumnSelection?: boolean;\n\tenableSearch?: boolean;\n\tenablePaste?: boolean;\n\toverscan?: number;\n\tclass?: string;\n\n\t// Callbacks\n\tonDataChange?: (data: TData[]) => void;\n\tonRowAdd?: (event?: MouseEvent) => Partial<CellPosition> | void | Promise<Partial<CellPosition> | void>;\n\tonRowsAdd?: (count: number) => void | Promise<void>;\n\tonRowsDelete?: (rows: TData[], rowIndices: number[]) => void | Promise<void>;\n\tonPaste?: (updates: UpdateCell[]) => void | Promise<void>;\n\tonFilesUpload?: (params: {\n\t\tfiles: File[];\n\t\trowIndex: number;\n\t\tcolumnId: string;\n\t\trow: TData;\n\t}) => Promise<FileCellData[]>;\n\tonFilesDelete?: (params: {\n\t\tfileIds: string[];\n\t\trowIndex: number;\n\t\tcolumnId: string;\n\t\trow: TData;\n\t}) => void | Promise<void>;\n\n\t// Snippets for customization\n\theader?: Snippet<[{ column: Column<TData, unknown> }]>;\n\tcell?: Snippet<[{ cell: Cell<TData, unknown>; row: Row<TData> }]>;\n\tempty?: Snippet;\n\tfooter?: Snippet;\n}\n\n// ============================================\n// Utility Functions\n// ============================================\n\n/**\n * Creates a unique cell key from row index and column id\n */\nexport function getCellKey(rowIndex: number, columnId: string): string {\n\treturn `${rowIndex}:${columnId}`;\n}\n\n/**\n * Parses a cell key back into row index and column id\n */\nexport function parseCellKey(cellKey: string): CellPosition {\n\tconst parts = cellKey.split(':');\n\tconst rowIndexStr = parts[0];\n\tconst columnId = parts[1];\n\tif (rowIndexStr && columnId) {\n\t\tconst rowIndex = parseInt(rowIndexStr, 10);\n\t\tif (!Number.isNaN(rowIndex)) {\n\t\t\treturn { rowIndex, columnId };\n\t\t}\n\t}\n\treturn { rowIndex: 0, columnId: '' };\n}\n\n/**\n * Gets the pixel height for a row height value\n */\nexport function getRowHeightValue(rowHeight: RowHeightValue): number {\n\treturn ROW_HEIGHT_VALUES[rowHeight];\n}\n\n/**\n * Gets the line count for a row height value\n */\nexport function getLineCount(rowHeight: RowHeightValue): number {\n\treturn ROW_LINE_COUNTS[rowHeight];\n}\n\n/**\n * Gets common pinning styles for a column (port of TableCN's getCommonPinningStyles)\n */\nexport function getCommonPinningStyles<TData>(params: {\n\tcolumn?: Column<TData, unknown>;\n\twithBorder?: boolean;\n}): Record<string, string | number | undefined> {\n\tconst { column, withBorder = false } = params;\n\n\t// Return default styles if column is undefined\n\tif (!column) {\n\t\treturn {\n\t\t\tposition: 'relative',\n\t\t\tbackground: 'var(--background)',\n\t\t\tzIndex: undefined\n\t\t};\n\t}\n\n\t// Wrap in try-catch to handle SSR edge cases where TanStack internal state may not be ready\n\ttry {\n\t\tconst isPinned = column.getIsPinned();\n\t\tconst isLastLeftPinnedColumn = isPinned === 'left' && column.getIsLastColumn('left');\n\t\tconst isFirstRightPinnedColumn = isPinned === 'right' && column.getIsFirstColumn('right');\n\n\t\treturn {\n\t\t\tboxShadow: withBorder\n\t\t\t\t? isLastLeftPinnedColumn\n\t\t\t\t\t? '-4px 0 4px -4px var(--border) inset'\n\t\t\t\t\t: isFirstRightPinnedColumn\n\t\t\t\t\t\t? '4px 0 4px -4px var(--border) inset'\n\t\t\t\t\t\t: undefined\n\t\t\t\t: undefined,\n\t\t\tleft: isPinned === 'left' ? `${column.getStart('left')}px` : undefined,\n\t\t\tright: isPinned === 'right' ? `${column.getAfter('right')}px` : undefined,\n\t\t\topacity: isPinned ? 0.97 : 1,\n\t\t\tposition: isPinned ? 'sticky' : 'relative',\n\t\t\tbackground: isPinned ? 'var(--background)' : 'var(--background)',\n\t\t\twidth: column.getSize(),\n\t\t\tzIndex: isPinned ? 1 : undefined\n\t\t};\n\t} catch {\n\t\t// Return default styles if column methods fail (e.g., during SSR)\n\t\treturn {\n\t\t\tposition: 'relative',\n\t\t\tbackground: 'var(--background)',\n\t\t\tzIndex: undefined\n\t\t};\n\t}\n}\n",
			"type": "registry:lib",
			"target": "data-grid.ts"
		},
		{
			"content": "// Data Grid Configuration Constants\n\n// Virtualization settings\nexport const OVERSCAN = 3;\nexport const VIEWPORT_OFFSET = 1;\n\n// Column sizing\nexport const MIN_COLUMN_SIZE = 60;\nexport const MAX_COLUMN_SIZE = 800;\nexport const DEFAULT_COLUMN_SIZE = 150;\n\n// Row heights in pixels\nexport const ROW_HEIGHTS = {\n\tshort: 36,\n\tmedium: 56,\n\ttall: 76,\n\t'extra-tall': 96\n} as const;\n\n// Line counts for text wrapping\nexport const ROW_LINE_COUNTS = {\n\tshort: 1,\n\tmedium: 2,\n\ttall: 3,\n\t'extra-tall': 4\n} as const;\n\n// Keyboard shortcuts\nexport const KEYBOARD_SHORTCUTS = {\n\t// Navigation\n\tARROW_UP: 'ArrowUp',\n\tARROW_DOWN: 'ArrowDown',\n\tARROW_LEFT: 'ArrowLeft',\n\tARROW_RIGHT: 'ArrowRight',\n\tTAB: 'Tab',\n\tENTER: 'Enter',\n\tESCAPE: 'Escape',\n\tHOME: 'Home',\n\tEND: 'End',\n\tPAGE_UP: 'PageUp',\n\tPAGE_DOWN: 'PageDown',\n\n\t// Actions\n\tDELETE: 'Delete',\n\tBACKSPACE: 'Backspace',\n\n\t// With modifiers (handled separately)\n\t// Ctrl+A - Select all\n\t// Ctrl+C - Copy\n\t// Ctrl+X - Cut\n\t// Ctrl+V - Paste\n\t// Ctrl+F - Find\n\t// Ctrl+Home - Go to first cell\n\t// Ctrl+End - Go to last cell\n} as const;\n\n// Selection\nexport const SELECTION_BORDER_WIDTH = 2;\n\n// Animation durations (ms)\nexport const ANIMATION_DURATION = {\n\tfast: 100,\n\tnormal: 200,\n\tslow: 300\n} as const;\n\n// Debounce delays (ms)\nexport const DEBOUNCE_DELAY = {\n\tsearch: 300,\n\tresize: 100,\n\tscroll: 16\n} as const;\n\n// Cell variants configuration\nexport const CELL_VARIANTS = [\n\t'short-text',\n\t'long-text',\n\t'number',\n\t'checkbox',\n\t'select',\n\t'multi-select',\n\t'date',\n\t'url',\n\t'file'\n] as const;\n\n// Default cell variant\nexport const DEFAULT_CELL_VARIANT = 'short-text';\n\n// File upload defaults\nexport const FILE_UPLOAD_DEFAULTS = {\n\tmaxFileSize: 10 * 1024 * 1024, // 10MB\n\tmaxFiles: 5,\n\taccept: '*/*'\n} as const;\n\n// Date format\nexport const DATE_FORMAT = 'yyyy-MM-dd';\nexport const DATE_TIME_FORMAT = 'yyyy-MM-dd HH:mm';\n\n// Clipboard format\nexport const CLIPBOARD_MIME_TYPE = 'text/plain';\nexport const CLIPBOARD_SEPARATOR = '\\t'; // TSV format\nexport const CLIPBOARD_ROW_SEPARATOR = '\\n';\n",
			"type": "registry:lib",
			"target": "data-grid.ts"
		},
		{
			"content": "// Data Grid Filter Utilities\n// Exact port of TableCN filter utilities\n\nimport type { FilterFn, Row } from '@tanstack/table-core';\nimport type {\n\tBooleanFilterOperator,\n\tDateFilterOperator,\n\tFilterOperator,\n\tFilterValue,\n\tNumberFilterOperator,\n\tSelectFilterOperator,\n\tTextFilterOperator\n} from '$lib/types/data-grid.js';\n\nexport const TEXT_FILTER_OPERATORS: ReadonlyArray<{\n\tlabel: string;\n\tvalue: TextFilterOperator;\n}> = [\n\t{ label: 'Contains', value: 'contains' },\n\t{ label: 'Does not contain', value: 'notContains' },\n\t{ label: 'Is', value: 'equals' },\n\t{ label: 'Is not', value: 'notEquals' },\n\t{ label: 'Starts with', value: 'startsWith' },\n\t{ label: 'Ends with', value: 'endsWith' },\n\t{ label: 'Is empty', value: 'isEmpty' },\n\t{ label: 'Is not empty', value: 'isNotEmpty' }\n];\n\nexport const NUMBER_FILTER_OPERATORS: ReadonlyArray<{\n\tlabel: string;\n\tvalue: NumberFilterOperator;\n}> = [\n\t{ label: 'Is', value: 'equals' },\n\t{ label: 'Is not', value: 'notEquals' },\n\t{ label: 'Is less than', value: 'lessThan' },\n\t{ label: 'Is less than or equal to', value: 'lessThanOrEqual' },\n\t{ label: 'Is greater than', value: 'greaterThan' },\n\t{ label: 'Is greater than or equal to', value: 'greaterThanOrEqual' },\n\t{ label: 'Is between', value: 'between' },\n\t{ label: 'Is empty', value: 'isEmpty' },\n\t{ label: 'Is not empty', value: 'isNotEmpty' }\n];\n\nexport const DATE_FILTER_OPERATORS: ReadonlyArray<{\n\tlabel: string;\n\tvalue: DateFilterOperator;\n}> = [\n\t{ label: 'Is', value: 'equals' },\n\t{ label: 'Is not', value: 'notEquals' },\n\t{ label: 'Is before', value: 'before' },\n\t{ label: 'Is after', value: 'after' },\n\t{ label: 'Is on or before', value: 'onOrBefore' },\n\t{ label: 'Is on or after', value: 'onOrAfter' },\n\t{ label: 'Is between', value: 'between' },\n\t{ label: 'Is empty', value: 'isEmpty' },\n\t{ label: 'Is not empty', value: 'isNotEmpty' }\n];\n\nexport const SELECT_FILTER_OPERATORS: ReadonlyArray<{\n\tlabel: string;\n\tvalue: SelectFilterOperator;\n}> = [\n\t{ label: 'Is', value: 'is' },\n\t{ label: 'Is not', value: 'isNot' },\n\t{ label: 'Has any of', value: 'isAnyOf' },\n\t{ label: 'Has none of', value: 'isNoneOf' },\n\t{ label: 'Is empty', value: 'isEmpty' },\n\t{ label: 'Is not empty', value: 'isNotEmpty' }\n];\n\nexport const BOOLEAN_FILTER_OPERATORS: ReadonlyArray<{\n\tlabel: string;\n\tvalue: BooleanFilterOperator;\n}> = [\n\t{ label: 'Is', value: 'isTrue' },\n\t{ label: 'Is not', value: 'isFalse' }\n];\n\nexport function getDefaultOperator(variant: string): FilterOperator {\n\tswitch (variant) {\n\t\tcase 'number':\n\t\t\treturn 'equals';\n\t\tcase 'date':\n\t\t\treturn 'equals';\n\t\tcase 'select':\n\t\tcase 'multi-select':\n\t\t\treturn 'is';\n\t\tcase 'checkbox':\n\t\t\treturn 'isTrue';\n\t\tdefault:\n\t\t\treturn 'contains';\n\t}\n}\n\nexport function getOperatorsForVariant(variant: string): ReadonlyArray<{\n\tlabel: string;\n\tvalue: FilterOperator;\n}> {\n\tswitch (variant) {\n\t\tcase 'number':\n\t\t\treturn NUMBER_FILTER_OPERATORS;\n\t\tcase 'date':\n\t\t\treturn DATE_FILTER_OPERATORS;\n\t\tcase 'select':\n\t\tcase 'multi-select':\n\t\t\treturn SELECT_FILTER_OPERATORS;\n\t\tcase 'checkbox':\n\t\t\treturn BOOLEAN_FILTER_OPERATORS;\n\t\tdefault:\n\t\t\treturn TEXT_FILTER_OPERATORS;\n\t}\n}\n\nexport function getFilterFn<TData>(): FilterFn<TData> {\n\treturn (row: Row<TData>, columnId: string, filterValue: unknown): boolean => {\n\t\tif (!filterValue || typeof filterValue !== 'object') {\n\t\t\treturn true;\n\t\t}\n\n\t\tconst filter = filterValue as FilterValue;\n\t\tconst { operator, value, value2 } = filter;\n\n\t\tconst cellValue = row.getValue(columnId);\n\n\t\tif (operator === 'isEmpty') {\n\t\t\treturn (\n\t\t\t\tcellValue === null ||\n\t\t\t\tcellValue === undefined ||\n\t\t\t\tcellValue === '' ||\n\t\t\t\t(Array.isArray(cellValue) && cellValue.length === 0)\n\t\t\t);\n\t\t}\n\n\t\tif (operator === 'isNotEmpty') {\n\t\t\treturn !(\n\t\t\t\tcellValue === null ||\n\t\t\t\tcellValue === undefined ||\n\t\t\t\tcellValue === '' ||\n\t\t\t\t(Array.isArray(cellValue) && cellValue.length === 0)\n\t\t\t);\n\t\t}\n\n\t\tif (operator === 'isTrue') {\n\t\t\treturn cellValue === true;\n\t\t}\n\n\t\tif (operator === 'isFalse') {\n\t\t\treturn cellValue === false || !cellValue;\n\t\t}\n\n\t\tif (value === undefined || value === null || value === '') {\n\t\t\treturn true;\n\t\t}\n\n\t\tconst cellValueStr = String(cellValue ?? '').toLowerCase();\n\t\tconst filterValueStr =\n\t\t\ttypeof value === 'string' ? value.toLowerCase() : String(value);\n\n\t\tif (operator === 'contains') {\n\t\t\treturn cellValueStr.includes(filterValueStr);\n\t\t}\n\n\t\tif (operator === 'notContains') {\n\t\t\treturn !cellValueStr.includes(filterValueStr);\n\t\t}\n\n\t\tif (operator === 'equals') {\n\t\t\tif (typeof cellValue === 'number' && typeof value === 'number') {\n\t\t\t\treturn cellValue === value;\n\t\t\t}\n\t\t\tif (cellValue instanceof Date && typeof value === 'string') {\n\t\t\t\tconst cellDate = new Date(cellValue);\n\t\t\t\tconst filterDate = new Date(value);\n\t\t\t\treturn cellDate.toDateString() === filterDate.toDateString();\n\t\t\t}\n\t\t\treturn cellValueStr === filterValueStr;\n\t\t}\n\n\t\tif (operator === 'notEquals') {\n\t\t\tif (typeof cellValue === 'number' && typeof value === 'number') {\n\t\t\t\treturn cellValue !== value;\n\t\t\t}\n\t\t\tif (cellValue instanceof Date && typeof value === 'string') {\n\t\t\t\tconst cellDate = new Date(cellValue);\n\t\t\t\tconst filterDate = new Date(value);\n\t\t\t\treturn cellDate.toDateString() !== filterDate.toDateString();\n\t\t\t}\n\t\t\treturn cellValueStr !== filterValueStr;\n\t\t}\n\n\t\tif (operator === 'startsWith') {\n\t\t\treturn cellValueStr.startsWith(filterValueStr);\n\t\t}\n\n\t\tif (operator === 'endsWith') {\n\t\t\treturn cellValueStr.endsWith(filterValueStr);\n\t\t}\n\n\t\tif (typeof cellValue === 'number' && typeof value === 'number') {\n\t\t\tif (operator === 'greaterThan') {\n\t\t\t\treturn cellValue > value;\n\t\t\t}\n\n\t\t\tif (operator === 'greaterThanOrEqual') {\n\t\t\t\treturn cellValue >= value;\n\t\t\t}\n\n\t\t\tif (operator === 'lessThan') {\n\t\t\t\treturn cellValue < value;\n\t\t\t}\n\n\t\t\tif (operator === 'lessThanOrEqual') {\n\t\t\t\treturn cellValue <= value;\n\t\t\t}\n\n\t\t\tif (operator === 'between' && typeof value2 === 'number') {\n\t\t\t\treturn cellValue >= value && cellValue <= value2;\n\t\t\t}\n\t\t}\n\n\t\tif (cellValue instanceof Date || typeof cellValue === 'string') {\n\t\t\tconst cellDate = new Date(cellValue);\n\t\t\tif (!Number.isNaN(cellDate.getTime()) && typeof value === 'string') {\n\t\t\t\tconst filterDate = new Date(value);\n\n\t\t\t\tif (operator === 'before') {\n\t\t\t\t\treturn cellDate < filterDate;\n\t\t\t\t}\n\n\t\t\t\tif (operator === 'after') {\n\t\t\t\t\treturn cellDate > filterDate;\n\t\t\t\t}\n\n\t\t\t\tif (operator === 'onOrBefore') {\n\t\t\t\t\treturn cellDate <= filterDate;\n\t\t\t\t}\n\n\t\t\t\tif (operator === 'onOrAfter') {\n\t\t\t\t\treturn cellDate >= filterDate;\n\t\t\t\t}\n\n\t\t\t\tif (operator === 'between' && typeof value2 === 'string') {\n\t\t\t\t\tconst filterDate2 = new Date(value2);\n\t\t\t\t\treturn cellDate >= filterDate && cellDate <= filterDate2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (operator === 'is') {\n\t\t\tif (Array.isArray(cellValue)) {\n\t\t\t\treturn cellValue.some((v) => String(v) === String(value));\n\t\t\t}\n\t\t\treturn String(cellValue) === String(value);\n\t\t}\n\n\t\tif (operator === 'isNot') {\n\t\t\tif (Array.isArray(cellValue)) {\n\t\t\t\treturn !cellValue.some((v) => String(v) === String(value));\n\t\t\t}\n\t\t\treturn String(cellValue) !== String(value);\n\t\t}\n\n\t\tif (operator === 'isAnyOf' && Array.isArray(value)) {\n\t\t\tif (Array.isArray(cellValue)) {\n\t\t\t\treturn cellValue.some((v) =>\n\t\t\t\t\tvalue.some((fv) => String(v) === String(fv))\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn value.some((fv) => String(cellValue) === String(fv));\n\t\t}\n\n\t\tif (operator === 'isNoneOf' && Array.isArray(value)) {\n\t\t\tif (Array.isArray(cellValue)) {\n\t\t\t\treturn !cellValue.some((v) =>\n\t\t\t\t\tvalue.some((fv) => String(v) === String(fv))\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn !value.some((fv) => String(cellValue) === String(fv));\n\t\t}\n\n\t\treturn true;\n\t};\n}\n",
			"type": "registry:lib",
			"target": "data-grid-filters.ts"
		},
		{
			"content": "// TanStack Table integration for Svelte 5\n// This creates a reactive table instance using Svelte 5 runes\n\nimport {\n\tcreateTable,\n\tgetCoreRowModel,\n\ttype TableOptions,\n\ttype TableOptionsResolved,\n\ttype TableState,\n\ttype Table,\n\ttype RowData,\n\ttype Updater\n} from '@tanstack/table-core';\n\nexport interface CreateSvelteTableOptions<TData extends RowData>\n\textends Omit<TableOptions<TData>, 'getCoreRowModel'> {\n\t// Make getCoreRowModel optional since we provide a default\n\tgetCoreRowModel?: ReturnType<typeof getCoreRowModel>;\n}\n\n/**\n * Creates a reactive TanStack Table instance for Svelte 5\n *\n * @param options - Table options (can be reactive via getter function)\n * @returns A reactive table instance\n *\n * @example\n * ```svelte\n * <script lang=\"ts\">\n *   import { createSvelteTable } from '$lib/table';\n *\n *   let data = $state([...]);\n *\n *   const table = createSvelteTable({\n *     get data() { return data },\n *     columns,\n *   });\n * </script>\n * ```\n */\nexport function createSvelteTable<TData extends RowData>(\n\toptions: CreateSvelteTableOptions<TData>\n): Table<TData> {\n\t// Create reactive state for the table - initialized properly\n\tlet tableState = $state<TableState>({\n\t\tcolumnFilters: [],\n\t\tcolumnOrder: [],\n\t\tcolumnPinning: { left: [], right: [] },\n\t\tcolumnSizing: {},\n\t\tcolumnSizingInfo: {\n\t\t\tcolumnSizingStart: [],\n\t\t\tdeltaOffset: null,\n\t\t\tdeltaPercentage: null,\n\t\t\tisResizingColumn: false,\n\t\t\tstartOffset: null,\n\t\t\tstartSize: null\n\t\t},\n\t\tcolumnVisibility: {},\n\t\texpanded: {},\n\t\tglobalFilter: undefined,\n\t\tgrouping: [],\n\t\tpagination: {\n\t\t\tpageIndex: 0,\n\t\t\tpageSize: 10\n\t\t},\n\t\trowPinning: { top: [], bottom: [] },\n\t\trowSelection: {},\n\t\tsorting: []\n\t});\n\n\t// Build the resolved options\n\tconst resolvedOptions: TableOptionsResolved<TData> = {\n\t\t...options,\n\t\tgetCoreRowModel: options.getCoreRowModel ?? getCoreRowModel(),\n\t\tstate: {\n\t\t\t...tableState,\n\t\t\t...options.state\n\t\t},\n\t\tonStateChange: (updater: Updater<TableState>) => {\n\t\t\t// Update our reactive state\n\t\t\tif (typeof updater === 'function') {\n\t\t\t\ttableState = updater(tableState);\n\t\t\t} else {\n\t\t\t\ttableState = updater;\n\t\t\t}\n\n\t\t\t// Call user's onStateChange if provided\n\t\t\toptions.onStateChange?.(updater);\n\t\t},\n\t\trenderFallbackValue: null\n\t} as TableOptionsResolved<TData>;\n\n\tconst table = createTable(resolvedOptions);\n\n\t// Initialize state from table's initial state\n\ttableState = { ...tableState, ...table.initialState };\n\n\t// Create effect to update table options when they change\n\t$effect(() => {\n\t\ttable.setOptions((prev) => ({\n\t\t\t...prev,\n\t\t\t...options,\n\t\t\tstate: {\n\t\t\t\t...tableState,\n\t\t\t\t...options.state\n\t\t\t},\n\t\t\tonStateChange: (updater: Updater<TableState>) => {\n\t\t\t\tif (typeof updater === 'function') {\n\t\t\t\t\ttableState = updater(tableState);\n\t\t\t\t} else {\n\t\t\t\t\ttableState = updater;\n\t\t\t\t}\n\t\t\t\toptions.onStateChange?.(updater);\n\t\t\t}\n\t\t}));\n\t});\n\n\treturn table;\n}\n\n/**\n * Helper to create table options with reactive data\n * Use this when you want to pass reactive data to the table\n *\n * @example\n * ```svelte\n * <script lang=\"ts\">\n *   let data = $state([...]);\n *   let sorting = $state([]);\n *\n *   const table = createSvelteTable(\n *     tableOptions(() => ({\n *       data,\n *       columns,\n *       state: { sorting },\n *       onSortingChange: (updater) => {\n *         sorting = typeof updater === 'function' ? updater(sorting) : updater;\n *       }\n *     }))\n *   );\n * </script>\n * ```\n */\nexport function tableOptions<TData extends RowData>(\n\tgetOptions: () => CreateSvelteTableOptions<TData>\n): CreateSvelteTableOptions<TData> {\n\t// This is a helper that makes the pattern clearer\n\t// The actual reactivity comes from the $effect in createSvelteTable\n\treturn getOptions();\n}\n\n// Re-export useful types and functions from table-core\nexport {\n\tcreateColumnHelper,\n\ttype ColumnDef,\n\ttype ColumnHelper,\n\ttype Row,\n\ttype Cell,\n\ttype Header,\n\ttype HeaderGroup,\n\ttype Column,\n\ttype Table,\n\ttype TableState,\n\ttype SortingState,\n\ttype ColumnFiltersState,\n\ttype VisibilityState,\n\ttype RowSelectionState,\n\ttype PaginationState,\n\ttype Updater\n} from '@tanstack/table-core';\n",
			"type": "registry:lib",
			"target": "create-svelte-table.svelte.ts"
		},
		{
			"content": "<script lang=\"ts\" module>\n\timport type { Component, Snippet } from 'svelte';\n\n\t// Types for FlexRender content\n\texport type FlexRenderContent<TProps extends Record<string, unknown>> =\n\t\t| string\n\t\t| number\n\t\t| boolean\n\t\t| null\n\t\t| undefined\n\t\t| Component<TProps>\n\t\t| Snippet<[TProps]>\n\t\t| ((props: TProps) => string | number | null | undefined)\n\t\t| { component: Component<TProps>; props: TProps }\n\t\t| { snippet: Snippet<[TProps]>; props: TProps };\n</script>\n\n<script lang=\"ts\">\n\timport { isComponentRender, isSnippetRender } from './render-helpers';\n\n\tinterface Props {\n\t\tcontent: unknown;\n\t\tcontext: Record<string, unknown>;\n\t}\n\n\tlet { content, context }: Props = $props();\n\n\t// Determine what type of content we're dealing with\n\tconst contentInfo = $derived.by(() => {\n\t\tif (content === null || content === undefined) {\n\t\t\treturn { type: 'empty' as const, value: '' };\n\t\t}\n\n\t\tif (typeof content === 'string' || typeof content === 'number' || typeof content === 'boolean') {\n\t\t\treturn { type: 'primitive' as const, value: String(content) };\n\t\t}\n\n\t\t// Check for renderComponent result\n\t\tif (isComponentRender(content)) {\n\t\t\treturn { type: 'component-render' as const, value: content };\n\t\t}\n\n\t\t// Check for renderSnippet result\n\t\tif (isSnippetRender(content)) {\n\t\t\treturn { type: 'snippet-render' as const, value: content };\n\t\t}\n\n\t\tif (typeof content === 'function') {\n\t\t\t// Could be a component, snippet, or render function\n\t\t\tconst fn = content as Function;\n\n\t\t\t// Try calling it as a function first\n\t\t\ttry {\n\t\t\t\tconst result = (fn as (props: Record<string, unknown>) => unknown)(context);\n\n\t\t\t\t// Check if the result is a component render or snippet render\n\t\t\t\tif (isComponentRender(result)) {\n\t\t\t\t\treturn { type: 'component-render' as const, value: result };\n\t\t\t\t}\n\t\t\t\tif (isSnippetRender(result)) {\n\t\t\t\t\treturn { type: 'snippet-render' as const, value: result };\n\t\t\t\t}\n\n\t\t\t\t// Otherwise treat it as a primitive result\n\t\t\t\tif (result !== null && result !== undefined) {\n\t\t\t\t\treturn { type: 'primitive' as const, value: String(result) };\n\t\t\t\t}\n\t\t\t\treturn { type: 'empty' as const, value: '' };\n\t\t\t} catch {\n\t\t\t\t// If calling as function fails, try treating as component\n\t\t\t\treturn { type: 'component' as const, value: fn as Component<Record<string, unknown>> };\n\t\t\t}\n\t\t}\n\n\t\treturn { type: 'empty' as const, value: '' };\n\t});\n</script>\n\n{#if contentInfo.type === 'primitive'}\n\t{contentInfo.value}\n{:else if contentInfo.type === 'component'}\n\t{@const Comp = contentInfo.value}\n\t<Comp {...context} />\n{:else if contentInfo.type === 'component-render'}\n\t{@const { component: Comp, props } = contentInfo.value}\n\t<Comp {...props} />\n{:else if contentInfo.type === 'snippet-render'}\n\t{@const { snippet, props } = contentInfo.value}\n\t{@render snippet(props)}\n{/if}\n",
			"type": "registry:component",
			"target": "flex-render.svelte"
		},
		{
			"content": "// Helper functions for rendering cells and headers in TanStack Table\n// These provide type-safe ways to use Svelte components and snippets in column definitions\n\nimport type { Component, Snippet } from 'svelte';\n\n/**\n * Wraps a Svelte component for use in column cell/header definitions\n *\n * @example\n * ```ts\n * const columns = [\n *   {\n *     accessorKey: 'actions',\n *     cell: ({ row }) => renderComponent(ActionCell, { row })\n *   }\n * ];\n * ```\n */\nexport function renderComponent<TProps extends Record<string, unknown>>(\n\tcomponent: Component<TProps>,\n\tprops: TProps\n): { component: Component<TProps>; props: TProps } {\n\treturn { component, props };\n}\n\n/**\n * Wraps a Snippet for use in column cell/header definitions\n *\n * @example\n * ```svelte\n * {#snippet actionCell(props: { row: Row<Data> })}\n *   <button>Edit</button>\n * {/snippet}\n *\n * <script>\n *   const columns = [\n *     {\n *       accessorKey: 'actions',\n *       cell: ({ row }) => renderSnippet(actionCell, { row })\n *     }\n *   ];\n * </script>\n * ```\n */\nexport function renderSnippet<TProps>(\n\tsnippet: Snippet<[TProps]>,\n\tprops: TProps\n): { snippet: Snippet<[TProps]>; props: TProps } {\n\treturn { snippet, props };\n}\n\n/**\n * Type guard to check if a value is a component render result\n */\nexport function isComponentRender<TProps extends Record<string, unknown>>(\n\tvalue: unknown\n): value is { component: Component<TProps>; props: TProps } {\n\treturn (\n\t\ttypeof value === 'object' &&\n\t\tvalue !== null &&\n\t\t'component' in value &&\n\t\t'props' in value &&\n\t\ttypeof (value as { component: unknown }).component === 'function'\n\t);\n}\n\n/**\n * Type guard to check if a value is a snippet render result\n */\nexport function isSnippetRender<TProps>(\n\tvalue: unknown\n): value is { snippet: Snippet<[TProps]>; props: TProps } {\n\treturn (\n\t\ttypeof value === 'object' &&\n\t\tvalue !== null &&\n\t\t'snippet' in value &&\n\t\t'props' in value &&\n\t\ttypeof (value as { snippet: unknown }).snippet === 'function'\n\t);\n}\n",
			"type": "registry:lib",
			"target": "render-helpers.ts"
		},
		{
			"content": "// TanStack Table integration for Svelte 5\n// Re-exports from shadcn-svelte data-table components\n\n// Core table creation\nexport { createSvelteTable } from '$lib/components/ui/data-table/data-table.svelte.js';\n\n// FlexRender component\nexport { default as FlexRender } from '$lib/components/ui/data-table/flex-render.svelte';\n\n// Render helpers\nexport {\n\trenderComponent,\n\trenderSnippet,\n\tRenderComponentConfig,\n\tRenderSnippetConfig\n} from '$lib/components/ui/data-table/render-helpers.js';\n\n// Type exports\nimport type { TableOptions, RowData } from '@tanstack/table-core';\nimport { RenderComponentConfig, RenderSnippetConfig } from '$lib/components/ui/data-table/render-helpers.js';\n\nexport type FlexRenderContent<TProps extends Record<string, unknown>> =\n\t| string\n\t| ((props: TProps) => unknown);\n\n// Helper function to check if content is a component render config\nexport function isComponentRender(content: unknown): boolean {\n\treturn content instanceof RenderComponentConfig;\n}\n\n// Helper function to check if content is a snippet render config\nexport function isSnippetRender(content: unknown): boolean {\n\treturn content instanceof RenderSnippetConfig;\n}\n\n// Table options helper - utility for creating typed table options\nexport function tableOptions<TData extends RowData>(\n\toptions: TableOptions<TData>\n): TableOptions<TData> {\n\treturn options;\n}\n\n// Re-export useful types from table-core\nexport {\n\tcreateColumnHelper,\n\tgetCoreRowModel,\n\tgetSortedRowModel,\n\tgetFilteredRowModel,\n\tgetPaginationRowModel,\n\tgetExpandedRowModel,\n\tgetGroupedRowModel,\n\tgetFacetedRowModel,\n\tgetFacetedUniqueValues,\n\tgetFacetedMinMaxValues,\n\ttype ColumnDef,\n\ttype ColumnHelper,\n\ttype Row,\n\ttype Cell,\n\ttype Header,\n\ttype HeaderGroup,\n\ttype Column,\n\ttype Table,\n\ttype TableState,\n\ttype SortingState,\n\ttype ColumnFiltersState,\n\ttype VisibilityState,\n\ttype RowSelectionState,\n\ttype PaginationState,\n\ttype ExpandedState,\n\ttype GroupingState,\n\ttype ColumnSizingState,\n\ttype ColumnPinningState,\n\ttype Updater,\n\ttype OnChangeFn,\n\ttype RowData,\n\ttype CellContext,\n\ttype HeaderContext,\n\ttype ColumnDefTemplate\n} from '@tanstack/table-core';\n",
			"type": "registry:lib",
			"target": "index.ts"
		},
		{
			"content": "// TanStack Virtual integration for Svelte 5\n// This creates a reactive virtualizer instance using Svelte 5 runes\n\nimport {\n\tVirtualizer,\n\telementScroll,\n\tobserveElementOffset,\n\tobserveElementRect,\n\tobserveWindowOffset,\n\tobserveWindowRect,\n\twindowScroll,\n\ttype VirtualizerOptions,\n\ttype VirtualItem\n} from '@tanstack/virtual-core';\n\n// ============================================\n// Types\n// ============================================\n\nexport interface CreateVirtualizerOptions<TScrollElement extends Element | Window> {\n\t/** Total count of items to virtualize */\n\tcount: number;\n\t/** Function to get the scroll container element */\n\tgetScrollElement: () => TScrollElement | null;\n\t/** Function to estimate the size of an item */\n\testimateSize: (index: number) => number;\n\t/** Number of items to render outside the visible area */\n\toverscan?: number;\n\t/** Padding at the start of the list */\n\tpaddingStart?: number;\n\t/** Padding at the end of the list */\n\tpaddingEnd?: number;\n\t/** Whether to virtualize horizontally */\n\thorizontal?: boolean;\n\t/** Function to get a unique key for an item */\n\tgetItemKey?: (index: number) => string | number;\n\t/** Called when the virtualizer state changes */\n\tonChange?: (instance: Virtualizer<TScrollElement, Element>) => void;\n\t/** Initial scroll offset */\n\tinitialOffset?: number;\n\t/** Whether to enable smooth scrolling */\n\tscrollBehavior?: ScrollBehavior;\n}\n\nexport interface VirtualizerReturn<TScrollElement extends Element | Window> {\n\t/** Array of virtual items currently visible (plus overscan) */\n\treadonly virtualItems: VirtualItem[];\n\t/** Total size of the virtualized list in pixels */\n\treadonly totalSize: number;\n\t/** Current scroll offset */\n\treadonly scrollOffset: number;\n\t/** Whether the virtualizer is currently scrolling */\n\treadonly isScrolling: boolean;\n\t/** Scroll to a specific index */\n\tscrollToIndex: (\n\t\tindex: number,\n\t\toptions?: { align?: 'start' | 'center' | 'end'; behavior?: 'auto' | 'smooth' }\n\t) => void;\n\t/** Scroll to a specific offset */\n\tscrollToOffset: (offset: number, options?: { behavior?: 'auto' | 'smooth' }) => void;\n\t/** Measure a specific element */\n\tmeasureElement: (element: Element | null) => void;\n\t/** Get the virtualizer instance */\n\treadonly instance: Virtualizer<TScrollElement, Element> | null;\n\t/** Force re-measure all items */\n\tmeasure: () => void;\n}\n\n// ============================================\n// Element Virtualizer\n// ============================================\n\n/**\n * Creates a reactive virtualizer for scrollable elements\n *\n * @example\n * ```svelte\n * <script lang=\"ts\">\n *   import { createSvelteVirtualizer } from '$lib/virtual';\n *\n *   let scrollElement: HTMLDivElement | null = $state(null);\n *   let items = $state([...]);\n *\n *   const virtualizer = createSvelteVirtualizer({\n *     get count() { return items.length },\n *     getScrollElement: () => scrollElement,\n *     estimateSize: () => 50,\n *   });\n * </script>\n *\n * <div bind:this={scrollElement} class=\"h-[400px] overflow-auto\">\n *   <div style:height=\"{virtualizer.totalSize}px\" style:position=\"relative\">\n *     {#each virtualizer.virtualItems as item (item.key)}\n *       <div\n *         style:position=\"absolute\"\n *         style:top=\"{item.start}px\"\n *         style:height=\"{item.size}px\"\n *       >\n *         {items[item.index]}\n *       </div>\n *     {/each}\n *   </div>\n * </div>\n * ```\n */\nexport function createSvelteVirtualizer<TScrollElement extends Element>(\n\toptions: CreateVirtualizerOptions<TScrollElement>\n): VirtualizerReturn<TScrollElement> {\n\t// Reactive state\n\tlet virtualItems = $state<VirtualItem[]>([]);\n\tlet totalSize = $state(0);\n\tlet scrollOffset = $state(0);\n\tlet isScrolling = $state(false);\n\n\tlet instance: Virtualizer<TScrollElement, Element> | null = null;\n\n\t// Effect to create/update virtualizer\n\t$effect(() => {\n\t\tconst scrollElement = options.getScrollElement();\n\n\t\tif (!scrollElement) {\n\t\t\tvirtualItems = [];\n\t\t\ttotalSize = 0;\n\t\t\tscrollOffset = 0;\n\t\t\tinstance = null;\n\t\t\treturn;\n\t\t}\n\n\t\t// Create new virtualizer instance\n\t\tinstance = new Virtualizer<TScrollElement, Element>({\n\t\t\tcount: options.count,\n\t\t\tgetScrollElement: () => scrollElement,\n\t\t\testimateSize: options.estimateSize,\n\t\t\toverscan: options.overscan ?? 3,\n\t\t\tpaddingStart: options.paddingStart ?? 0,\n\t\t\tpaddingEnd: options.paddingEnd ?? 0,\n\t\t\thorizontal: options.horizontal ?? false,\n\t\t\tgetItemKey: options.getItemKey,\n\t\t\tinitialOffset: options.initialOffset,\n\n\t\t\t// Element-specific observers\n\t\t\tobserveElementRect,\n\t\t\tobserveElementOffset,\n\t\t\tscrollToFn: elementScroll,\n\n\t\t\t// Update reactive state on change\n\t\t\tonChange: (inst) => {\n\t\t\t\tvirtualItems = inst.getVirtualItems();\n\t\t\t\ttotalSize = inst.getTotalSize();\n\t\t\t\tscrollOffset = inst.scrollOffset ?? 0;\n\t\t\t\tisScrolling = inst.isScrolling;\n\t\t\t\toptions.onChange?.(inst);\n\t\t\t}\n\t\t});\n\n\t\t// Trigger initial measurement\n\t\tinstance._willUpdate();\n\n\t\t// Cleanup\n\t\treturn () => {\n\t\t\tinstance = null;\n\t\t};\n\t});\n\n\treturn {\n\t\tget virtualItems() {\n\t\t\treturn virtualItems;\n\t\t},\n\t\tget totalSize() {\n\t\t\treturn totalSize;\n\t\t},\n\t\tget scrollOffset() {\n\t\t\treturn scrollOffset;\n\t\t},\n\t\tget isScrolling() {\n\t\t\treturn isScrolling;\n\t\t},\n\t\tget instance() {\n\t\t\treturn instance;\n\t\t},\n\n\t\tscrollToIndex(index, opts) {\n\t\t\tinstance?.scrollToIndex(index, opts as any);\n\t\t},\n\n\t\tscrollToOffset(offset, opts) {\n\t\t\tinstance?.scrollToOffset(offset, opts as any);\n\t\t},\n\n\t\tmeasureElement(element) {\n\t\t\tif (element) {\n\t\t\t\tinstance?.measureElement(element);\n\t\t\t}\n\t\t},\n\n\t\tmeasure() {\n\t\t\tinstance?._willUpdate();\n\t\t}\n\t};\n}\n\n// ============================================\n// Window Virtualizer\n// ============================================\n\n/**\n * Creates a reactive virtualizer that uses the window as the scroll container\n *\n * @example\n * ```svelte\n * <script lang=\"ts\">\n *   import { createWindowVirtualizer } from '$lib/virtual';\n *\n *   let items = $state([...]);\n *\n *   const virtualizer = createWindowVirtualizer({\n *     get count() { return items.length },\n *     estimateSize: () => 50,\n *   });\n * </script>\n *\n * <div style:height=\"{virtualizer.totalSize}px\" style:position=\"relative\">\n *   {#each virtualizer.virtualItems as item (item.key)}\n *     <div\n *       style:position=\"absolute\"\n *       style:top=\"{item.start}px\"\n *       style:height=\"{item.size}px\"\n *     >\n *       {items[item.index]}\n *     </div>\n *   {/each}\n * </div>\n * ```\n */\nexport function createWindowVirtualizer(\n\toptions: Omit<CreateVirtualizerOptions<Window>, 'getScrollElement'>\n): VirtualizerReturn<Window> {\n\t// Reactive state\n\tlet virtualItems = $state<VirtualItem[]>([]);\n\tlet totalSize = $state(0);\n\tlet scrollOffset = $state(0);\n\tlet isScrolling = $state(false);\n\n\tlet instance: Virtualizer<Window, Element> | null = null;\n\n\t// Effect to create/update virtualizer\n\t$effect(() => {\n\t\t// Only run on client\n\t\tif (typeof window === 'undefined') {\n\t\t\treturn;\n\t\t}\n\n\t\t// Create new virtualizer instance\n\t\tinstance = new Virtualizer<Window, Element>({\n\t\t\tcount: options.count,\n\t\t\tgetScrollElement: () => window,\n\t\t\testimateSize: options.estimateSize,\n\t\t\toverscan: options.overscan ?? 3,\n\t\t\tpaddingStart: options.paddingStart ?? 0,\n\t\t\tpaddingEnd: options.paddingEnd ?? 0,\n\t\t\thorizontal: options.horizontal ?? false,\n\t\t\tgetItemKey: options.getItemKey,\n\t\t\tinitialOffset: options.initialOffset,\n\n\t\t\t// Window-specific observers\n\t\t\tobserveElementRect: observeWindowRect,\n\t\t\tobserveElementOffset: observeWindowOffset,\n\t\t\tscrollToFn: windowScroll,\n\n\t\t\t// Update reactive state on change\n\t\t\tonChange: (inst) => {\n\t\t\t\tvirtualItems = inst.getVirtualItems();\n\t\t\t\ttotalSize = inst.getTotalSize();\n\t\t\t\tscrollOffset = inst.scrollOffset ?? 0;\n\t\t\t\tisScrolling = inst.isScrolling;\n\t\t\t\toptions.onChange?.(inst as Virtualizer<Window, Element>);\n\t\t\t}\n\t\t});\n\n\t\t// Trigger initial measurement\n\t\tinstance._willUpdate();\n\n\t\t// Cleanup\n\t\treturn () => {\n\t\t\tinstance = null;\n\t\t};\n\t});\n\n\treturn {\n\t\tget virtualItems() {\n\t\t\treturn virtualItems;\n\t\t},\n\t\tget totalSize() {\n\t\t\treturn totalSize;\n\t\t},\n\t\tget scrollOffset() {\n\t\t\treturn scrollOffset;\n\t\t},\n\t\tget isScrolling() {\n\t\t\treturn isScrolling;\n\t\t},\n\t\tget instance() {\n\t\t\treturn instance;\n\t\t},\n\n\t\tscrollToIndex(index, opts) {\n\t\t\tinstance?.scrollToIndex(index, opts as any);\n\t\t},\n\n\t\tscrollToOffset(offset, opts) {\n\t\t\tinstance?.scrollToOffset(offset, opts as any);\n\t\t},\n\n\t\tmeasureElement(element) {\n\t\t\tif (element) {\n\t\t\t\tinstance?.measureElement(element);\n\t\t\t}\n\t\t},\n\n\t\tmeasure() {\n\t\t\tinstance?._willUpdate();\n\t\t}\n\t};\n}\n\n// Re-export types from virtual-core\nexport type { VirtualItem, VirtualizerOptions } from '@tanstack/virtual-core';\n",
			"type": "registry:lib",
			"target": "create-svelte-virtualizer.svelte.ts"
		},
		{
			"content": "// TanStack Virtual integration for Svelte 5\n// Re-exports from the .svelte.ts implementation\nexport {\n\tcreateSvelteVirtualizer,\n\tcreateWindowVirtualizer,\n\ttype CreateVirtualizerOptions,\n\ttype VirtualizerReturn\n} from './create-svelte-virtualizer.svelte.js';\n\n// Re-export types from virtual-core\nexport type { VirtualItem, VirtualizerOptions } from '@tanstack/virtual-core';\n",
			"type": "registry:lib",
			"target": "index.ts"
		},
		{
			"content": "// Keyboard handling utilities for DataGrid\nimport type { DataGridStore } from '$lib/stores/data-grid.svelte';\nimport { KEYBOARD_SHORTCUTS } from '$lib/config/data-grid';\n\nexport type KeyboardAction =\n\t| 'navigate-up'\n\t| 'navigate-down'\n\t| 'navigate-left'\n\t| 'navigate-right'\n\t| 'navigate-home'\n\t| 'navigate-end'\n\t| 'navigate-first'\n\t| 'navigate-last'\n\t| 'select-all'\n\t| 'copy'\n\t| 'cut'\n\t| 'paste'\n\t| 'delete'\n\t| 'edit'\n\t| 'cancel'\n\t| 'search'\n\t| 'next-match'\n\t| 'prev-match'\n\t| 'undo'\n\t| 'redo';\n\nexport interface KeyBinding {\n\tkey: string;\n\tctrl?: boolean;\n\tmeta?: boolean;\n\tshift?: boolean;\n\talt?: boolean;\n}\n\nexport const DEFAULT_KEY_BINDINGS: Record<KeyboardAction, KeyBinding[]> = {\n\t'navigate-up': [{ key: 'ArrowUp' }],\n\t'navigate-down': [{ key: 'ArrowDown' }],\n\t'navigate-left': [{ key: 'ArrowLeft' }, { key: 'Tab', shift: true }],\n\t'navigate-right': [{ key: 'ArrowRight' }, { key: 'Tab' }],\n\t'navigate-home': [{ key: 'Home' }],\n\t'navigate-end': [{ key: 'End' }],\n\t'navigate-first': [{ key: 'Home', ctrl: true }],\n\t'navigate-last': [{ key: 'End', ctrl: true }],\n\t'select-all': [{ key: 'a', ctrl: true }, { key: 'a', meta: true }],\n\tcopy: [{ key: 'c', ctrl: true }, { key: 'c', meta: true }],\n\tcut: [{ key: 'x', ctrl: true }, { key: 'x', meta: true }],\n\tpaste: [{ key: 'v', ctrl: true }, { key: 'v', meta: true }],\n\tdelete: [{ key: 'Delete' }, { key: 'Backspace' }],\n\tedit: [{ key: 'Enter' }, { key: 'F2' }],\n\tcancel: [{ key: 'Escape' }],\n\tsearch: [{ key: 'f', ctrl: true }, { key: 'f', meta: true }],\n\t'next-match': [{ key: 'F3' }, { key: 'g', ctrl: true }, { key: 'g', meta: true }],\n\t'prev-match': [\n\t\t{ key: 'F3', shift: true },\n\t\t{ key: 'g', ctrl: true, shift: true },\n\t\t{ key: 'g', meta: true, shift: true }\n\t],\n\tundo: [{ key: 'z', ctrl: true }, { key: 'z', meta: true }],\n\tredo: [\n\t\t{ key: 'z', ctrl: true, shift: true },\n\t\t{ key: 'z', meta: true, shift: true },\n\t\t{ key: 'y', ctrl: true },\n\t\t{ key: 'y', meta: true }\n\t]\n};\n\n/**\n * Checks if a keyboard event matches a key binding\n */\nexport function matchesKeyBinding(event: KeyboardEvent, binding: KeyBinding): boolean {\n\tconst keyMatches = event.key.toLowerCase() === binding.key.toLowerCase();\n\tconst ctrlMatches = binding.ctrl ? event.ctrlKey : !event.ctrlKey;\n\tconst metaMatches = binding.meta ? event.metaKey : !event.metaKey;\n\tconst shiftMatches = binding.shift ? event.shiftKey : !event.shiftKey;\n\tconst altMatches = binding.alt ? event.altKey : !event.altKey;\n\n\t// Handle modifier keys - allow either ctrl or meta for cross-platform\n\tif (binding.ctrl || binding.meta) {\n\t\treturn keyMatches && (event.ctrlKey || event.metaKey) && shiftMatches && altMatches;\n\t}\n\n\treturn keyMatches && ctrlMatches && metaMatches && shiftMatches && altMatches;\n}\n\n/**\n * Gets the keyboard action from a keyboard event\n */\nexport function getKeyboardAction(event: KeyboardEvent): KeyboardAction | null {\n\tfor (const [action, bindings] of Object.entries(DEFAULT_KEY_BINDINGS)) {\n\t\tfor (const binding of bindings) {\n\t\t\tif (matchesKeyBinding(event, binding)) {\n\t\t\t\treturn action as KeyboardAction;\n\t\t\t}\n\t\t}\n\t}\n\treturn null;\n}\n\n/**\n * Creates a keyboard event handler for the data grid\n */\nexport function createKeyboardHandler(\n\tstore: DataGridStore<any>,\n\toptions: {\n\t\tonCopy?: () => void;\n\t\tonCut?: () => void;\n\t\tonPaste?: () => void;\n\t\tonDelete?: () => void;\n\t\tonUndo?: () => void;\n\t\tonRedo?: () => void;\n\t} = {}\n) {\n\treturn function handleKeydown(event: KeyboardEvent): void {\n\t\tconst action = getKeyboardAction(event);\n\n\t\tif (!action) {\n\t\t\t// Handle character keys for quick edit\n\t\t\tif (\n\t\t\t\tevent.key.length === 1 &&\n\t\t\t\t!event.ctrlKey &&\n\t\t\t\t!event.metaKey &&\n\t\t\t\t!event.altKey &&\n\t\t\t\tstore.focusedCell &&\n\t\t\t\t!store.isEditing &&\n\t\t\t\t!store.readOnly\n\t\t\t) {\n\t\t\t\t// Start editing and type the character\n\t\t\t\tstore.startEditing(store.focusedCell);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// Prevent default for handled actions\n\t\tconst handledActions: KeyboardAction[] = [\n\t\t\t'navigate-up',\n\t\t\t'navigate-down',\n\t\t\t'navigate-left',\n\t\t\t'navigate-right',\n\t\t\t'navigate-home',\n\t\t\t'navigate-end',\n\t\t\t'navigate-first',\n\t\t\t'navigate-last',\n\t\t\t'select-all',\n\t\t\t'search',\n\t\t\t'next-match',\n\t\t\t'prev-match',\n\t\t\t'edit',\n\t\t\t'cancel'\n\t\t];\n\n\t\tif (handledActions.includes(action)) {\n\t\t\tevent.preventDefault();\n\t\t}\n\n\t\t// Don't handle most actions while editing\n\t\tif (store.isEditing) {\n\t\t\tif (action === 'cancel') {\n\t\t\t\tstore.stopEditing();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (action) {\n\t\t\tcase 'navigate-up':\n\t\t\t\tif (event.shiftKey && store.focusedCell && store.selectionRange) {\n\t\t\t\t\t// Extend selection\n\t\t\t\t\tconst newEnd = {\n\t\t\t\t\t\trowIndex: Math.max(0, store.selectionRange.end.rowIndex - 1),\n\t\t\t\t\t\tcolumnId: store.selectionRange.end.columnId\n\t\t\t\t\t};\n\t\t\t\t\tstore.selectRange(store.selectionRange.start, newEnd);\n\t\t\t\t} else {\n\t\t\t\t\tstore.moveFocus('up');\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'navigate-down':\n\t\t\t\tif (event.shiftKey && store.focusedCell && store.selectionRange) {\n\t\t\t\t\tconst newEnd = {\n\t\t\t\t\t\trowIndex: Math.min(store.data.length - 1, store.selectionRange.end.rowIndex + 1),\n\t\t\t\t\t\tcolumnId: store.selectionRange.end.columnId\n\t\t\t\t\t};\n\t\t\t\t\tstore.selectRange(store.selectionRange.start, newEnd);\n\t\t\t\t} else {\n\t\t\t\t\tstore.moveFocus('down');\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'navigate-left':\n\t\t\t\tstore.moveFocus('left');\n\t\t\t\tbreak;\n\n\t\t\tcase 'navigate-right':\n\t\t\t\tstore.moveFocus('right');\n\t\t\t\tbreak;\n\n\t\t\tcase 'navigate-home':\n\t\t\t\tstore.moveFocus('home');\n\t\t\t\tbreak;\n\n\t\t\tcase 'navigate-end':\n\t\t\t\tstore.moveFocus('end');\n\t\t\t\tbreak;\n\n\t\t\tcase 'navigate-first':\n\t\t\t\tstore.moveToFirstCell();\n\t\t\t\tbreak;\n\n\t\t\tcase 'navigate-last':\n\t\t\t\tstore.moveToLastCell();\n\t\t\t\tbreak;\n\n\t\t\tcase 'select-all':\n\t\t\t\tstore.selectAll();\n\t\t\t\tbreak;\n\n\t\t\tcase 'copy':\n\t\t\t\toptions.onCopy?.();\n\t\t\t\tbreak;\n\n\t\t\tcase 'cut':\n\t\t\t\tif (!store.readOnly) {\n\t\t\t\t\tstore.markCellsAsCut();\n\t\t\t\t\toptions.onCut?.();\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'paste':\n\t\t\t\tif (!store.readOnly) {\n\t\t\t\t\toptions.onPaste?.();\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'delete':\n\t\t\t\tif (!store.readOnly) {\n\t\t\t\t\toptions.onDelete?.();\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'edit':\n\t\t\t\tif (!store.readOnly && store.focusedCell) {\n\t\t\t\t\tstore.startEditing(store.focusedCell);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'cancel':\n\t\t\t\tif (store.searchState.searchOpen) {\n\t\t\t\t\tstore.closeSearch();\n\t\t\t\t} else {\n\t\t\t\t\tstore.clearSelection();\n\t\t\t\t\tstore.clearCut();\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'search':\n\t\t\t\tstore.openSearch();\n\t\t\t\tbreak;\n\n\t\t\tcase 'next-match':\n\t\t\t\tstore.nextMatch();\n\t\t\t\tbreak;\n\n\t\t\tcase 'prev-match':\n\t\t\t\tstore.previousMatch();\n\t\t\t\tbreak;\n\n\t\t\tcase 'undo':\n\t\t\t\toptions.onUndo?.();\n\t\t\t\tbreak;\n\n\t\t\tcase 'redo':\n\t\t\t\toptions.onRedo?.();\n\t\t\t\tbreak;\n\t\t}\n\t};\n}\n\n/**\n * Formats a key binding for display\n */\nexport function formatKeyBinding(binding: KeyBinding): string {\n\tconst parts: string[] = [];\n\n\tif (binding.ctrl || binding.meta) {\n\t\tparts.push(navigator.platform.includes('Mac') ? '' : 'Ctrl');\n\t}\n\tif (binding.shift) {\n\t\tparts.push('Shift');\n\t}\n\tif (binding.alt) {\n\t\tparts.push(navigator.platform.includes('Mac') ? '' : 'Alt');\n\t}\n\n\t// Format the key\n\tlet key = binding.key;\n\tconst keyMap: Record<string, string> = {\n\t\tArrowUp: '',\n\t\tArrowDown: '',\n\t\tArrowLeft: '',\n\t\tArrowRight: '',\n\t\tEnter: '',\n\t\tEscape: 'Esc',\n\t\tDelete: 'Del',\n\t\tBackspace: '',\n\t\tTab: '',\n\t\tHome: 'Home',\n\t\tEnd: 'End'\n\t};\n\tkey = keyMap[key] || key.toUpperCase();\n\n\tparts.push(key);\n\treturn parts.join('+');\n}\n",
			"type": "registry:lib",
			"target": "keyboard.ts"
		}
	]
}